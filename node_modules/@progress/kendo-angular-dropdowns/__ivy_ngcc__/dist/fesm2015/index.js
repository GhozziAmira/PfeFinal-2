/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { EventEmitter, Component, Renderer2, Input, Output, ViewChild, HostBinding, Directive, TemplateRef, Injectable, ElementRef, ChangeDetectorRef, NgZone, ViewChildren, forwardRef, isDevMode, ContentChild, ViewContainerRef, InjectionToken, Optional, Inject, KeyValueDiffers, HostListener, NgModule } from '@angular/core';
import { isDocumentAvailable, isChanged, KendoInput, ResizeSensorModule } from '@progress/kendo-angular-common';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import { LocalizationService, L10N_PREFIX, ComponentMessages } from '@progress/kendo-angular-l10n';
import { merge, fromEvent, Subject, Subscription, of, interval } from 'rxjs';
import { map, auditTime, tap, filter, partition, throttleTime, catchError, distinctUntilChanged, skipWhile, concatMap, take, takeUntil } from 'rxjs/operators';
import { PopupService, PopupModule } from '@progress/kendo-angular-popup';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@progress/kendo-angular-l10n';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from '@progress/kendo-angular-popup';
import * as ɵngcc4 from '@progress/kendo-angular-common';
import * as ɵngcc5 from '@angular/forms';

const _c0 = ["input"];
const _c1 = ["content"];
const _c2 = ["list"];
function ListComponent_div_0_1_ng_template_0_Template(rf, ctx) { }
const _c3 = function (a0, a1) { return { templateRef: a0, $implicit: a1 }; };
function ListComponent_div_0_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ListComponent_div_0_1_ng_template_0_Template, 0, 0, "ng-template", 9);
} if (rf & 2) {
    const ctx_r221 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction2(1, _c3, ctx_r221.fixedGroupTemplate.templateRef, ctx_r221.currentGroup));
} }
function ListComponent_div_0_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "strong");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r222 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r222.currentGroup);
} }
const _c4 = function (a0) { return { "k-virtual-item": a0 }; };
const _c5 = function (a0, a1, a2) { return { "height.px": a0, "minHeight.px": a1, "boxSizing": a2 }; };
function ListComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 7);
    ɵngcc0.ɵɵtemplate(1, ListComponent_div_0_1_Template, 1, 4, undefined, 5);
    ɵngcc0.ɵɵtemplate(2, ListComponent_div_0_ng_template_2_Template, 2, 1, "ng-template", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r215 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(4, _c4, ctx_r215.virtual))("ngStyle", ɵngcc0.ɵɵpureFunction3(6, _c5, ctx_r215.virtual == null ? null : ctx_r215.virtual.itemHeight, ctx_r215.virtual == null ? null : ctx_r215.virtual.itemHeight, ctx_r215.virtual ? "border-box" : "inherit"));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r215.fixedGroupTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r215.fixedGroupTemplate);
} }
function ListComponent_5_ng_template_0_1_ng_template_0_Template(rf, ctx) { }
function ListComponent_5_ng_template_0_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ListComponent_5_ng_template_0_1_ng_template_0_Template, 0, 0, "ng-template", 9);
} if (rf & 2) {
    const dataItem_r225 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r227 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction2(1, _c3, ctx_r227.template.templateRef, dataItem_r225));
} }
function ListComponent_5_ng_template_0_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const dataItem_r225 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r228 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r228.getText(dataItem_r225));
} }
const _c6 = function (a0, a1) { return { "k-virtual-item": a0, "k-state-disabled": a1 }; };
function ListComponent_5_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 11);
    ɵngcc0.ɵɵtemplate(1, ListComponent_5_ng_template_0_1_Template, 1, 4, undefined, 5);
    ɵngcc0.ɵɵtemplate(2, ListComponent_5_ng_template_0_ng_template_2_Template, 1, 1, "ng-template", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const dataItem_r225 = ctx.$implicit;
    const itemIndex_r226 = ctx.index;
    const ctx_r224 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("height", ctx_r224.virtual == null ? null : ctx_r224.virtual.itemHeight)("index", itemIndex_r226 + ctx_r224.startFrom)("multipleSelection", ctx_r224.multipleSelection)("ngClass", ɵngcc0.ɵɵpureFunction2(8, _c6, ctx_r224.virtual, ctx_r224.isDisabled(itemIndex_r226)));
    ɵngcc0.ɵɵattribute("id", ctx_r224.optionPrefix + "-" + ctx_r224.getValue(dataItem_r225))("tabIndex", 0 - 1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r224.template);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r224.template);
} }
function ListComponent_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ListComponent_5_ng_template_0_Template, 3, 11, "ng-template", 10);
} if (rf & 2) {
    const ctx_r218 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r218.data);
} }
function ListComponent_6_ng_template_0_li_0_1_ng_template_0_Template(rf, ctx) { }
function ListComponent_6_ng_template_0_li_0_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ListComponent_6_ng_template_0_li_0_1_ng_template_0_Template, 0, 0, "ng-template", 9);
} if (rf & 2) {
    const dataItem_r233 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r237 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction2(1, _c3, ctx_r237.groupTemplate.templateRef, dataItem_r233.value));
} }
function ListComponent_6_ng_template_0_li_0_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "strong");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const dataItem_r233 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", dataItem_r233.value, "");
} }
function ListComponent_6_ng_template_0_li_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 14);
    ɵngcc0.ɵɵtemplate(1, ListComponent_6_ng_template_0_li_0_1_Template, 1, 4, undefined, 5);
    ɵngcc0.ɵɵtemplate(2, ListComponent_6_ng_template_0_li_0_ng_template_2_Template, 2, 1, "ng-template", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const dataItem_r233 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r235 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(7, _c4, ctx_r235.virtual))("ngStyle", ɵngcc0.ɵɵpureFunction3(9, _c5, ctx_r235.virtual == null ? null : ctx_r235.virtual.itemHeight, ctx_r235.virtual == null ? null : ctx_r235.virtual.itemHeight, ctx_r235.virtual ? "border-box" : "inherit"));
    ɵngcc0.ɵɵattribute("group-index", dataItem_r233.index)("id", ctx_r235.optionPrefix + "-" + ctx_r235.getValue(dataItem_r233.value))("tabIndex", 0 - 1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r235.groupTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r235.groupTemplate);
} }
function ListComponent_6_ng_template_0_li_1_1_ng_template_0_Template(rf, ctx) { }
function ListComponent_6_ng_template_0_li_1_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ListComponent_6_ng_template_0_li_1_1_ng_template_0_Template, 0, 0, "ng-template", 9);
} if (rf & 2) {
    const dataItem_r233 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r243 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction2(1, _c3, ctx_r243.template.templateRef, dataItem_r233.value));
} }
function ListComponent_6_ng_template_0_li_1_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const dataItem_r233 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r244 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r244.getText(dataItem_r233.value));
} }
function ListComponent_6_ng_template_0_li_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 11);
    ɵngcc0.ɵɵtemplate(1, ListComponent_6_ng_template_0_li_1_1_Template, 1, 4, undefined, 5);
    ɵngcc0.ɵɵtemplate(2, ListComponent_6_ng_template_0_li_1_ng_template_2_Template, 1, 1, "ng-template", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const dataItem_r233 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r236 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("height", ctx_r236.virtual == null ? null : ctx_r236.virtual.itemHeight)("index", dataItem_r233.offsetIndex)("multipleSelection", ctx_r236.multipleSelection)("ngClass", ɵngcc0.ɵɵpureFunction2(9, _c6, ctx_r236.virtual, ctx_r236.isDisabled(dataItem_r233.offsetIndex)));
    ɵngcc0.ɵɵattribute("absolute-index", dataItem_r233.index)("id", ctx_r236.optionPrefix + "-" + ctx_r236.getValue(dataItem_r233.value))("tabIndex", 0 - 1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r236.template);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r236.template);
} }
function ListComponent_6_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ListComponent_6_ng_template_0_li_0_Template, 3, 13, "li", 12);
    ɵngcc0.ɵɵtemplate(1, ListComponent_6_ng_template_0_li_1_Template, 3, 12, "li", 13);
} if (rf & 2) {
    const dataItem_r233 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("ngIf", dataItem_r233.header && dataItem_r233.index > 0);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !dataItem_r233.header);
} }
function ListComponent_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ListComponent_6_ng_template_0_Template, 2, 2, "ng-template", 10);
} if (rf & 2) {
    const ctx_r219 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r219.data);
} }
function ListComponent_div_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 15);
    ɵngcc0.ɵɵelement(1, "div");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r220 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("height", ctx_r220.scrollHeight, "px");
} }
const _c7 = function (a0, a1) { return { "k-virtual-content": a0, "k-list-scroller": a1 }; };
const _c8 = function (a0) { return { "k-virtual-list": a0 }; };
const _c9 = ["container"];
const _c10 = ["popupTemplate"];
const _c11 = ["optionsList"];
var I18N_12;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text displayed in the popup when there are no items
     * @meaning kendo.autocomplete.noDataText
     */ 
    const MSG_EXTERNAL_2690656529626907484$$DIST_FESM2015_INDEX_JS_13 = goog.getMsg("NO DATA FOUND");
    I18N_12 = MSG_EXTERNAL_2690656529626907484$$DIST_FESM2015_INDEX_JS_13;
}
else {
    I18N_12 = $localize `:kendo.autocomplete.noDataText|The text displayed in the popup when there are no items␟4e9993e088a293543eb0c2801343518c115b6f20␟2690656529626907484:NO DATA FOUND`;
}
var I18N_14;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The title of the clear button
     * @meaning kendo.autocomplete.clearTitle
     */ 
    const MSG_EXTERNAL_4821453594854847070$$DIST_FESM2015_INDEX_JS_15 = goog.getMsg("clear");
    I18N_14 = MSG_EXTERNAL_4821453594854847070$$DIST_FESM2015_INDEX_JS_15;
}
else {
    I18N_14 = $localize `:kendo.autocomplete.clearTitle|The title of the clear button␟7cf49cc2d50eebd29f8d61564512383caaaac7a6␟4821453594854847070:clear`;
}
const _c16 = ["noDataText", I18N_12, "clearTitle", I18N_14];
function AutoCompleteComponent_span_4_Template(rf, ctx) { if (rf & 1) {
    const _r257 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 8);
    ɵngcc0.ɵɵlistener("click", function AutoCompleteComponent_span_4_Template_span_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r257); const ctx_r256 = ɵngcc0.ɵɵnextContext(); return ctx_r256.clearValue($event); })("mousedown", function AutoCompleteComponent_span_4_Template_span_mousedown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r257); return $event.preventDefault(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r250 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("title", ctx_r250.clearTitle);
} }
function AutoCompleteComponent_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 9);
} }
function AutoCompleteComponent_ng_template_6_0_ng_template_0_Template(rf, ctx) { }
const _c17 = function (a0) { return { templateRef: a0 }; };
function AutoCompleteComponent_ng_template_6_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, AutoCompleteComponent_ng_template_6_0_ng_template_0_Template, 0, 0, "ng-template", 14);
} if (rf & 2) {
    const ctx_r259 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction1(1, _c17, ctx_r259.headerTemplate.templateRef));
} }
function AutoCompleteComponent_ng_template_6_div_3_ng_template_1_Template(rf, ctx) { }
function AutoCompleteComponent_ng_template_6_div_3_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r265 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r265.noDataText);
} }
function AutoCompleteComponent_ng_template_6_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 15);
    ɵngcc0.ɵɵtemplate(1, AutoCompleteComponent_ng_template_6_div_3_ng_template_1_Template, 0, 0, "ng-template", 16);
    ɵngcc0.ɵɵtemplate(2, AutoCompleteComponent_ng_template_6_div_3_ng_template_2_Template, 2, 1, "ng-template", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r261 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r261.noDataTemplate)("templateContext", ɵngcc0.ɵɵpureFunction1(3, _c17, ctx_r261.noDataTemplate == null ? null : ctx_r261.noDataTemplate.templateRef));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r261.noDataTemplate);
} }
function AutoCompleteComponent_ng_template_6_4_ng_template_0_Template(rf, ctx) { }
function AutoCompleteComponent_ng_template_6_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, AutoCompleteComponent_ng_template_6_4_ng_template_0_Template, 0, 0, "ng-template", 14);
} if (rf & 2) {
    const ctx_r262 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction1(1, _c17, ctx_r262.footerTemplate.templateRef));
} }
function AutoCompleteComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    const _r268 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵtemplate(0, AutoCompleteComponent_ng_template_6_0_Template, 1, 3, undefined, 10);
    ɵngcc0.ɵɵelementStart(1, "kendo-list", 11, 12);
    ɵngcc0.ɵɵlistener("pageChange", function AutoCompleteComponent_ng_template_6_Template_kendo_list_pageChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r268); const ctx_r267 = ɵngcc0.ɵɵnextContext(); return ctx_r267.pageChange($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, AutoCompleteComponent_ng_template_6_div_3_Template, 3, 5, "div", 13);
    ɵngcc0.ɵɵtemplate(4, AutoCompleteComponent_ng_template_6_4_Template, 1, 3, undefined, 10);
} if (rf & 2) {
    const ctx_r253 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r253.headerTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("id", ctx_r253.listBoxId)("optionPrefix", ctx_r253.optionPrefix)("data", ctx_r253.data)("textField", ctx_r253.valueField)("valueField", ctx_r253.valueField)("template", ctx_r253.template)("groupTemplate", ctx_r253.groupTemplate)("fixedGroupTemplate", ctx_r253.fixedGroupTemplate)("height", ctx_r253.listHeight)("show", ctx_r253.isOpen)("virtual", ctx_r253.virtual);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r253.data.length === 0);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r253.footerTemplate);
} }
function AutoCompleteComponent_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    const _r270 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-resize-sensor", 17);
    ɵngcc0.ɵɵlistener("resize", function AutoCompleteComponent_ng_template_8_Template_kendo_resize_sensor_resize_0_listener() { ɵngcc0.ɵɵrestoreView(_r270); const ctx_r269 = ɵngcc0.ɵɵnextContext(); return ctx_r269.onResize(); });
    ɵngcc0.ɵɵelementEnd();
} }
var I18N_18;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text displayed in the popup when there are no items
     * @meaning kendo.combobox.noDataText
     */ 
    const MSG_EXTERNAL_7708502966028483300$$DIST_FESM2015_INDEX_JS_19 = goog.getMsg("NO DATA FOUND");
    I18N_18 = MSG_EXTERNAL_7708502966028483300$$DIST_FESM2015_INDEX_JS_19;
}
else {
    I18N_18 = $localize `:kendo.combobox.noDataText|The text displayed in the popup when there are no items␟2b6e00c74a6d9c98c03a6274d0224e9bd457ff89␟7708502966028483300:NO DATA FOUND`;
}
var I18N_20;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The title of the clear button
     * @meaning kendo.combobox.clearTitle
     */ 
    const MSG_EXTERNAL_2025597431468961462$$DIST_FESM2015_INDEX_JS_21 = goog.getMsg("clear");
    I18N_20 = MSG_EXTERNAL_2025597431468961462$$DIST_FESM2015_INDEX_JS_21;
}
else {
    I18N_20 = $localize `:kendo.combobox.clearTitle|The title of the clear button␟069e8fae80677e3e785861123bef446b3ff41ab4␟2025597431468961462:clear`;
}
const _c22 = ["noDataText", I18N_18, "clearTitle", I18N_20];
function ComboBoxComponent_span_6_Template(rf, ctx) { if (rf & 1) {
    const _r279 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 11);
    ɵngcc0.ɵɵlistener("click", function ComboBoxComponent_span_6_Template_span_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r279); const ctx_r278 = ɵngcc0.ɵɵnextContext(); return ctx_r278.clearValue($event); })("mousedown", function ComboBoxComponent_span_6_Template_span_mousedown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r279); return $event.preventDefault(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r273 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("title", ctx_r273.clearTitle);
} }
function ComboBoxComponent_ng_template_9_0_ng_template_0_Template(rf, ctx) { }
function ComboBoxComponent_ng_template_9_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ComboBoxComponent_ng_template_9_0_ng_template_0_Template, 0, 0, "ng-template", 16);
} if (rf & 2) {
    const ctx_r281 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction1(1, _c17, ctx_r281.headerTemplate.templateRef));
} }
function ComboBoxComponent_ng_template_9_div_3_ng_template_1_Template(rf, ctx) { }
function ComboBoxComponent_ng_template_9_div_3_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r287 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r287.noDataText);
} }
function ComboBoxComponent_ng_template_9_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 17);
    ɵngcc0.ɵɵtemplate(1, ComboBoxComponent_ng_template_9_div_3_ng_template_1_Template, 0, 0, "ng-template", 18);
    ɵngcc0.ɵɵtemplate(2, ComboBoxComponent_ng_template_9_div_3_ng_template_2_Template, 2, 1, "ng-template", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r283 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r283.noDataTemplate)("templateContext", ɵngcc0.ɵɵpureFunction1(3, _c17, ctx_r283.noDataTemplate ? ctx_r283.noDataTemplate.templateRef : undefined));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r283.noDataTemplate);
} }
function ComboBoxComponent_ng_template_9_4_ng_template_0_Template(rf, ctx) { }
function ComboBoxComponent_ng_template_9_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ComboBoxComponent_ng_template_9_4_ng_template_0_Template, 0, 0, "ng-template", 16);
} if (rf & 2) {
    const ctx_r284 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction1(1, _c17, ctx_r284.footerTemplate.templateRef));
} }
function ComboBoxComponent_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    const _r290 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵtemplate(0, ComboBoxComponent_ng_template_9_0_Template, 1, 3, undefined, 12);
    ɵngcc0.ɵɵelementStart(1, "kendo-list", 13, 14);
    ɵngcc0.ɵɵlistener("pageChange", function ComboBoxComponent_ng_template_9_Template_kendo_list_pageChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r290); const ctx_r289 = ɵngcc0.ɵɵnextContext(); return ctx_r289.pageChange($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, ComboBoxComponent_ng_template_9_div_3_Template, 3, 5, "div", 15);
    ɵngcc0.ɵɵtemplate(4, ComboBoxComponent_ng_template_9_4_Template, 1, 3, undefined, 12);
} if (rf & 2) {
    const ctx_r275 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r275.headerTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("id", ctx_r275.listBoxId)("optionPrefix", ctx_r275.optionPrefix)("data", ctx_r275.data)("textField", ctx_r275.textField)("valueField", ctx_r275.valueField)("template", ctx_r275.template)("groupTemplate", ctx_r275.groupTemplate)("fixedGroupTemplate", ctx_r275.fixedGroupTemplate)("height", ctx_r275.listHeight)("show", ctx_r275.isOpen)("virtual", ctx_r275.virtual);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r275.data.length === 0);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r275.footerTemplate);
} }
function ComboBoxComponent_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    const _r292 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-resize-sensor", 19);
    ɵngcc0.ɵɵlistener("resize", function ComboBoxComponent_ng_template_11_Template_kendo_resize_sensor_resize_0_listener() { ɵngcc0.ɵɵrestoreView(_r292); const ctx_r291 = ɵngcc0.ɵɵnextContext(); return ctx_r291.onResize(); });
    ɵngcc0.ɵɵelementEnd();
} }
const _c23 = function (a0, a1, a2) { return { "k-state-default": a0, "k-state-disabled": a1, "k-state-focused": a2 }; };
const _c24 = ["wrapper"];
var I18N_25;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text displayed in the popup when there are no items
     * @meaning kendo.dropdownlist.noDataText
     */ 
    const MSG_EXTERNAL_8289552890585138350$$DIST_FESM2015_INDEX_JS_26 = goog.getMsg("NO DATA FOUND");
    I18N_25 = MSG_EXTERNAL_8289552890585138350$$DIST_FESM2015_INDEX_JS_26;
}
else {
    I18N_25 = $localize `:kendo.dropdownlist.noDataText|The text displayed in the popup when there are no items␟4fc2f70c9c8cf7b18affd6b938105996d6ac3306␟8289552890585138350:NO DATA FOUND`;
}
const _c27 = ["noDataText", I18N_25];
function DropDownListComponent_5_ng_template_0_Template(rf, ctx) { }
function DropDownListComponent_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DropDownListComponent_5_ng_template_0_Template, 0, 0, "ng-template", 10);
} if (rf & 2) {
    const ctx_r294 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction2(1, _c3, ctx_r294.valueTemplate.templateRef, ctx_r294.dataItem));
} }
function DropDownListComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r295 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate(ctx_r295.getText());
} }
function DropDownListComponent_ng_template_9_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    const _r309 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 14);
    ɵngcc0.ɵɵlistener("click", function DropDownListComponent_ng_template_9_ng_template_0_Template_span_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r309); return $event.stopImmediatePropagation(); });
    ɵngcc0.ɵɵelementStart(1, "input", 15);
    ɵngcc0.ɵɵlistener("ngModelChange", function DropDownListComponent_ng_template_9_ng_template_0_Template_input_ngModelChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r309); const ctx_r310 = ɵngcc0.ɵɵnextContext(2); return ctx_r310.filterText = $event; })("keydown", function DropDownListComponent_ng_template_9_ng_template_0_Template_input_keydown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r309); const ctx_r311 = ɵngcc0.ɵɵnextContext(2); return ctx_r311.keydown($event); })("input", function DropDownListComponent_ng_template_9_ng_template_0_Template_input_input_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r309); const ctx_r312 = ɵngcc0.ɵɵnextContext(2); return ctx_r312.handleFilter($event); })("focus", function DropDownListComponent_ng_template_9_ng_template_0_Template_input_focus_1_listener() { ɵngcc0.ɵɵrestoreView(_r309); const ctx_r313 = ɵngcc0.ɵɵnextContext(2); return ctx_r313.onFilterFocus(); })("blur", function DropDownListComponent_ng_template_9_ng_template_0_Template_input_blur_1_listener() { ɵngcc0.ɵɵrestoreView(_r309); const ctx_r314 = ɵngcc0.ɵɵnextContext(2); return ctx_r314.blurFilterInput(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(2, "span", 16);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r301 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("filterInput", ctx_r301.isFocused && !ctx_r301.touchEnabled)("dir", ctx_r301.direction)("ngModel", ctx_r301.filterText);
    ɵngcc0.ɵɵattribute("aria-owns", ctx_r301.ariaOwns)("aria-activedescendant", ctx_r301.ariaActivedescendant)("aria-label", ctx_r301.noDataLabel);
} }
const _c28 = function (a0) { return { "k-state-disabled": a0 }; };
function DropDownListComponent_ng_template_9_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 17);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r302 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(3, _c28, ctx_r302.isDisabledDefaultItem))("index", 0 - 1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r302.getDefaultItemText(), " ");
} }
function DropDownListComponent_ng_template_9_ng_template_2_ng_template_1_Template(rf, ctx) { }
function DropDownListComponent_ng_template_9_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 17);
    ɵngcc0.ɵɵtemplate(1, DropDownListComponent_ng_template_9_ng_template_2_ng_template_1_Template, 0, 0, "ng-template", 10);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r303 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(3, _c28, ctx_r303.isDisabledDefaultItem))("index", 0 - 1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction2(5, _c3, ctx_r303.itemTemplate.templateRef, ctx_r303.defaultItem));
} }
function DropDownListComponent_ng_template_9_3_ng_template_0_Template(rf, ctx) { }
function DropDownListComponent_ng_template_9_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DropDownListComponent_ng_template_9_3_ng_template_0_Template, 0, 0, "ng-template", 10);
} if (rf & 2) {
    const ctx_r304 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction1(1, _c17, ctx_r304.headerTemplate.templateRef));
} }
function DropDownListComponent_ng_template_9_div_6_ng_template_1_Template(rf, ctx) { }
function DropDownListComponent_ng_template_9_div_6_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r318 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r318.noDataText);
} }
function DropDownListComponent_ng_template_9_div_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 18);
    ɵngcc0.ɵɵtemplate(1, DropDownListComponent_ng_template_9_div_6_ng_template_1_Template, 0, 0, "ng-template", 19);
    ɵngcc0.ɵɵtemplate(2, DropDownListComponent_ng_template_9_div_6_ng_template_2_Template, 2, 1, "ng-template", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r306 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r306.noDataTemplate)("templateContext", ɵngcc0.ɵɵpureFunction1(3, _c17, ctx_r306.noDataTemplate ? ctx_r306.noDataTemplate.templateRef : undefined));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r306.noDataTemplate);
} }
function DropDownListComponent_ng_template_9_7_ng_template_0_Template(rf, ctx) { }
function DropDownListComponent_ng_template_9_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DropDownListComponent_ng_template_9_7_ng_template_0_Template, 0, 0, "ng-template", 10);
} if (rf & 2) {
    const ctx_r307 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction1(1, _c17, ctx_r307.footerTemplate.templateRef));
} }
function DropDownListComponent_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    const _r321 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵtemplate(0, DropDownListComponent_ng_template_9_ng_template_0_Template, 3, 6, "ng-template", 5);
    ɵngcc0.ɵɵtemplate(1, DropDownListComponent_ng_template_9_ng_template_1_Template, 2, 5, "ng-template", 5);
    ɵngcc0.ɵɵtemplate(2, DropDownListComponent_ng_template_9_ng_template_2_Template, 2, 8, "ng-template", 5);
    ɵngcc0.ɵɵtemplate(3, DropDownListComponent_ng_template_9_3_Template, 1, 3, undefined, 4);
    ɵngcc0.ɵɵelementStart(4, "kendo-list", 11, 12);
    ɵngcc0.ɵɵlistener("pageChange", function DropDownListComponent_ng_template_9_Template_kendo_list_pageChange_4_listener($event) { ɵngcc0.ɵɵrestoreView(_r321); const ctx_r320 = ɵngcc0.ɵɵnextContext(); return ctx_r320.pageChange($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(6, DropDownListComponent_ng_template_9_div_6_Template, 3, 5, "div", 13);
    ɵngcc0.ɵɵtemplate(7, DropDownListComponent_ng_template_9_7_Template, 1, 3, undefined, 4);
} if (rf & 2) {
    const ctx_r297 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r297.filterable);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r297.defaultItem && !ctx_r297.itemTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r297.defaultItem && ctx_r297.itemTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r297.headerTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("id", ctx_r297.listBoxId)("optionPrefix", ctx_r297.optionPrefix)("data", ctx_r297.data)("textField", ctx_r297.textField)("valueField", ctx_r297.valueField)("template", ctx_r297.itemTemplate)("groupTemplate", ctx_r297.groupTemplate)("fixedGroupTemplate", ctx_r297.fixedGroupTemplate)("height", ctx_r297.listHeight)("show", ctx_r297.isOpen)("virtual", ctx_r297.virtual);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r297.data.length === 0);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r297.footerTemplate);
} }
function DropDownListComponent_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    const _r323 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-resize-sensor", 20);
    ɵngcc0.ɵɵlistener("resize", function DropDownListComponent_ng_template_11_Template_kendo_resize_sensor_resize_0_listener() { ɵngcc0.ɵɵrestoreView(_r323); const ctx_r322 = ɵngcc0.ɵɵnextContext(); return ctx_r322.onResize(); });
    ɵngcc0.ɵɵelementEnd();
} }
const _c29 = function (a1, a2, a3) { return { "k-dropdown-wrap": true, "k-state-default": a1, "k-state-disabled": a2, "k-state-focused": a3 }; };
var I18N_30;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text displayed in the popup when there are no items
     * @meaning kendo.multiselect.noDataText
     */ 
    const MSG_EXTERNAL_1450213984397806503$$DIST_FESM2015_INDEX_JS_31 = goog.getMsg("NO DATA FOUND");
    I18N_30 = MSG_EXTERNAL_1450213984397806503$$DIST_FESM2015_INDEX_JS_31;
}
else {
    I18N_30 = $localize `:kendo.multiselect.noDataText|The text displayed in the popup when there are no items␟3cc1323f79a5fe012960578e513f8a35b2af1e96␟1450213984397806503:NO DATA FOUND`;
}
var I18N_32;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The title of the clear button
     * @meaning kendo.combobox.clearTitle
     */ 
    const MSG_EXTERNAL_2025597431468961462$$DIST_FESM2015_INDEX_JS_33 = goog.getMsg("clear");
    I18N_32 = MSG_EXTERNAL_2025597431468961462$$DIST_FESM2015_INDEX_JS_33;
}
else {
    I18N_32 = $localize `:kendo.combobox.clearTitle|The title of the clear button␟069e8fae80677e3e785861123bef446b3ff41ab4␟2025597431468961462:clear`;
}
const _c34 = ["noDataText", I18N_30, "clearTitle", I18N_32];
function MultiSelectComponent_span_7_Template(rf, ctx) { if (rf & 1) {
    const _r333 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 11);
    ɵngcc0.ɵɵlistener("mousedown", function MultiSelectComponent_span_7_Template_span_mousedown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r333); const ctx_r332 = ɵngcc0.ɵɵnextContext(); return ctx_r332.clearAll($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r326 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("title", ctx_r326.clearTitle);
} }
function MultiSelectComponent_span_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 12);
} }
function MultiSelectComponent_ng_template_9_0_ng_template_0_Template(rf, ctx) { }
function MultiSelectComponent_ng_template_9_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, MultiSelectComponent_ng_template_9_0_ng_template_0_Template, 0, 0, "ng-template", 18);
} if (rf & 2) {
    const ctx_r334 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction1(1, _c17, ctx_r334.headerTemplate.templateRef));
} }
function MultiSelectComponent_ng_template_9_div_1_2_ng_template_0_Template(rf, ctx) { }
function MultiSelectComponent_ng_template_9_div_1_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, MultiSelectComponent_ng_template_9_div_1_2_ng_template_0_Template, 0, 0, "ng-template", 18);
} if (rf & 2) {
    const ctx_r340 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction2(1, _c3, ctx_r340.customItemTemplate.templateRef, ctx_r340.text));
} }
function MultiSelectComponent_ng_template_9_div_1_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r342 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r342.text);
} }
function MultiSelectComponent_ng_template_9_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 19);
    ɵngcc0.ɵɵelementStart(1, "div", 20);
    ɵngcc0.ɵɵtemplate(2, MultiSelectComponent_ng_template_9_div_1_2_Template, 1, 4, undefined, 21);
    ɵngcc0.ɵɵtemplate(3, MultiSelectComponent_ng_template_9_div_1_ng_template_3_Template, 1, 1, "ng-template", null, 22, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelement(5, "span", 23);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const _r341 = ɵngcc0.ɵɵreference(4);
    const ctx_r335 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("multipleSelection", true)("index", 0 - 1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r335.customItemTemplate)("ngIfElse", _r341);
} }
function MultiSelectComponent_ng_template_9_div_4_ng_template_1_Template(rf, ctx) { }
function MultiSelectComponent_ng_template_9_div_4_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r345 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r345.noDataText);
} }
function MultiSelectComponent_ng_template_9_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 24);
    ɵngcc0.ɵɵtemplate(1, MultiSelectComponent_ng_template_9_div_4_ng_template_1_Template, 0, 0, "ng-template", 25);
    ɵngcc0.ɵɵtemplate(2, MultiSelectComponent_ng_template_9_div_4_ng_template_2_Template, 2, 1, "ng-template", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r337 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r337.noDataTemplate)("templateContext", ɵngcc0.ɵɵpureFunction1(3, _c17, ctx_r337.noDataTemplate ? ctx_r337.noDataTemplate.templateRef : undefined));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r337.noDataTemplate);
} }
function MultiSelectComponent_ng_template_9_5_ng_template_0_Template(rf, ctx) { }
function MultiSelectComponent_ng_template_9_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, MultiSelectComponent_ng_template_9_5_ng_template_0_Template, 0, 0, "ng-template", 18);
} if (rf & 2) {
    const ctx_r338 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction1(1, _c17, ctx_r338.footerTemplate.templateRef));
} }
function MultiSelectComponent_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    const _r348 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵtemplate(0, MultiSelectComponent_ng_template_9_0_Template, 1, 3, undefined, 13);
    ɵngcc0.ɵɵtemplate(1, MultiSelectComponent_ng_template_9_div_1_Template, 6, 4, "div", 14);
    ɵngcc0.ɵɵelementStart(2, "kendo-list", 15, 16);
    ɵngcc0.ɵɵlistener("pageChange", function MultiSelectComponent_ng_template_9_Template_kendo_list_pageChange_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r348); const ctx_r347 = ɵngcc0.ɵɵnextContext(); return ctx_r347.pageChange($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, MultiSelectComponent_ng_template_9_div_4_Template, 3, 5, "div", 17);
    ɵngcc0.ɵɵtemplate(5, MultiSelectComponent_ng_template_9_5_Template, 1, 3, undefined, 13);
} if (rf & 2) {
    const ctx_r329 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r329.headerTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r329.allowCustom && ctx_r329.text);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("id", ctx_r329.listBoxId)("optionPrefix", ctx_r329.optionPrefix)("data", ctx_r329.data)("textField", ctx_r329.textField)("valueField", ctx_r329.valueField)("height", ctx_r329.listHeight)("template", ctx_r329.template)("groupTemplate", ctx_r329.groupTemplate)("fixedGroupTemplate", ctx_r329.fixedGroupTemplate)("show", ctx_r329.isOpen)("multipleSelection", true)("virtual", ctx_r329.virtual);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r329.data.length === 0);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r329.footerTemplate);
} }
function MultiSelectComponent_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    const _r350 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-resize-sensor", 26);
    ɵngcc0.ɵɵlistener("resize", function MultiSelectComponent_ng_template_11_Template_kendo_resize_sensor_resize_0_listener() { ɵngcc0.ɵɵrestoreView(_r350); const ctx_r349 = ɵngcc0.ɵɵnextContext(); return ctx_r349.onResize(); });
    ɵngcc0.ɵɵelementEnd();
} }
function TagListComponent_li_1_1_ng_template_0_Template(rf, ctx) { }
function TagListComponent_li_1_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TagListComponent_li_1_1_ng_template_0_Template, 0, 0, "ng-template");
} }
function TagListComponent_li_1_ng_template_2_1_ng_template_0_Template(rf, ctx) { }
function TagListComponent_li_1_ng_template_2_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TagListComponent_li_1_ng_template_2_1_ng_template_0_Template, 0, 0, "ng-template", 10);
} if (rf & 2) {
    const tag_r352 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r360 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction2(1, _c3, ctx_r360.groupTemplate.templateRef, tag_r352));
} }
function TagListComponent_li_1_ng_template_2_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const tag_r352 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵtextInterpolate2("", tag_r352.length, " ", tag_r352.length === 1 ? "item" : "items", " selected");
} }
function TagListComponent_li_1_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtemplate(1, TagListComponent_li_1_ng_template_2_1_Template, 1, 4, undefined, 8);
    ɵngcc0.ɵɵtemplate(2, TagListComponent_li_1_ng_template_2_ng_template_2_Template, 1, 2, "ng-template", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r356 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r356.groupTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r356.groupTemplate);
} }
function TagListComponent_li_1_ng_template_4_1_ng_template_0_Template(rf, ctx) { }
function TagListComponent_li_1_ng_template_4_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TagListComponent_li_1_ng_template_4_1_ng_template_0_Template, 0, 0, "ng-template", 10);
} if (rf & 2) {
    const tag_r352 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r365 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction2(1, _c3, ctx_r365.template.templateRef, tag_r352));
} }
function TagListComponent_li_1_ng_template_4_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const tag_r352 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r366 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate(ctx_r366.tagProp(tag_r352, ctx_r366.textField));
} }
function TagListComponent_li_1_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtemplate(1, TagListComponent_li_1_ng_template_4_1_Template, 1, 4, undefined, 8);
    ɵngcc0.ɵɵtemplate(2, TagListComponent_li_1_ng_template_4_ng_template_2_Template, 1, 1, "ng-template", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r358 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r358.template);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r358.template);
} }
const _c35 = function (a0) { return { "k-state-focused": a0 }; };
function TagListComponent_li_1_Template(rf, ctx) { if (rf & 1) {
    const _r371 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 2);
    ɵngcc0.ɵɵtemplate(1, TagListComponent_li_1_1_Template, 1, 0, undefined, 3);
    ɵngcc0.ɵɵtemplate(2, TagListComponent_li_1_ng_template_2_Template, 3, 2, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵtemplate(4, TagListComponent_li_1_ng_template_4_Template, 3, 2, "ng-template", null, 5, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementStart(6, "span", 6);
    ɵngcc0.ɵɵelementStart(7, "span", 7);
    ɵngcc0.ɵɵlistener("mousedown", function TagListComponent_li_1_Template_span_mousedown_7_listener($event) { ɵngcc0.ɵɵrestoreView(_r371); const tag_r352 = ctx.$implicit; const ctx_r370 = ɵngcc0.ɵɵnextContext(); return ctx_r370.deleteTag($event, tag_r352); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tag_r352 = ctx.$implicit;
    const i_r353 = ctx.index;
    const _r355 = ɵngcc0.ɵɵreference(3);
    const _r357 = ɵngcc0.ɵɵreference(5);
    const ctx_r351 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(7, _c35, i_r353 === ctx_r351.focused));
    ɵngcc0.ɵɵattribute("aria-setsize", ctx_r351.tags == null ? null : ctx_r351.tags.length)("id", ctx_r351.itemId(tag_r352));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r351.isGroupTag(tag_r352))("ngIfThen", _r355)("ngIfElse", _r357);
    ɵngcc0.ɵɵadvance(5);
    ɵngcc0.ɵɵattribute("aria-hidden", i_r353 !== ctx_r351.focused);
} }
export { PopupComponent } from '@progress/kendo-angular-popup';
import { CommonModule } from '@angular/common';

/**
 * @hidden
 */
var Keys;
(function (Keys) {
    Keys[Keys["backspace"] = 8] = "backspace";
    Keys[Keys["tab"] = 9] = "tab";
    Keys[Keys["enter"] = 13] = "enter";
    Keys[Keys["shift"] = 16] = "shift";
    Keys[Keys["ctrl"] = 17] = "ctrl";
    Keys[Keys["alt"] = 18] = "alt";
    Keys[Keys["pause/break"] = 19] = "pause/break";
    Keys[Keys["caps lock"] = 20] = "caps lock";
    Keys[Keys["esc"] = 27] = "esc";
    Keys[Keys["space"] = 32] = "space";
    Keys[Keys["page up"] = 33] = "page up";
    Keys[Keys["page down"] = 34] = "page down";
    Keys[Keys["end"] = 35] = "end";
    Keys[Keys["home"] = 36] = "home";
    Keys[Keys["left"] = 37] = "left";
    Keys[Keys["up"] = 38] = "up";
    Keys[Keys["right"] = 39] = "right";
    Keys[Keys["down"] = 40] = "down";
    Keys[Keys["insert"] = 45] = "insert";
    Keys[Keys["delete"] = 46] = "delete";
    Keys[Keys["command"] = 91] = "command";
    Keys[Keys["left command"] = 91] = "left command";
    Keys[Keys["right command"] = 93] = "right command";
    Keys[Keys["numpad *"] = 106] = "numpad *";
    Keys[Keys["numpad +"] = 107] = "numpad +";
    Keys[Keys["numpad -"] = 109] = "numpad -";
    Keys[Keys["numpad ."] = 110] = "numpad .";
    Keys[Keys["numpad /"] = 111] = "numpad /";
    Keys[Keys["num lock"] = 144] = "num lock";
    Keys[Keys["scroll lock"] = 145] = "scroll lock";
    Keys[Keys["my computer"] = 182] = "my computer";
    Keys[Keys["my calculator"] = 183] = "my calculator";
    Keys[Keys[";"] = 186] = ";";
    Keys[Keys["="] = 187] = "=";
    Keys[Keys[","] = 188] = ",";
    Keys[Keys["-"] = 189] = "-";
    Keys[Keys["."] = 190] = ".";
    Keys[Keys["/"] = 191] = "/";
    Keys[Keys["`"] = 192] = "`";
    Keys[Keys["["] = 219] = "[";
    Keys[Keys["\\"] = 220] = "\\";
    Keys[Keys["]"] = 221] = "]";
    Keys[Keys["'"] = 222] = "'";
})(Keys || (Keys = {}));

/* tslint:disable:no-null-keyword */
/* tslint:disable:no-bitwise */
/* tslint:disable:align */
/**
 * @hidden
 */
const isPresent = (value) => value !== null && value !== undefined;
/**
 * @hidden
 */
const isNumber = (value) => !isNaN(value);
/**
 * @hidden
 */
const guid = () => {
    let id = "";
    let i;
    let random;
    for (i = 0; i < 32; i++) {
        random = Math.random() * 16 | 0;
        if (i === 8 || i === 12 || i === 16 || i === 20) {
            id += "-";
        }
        id += (i === 12 ? 4 : (i === 16 ? (random & 3 | 8) : random)).toString(16);
    }
    return id;
};
/**
 * @hidden
 */
const combineStr = (begin, end) => {
    return begin.concat(end.substr(end.toLowerCase().indexOf(begin.toLowerCase()) + begin.length));
};
/**
 * @hidden
 */
const isWindowAvailable = () => typeof window !== 'undefined';
/**
 * @hidden
 */
const isArray = (value) => Array.isArray(value);
/**
 * @hidden
 */
const isObject = (value) => isPresent(value) && typeof value === 'object';
/**
 * @hidden
 */
const isEmptyString = (value) => typeof value === 'string' && value.length === 0;
/**
 * @hidden
 */
const resolveValuesInArray = (values, data = [], valueField) => values
    .map(value => {
    return data.find(item => item[valueField] === value);
})
    .filter(value => value !== undefined);
/**
 * @hidden
 */
const validateComplexValues = (values, valueField) => isArray(values) && values.filter(item => {
    return isObject(item) && item[valueField];
});
/**
 * @hidden
 */
const resolveAllValues = (value, data, valueField) => {
    const customValues = validateComplexValues(value, valueField) || [];
    const resolvedValues = resolveValuesInArray(value, data, valueField) || [];
    return resolvedValues.concat(customValues);
};
/**
 * @hidden
 */
const isObjectArray = (values) => {
    return isArray(values) && values.every(item => isObject(item));
};
/**
 * @hidden
 */
const selectedIndices = (values, data, valueField) => {
    const extractedValues = data.map(item => {
        return isPresent(item) && isPresent(item[valueField]) ? item[valueField] : item;
    });
    return values.reduce((arr, item) => {
        const value = isPresent(item) && isPresent(item[valueField]) ? item[valueField] : item;
        const index = extractedValues.indexOf(value);
        if (index !== -1) {
            arr.push(index);
        }
        return arr;
    }, []);
};
/**
 * @hidden
 */
const getter = (dataItem, field, usePrimitive = false) => {
    if (isPresent(dataItem)) {
        if (usePrimitive) {
            return field && isPresent(dataItem[field]) ? dataItem[field] : dataItem;
        }
        else {
            return field ? dataItem[field] : dataItem;
        }
    }
};
/**
 * @hidden
 */
const sameCharsOnly = (word, character) => {
    for (let idx = 0; idx < word.length; idx++) {
        if (word.charAt(idx) !== character) {
            return false;
        }
    }
    return true;
};
/**
 * @hidden
 */
const shuffleData = (data, splitIndex, defaultItem) => {
    let result = data;
    if (defaultItem) {
        result = [defaultItem].concat(result);
    }
    return result.slice(splitIndex).concat(result.slice(0, splitIndex));
};
/**
 * @hidden
 */
const matchText = (text, word, ignoreCase) => {
    if (!isPresent(text)) {
        return false;
    }
    let temp = String(text);
    if (ignoreCase) {
        temp = temp.toLowerCase();
    }
    return temp.indexOf(word) === 0;
};
/**
 * @hidden
 *
 * Checks whether the passed object has all of the listed properties.
 */
const hasProps = (obj, props) => {
    if (!isPresent(obj)) {
        return false;
    }
    return props.every(prop => obj.hasOwnProperty(prop));
};

/* tslint:disable:member-ordering */
/**
 * @hidden
 */
class SearchBarComponent {
    constructor(localization, renderer) {
        this.localization = localization;
        this.valueChange = new EventEmitter();
        this.onBlur = new EventEmitter();
        this.onFocus = new EventEmitter();
        this.onClick = new EventEmitter();
        this.onNavigate = new EventEmitter();
        this.searchBarClass = true;
        this._userInput = "";
        this._previousValue = "";
        this._placeholder = "";
        this.direction = localization.rtl ? 'rtl' : 'ltr';
        this.renderer = renderer;
    }
    get userInput() {
        return this._userInput;
    }
    set userInput(userInput) {
        this._userInput = userInput || "";
    }
    get value() {
        return this.input.nativeElement.value;
    }
    set placeholder(text) {
        this._placeholder = text || '';
        this.setInputSize();
    }
    get placeholder() {
        return this._placeholder;
    }
    ngOnInit() {
        this.localizationChangeSubscription = this.localization
            .changes.subscribe(({ rtl }) => this.direction = rtl ? 'rtl' : 'ltr');
    }
    ngOnChanges(changes) {
        let previousUserInput;
        if (this.input && (changes.userInput || changes.suggestedText)) {
            if (changes.userInput && changes.userInput.previousValue) {
                if (this._previousValue === changes.userInput.previousValue) {
                    previousUserInput = this._previousValue;
                }
                else {
                    previousUserInput = changes.userInput.currentValue || "";
                }
            }
            else {
                previousUserInput = this._previousValue;
            }
            const caretIndex = this.input.nativeElement.selectionStart;
            const caretAtEnd = previousUserInput.length === caretIndex;
            this.writeInputValue(this.suggestedText ? combineStr(this.userInput, this.suggestedText) : this.userInput);
            if (this.suggestedText) {
                this.setInputSelection(this.userInput.length, this.suggestedText.length);
            }
            else if (caretAtEnd) {
                this.setInputSelection(this.userInput.length, this.userInput.length);
            }
            else {
                this.setInputSelection(caretIndex, caretIndex);
            }
            this._previousValue = this.userInput;
        }
    }
    ngOnDestroy() {
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
    }
    writeInputValue(text) {
        if (isDocumentAvailable()) {
            this.renderer.setProperty(this.input.nativeElement, 'value', text);
        }
    }
    setInputSelection(start, end) {
        if (isDocumentAvailable() && this.input.nativeElement === document.activeElement) {
            try {
                this.input.nativeElement.setSelectionRange(start, end);
            }
            catch (e) {
                //Make sure that the element is in the DOM before you invoke its methods
            }
        }
    }
    handleInput(event) {
        const value = event.target.value;
        if (value !== this.userInput) {
            this._previousValue = value;
            this.valueChange.emit(value);
        }
    }
    handleFocus(event) {
        this.onFocus.emit(event);
    }
    handleBlur(event) {
        this.onBlur.emit(event);
    }
    handleKeydown(event) {
        const keyCode = event.keyCode;
        const keys = [Keys.up, Keys.down, Keys.left, Keys.right, Keys.enter,
            Keys.esc, Keys.delete, Keys.backspace, Keys.home, Keys.end];
        if (keys.indexOf(keyCode) > -1) {
            this.onNavigate.emit(event);
        }
    }
    focus() {
        if (isDocumentAvailable()) {
            this.input.nativeElement.focus();
        }
    }
    blur() {
        if (isDocumentAvailable()) {
            this.input.nativeElement.blur();
        }
    }
    setInputSize() {
        const lengthOf = x => x ? x.length : 0;
        const input = this.input.nativeElement;
        const placeholderLength = lengthOf(this.placeholder);
        const textLength = lengthOf(this.value);
        const size = Math.max(placeholderLength, textLength, 1);
        this.renderer.setAttribute(input, 'size', size.toString());
    }
}
SearchBarComponent.ɵfac = function SearchBarComponent_Factory(t) { return new (t || SearchBarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
SearchBarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SearchBarComponent, selectors: [["kendo-searchbar"]], viewQuery: function SearchBarComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostVars: 2, hostBindings: function SearchBarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-searchbar", ctx.searchBarClass);
    } }, inputs: { userInput: "userInput", placeholder: "placeholder", id: "id", listId: "listId", tagListId: "tagListId", activeDescendant: "activeDescendant", noDataLabel: "noDataLabel", disabled: "disabled", readonly: "readonly", tabIndex: "tabIndex", popupOpen: "popupOpen", role: "role", suggestedText: "suggestedText" }, outputs: { valueChange: "valueChange", onBlur: "onBlur", onFocus: "onFocus", onClick: "onClick", onNavigate: "onNavigate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], decls: 2, vars: 16, consts: [["autocomplete", "off", "aria-haspopup", "listbox", 3, "id", "disabled", "readonly", "placeholder", "input", "focus", "blur", "keydown"], ["input", ""]], template: function SearchBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "input", 0, 1);
        ɵngcc0.ɵɵlistener("input", function SearchBarComponent_Template_input_input_0_listener($event) { return ctx.handleInput($event); })("focus", function SearchBarComponent_Template_input_focus_0_listener($event) { return ctx.handleFocus($event); })("blur", function SearchBarComponent_Template_input_blur_0_listener($event) { return ctx.handleBlur($event); })("keydown", function SearchBarComponent_Template_input_keydown_0_listener($event) { return ctx.handleKeydown($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMap("k-input");
        ɵngcc0.ɵɵproperty("id", ctx.id)("disabled", ctx.disabled)("readonly", ctx.readonly)("placeholder", ctx.placeholder);
        ɵngcc0.ɵɵattribute("tabIndex", ctx.tabIndex)("dir", ctx.direction)("role", ctx.role)("aria-disabled", ctx.disabled)("aria-readonly", ctx.readonly)("aria-expanded", ctx.popupOpen)("aria-owns", ctx.listId)("aria-describedby", ctx.tagListId)("aria-activedescendant", ctx.activeDescendant)("aria-label", ctx.noDataLabel);
    } }, encapsulation: 2 });
/** @nocollapse */
SearchBarComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: Renderer2 }
];
SearchBarComponent.propDecorators = {
    id: [{ type: Input }],
    listId: [{ type: Input }],
    tagListId: [{ type: Input }],
    activeDescendant: [{ type: Input }],
    noDataLabel: [{ type: Input }],
    disabled: [{ type: Input }],
    readonly: [{ type: Input }],
    tabIndex: [{ type: Input }],
    popupOpen: [{ type: Input }],
    role: [{ type: Input }],
    userInput: [{ type: Input }],
    suggestedText: [{ type: Input }],
    valueChange: [{ type: Output }],
    onBlur: [{ type: Output }],
    onFocus: [{ type: Output }],
    onClick: [{ type: Output }],
    onNavigate: [{ type: Output }],
    input: [{ type: ViewChild, args: ["input", { static: true },] }],
    searchBarClass: [{ type: HostBinding, args: ['class.k-searchbar',] }],
    placeholder: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SearchBarComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-searchbar',
                template: `
        <input #input
            autocomplete="off"
            [id]="id"
            [disabled]="disabled"
            [readonly]="readonly"
            [placeholder]="placeholder"
            [class]="'k-input'"
            (input)="handleInput($event)"
            (focus)="handleFocus($event)"
            (blur)="handleBlur($event)"
            (keydown)="handleKeydown($event)"
            [attr.tabIndex]="tabIndex"
            [attr.dir]="direction"
            [attr.role]="role"
            [attr.aria-disabled]="disabled"
            [attr.aria-readonly]="readonly"
            aria-haspopup="listbox"
            [attr.aria-expanded]="popupOpen"
            [attr.aria-owns]="listId"
            [attr.aria-describedby]="tagListId"
            [attr.aria-activedescendant]="activeDescendant"
            [attr.aria-label]="noDataLabel"
        />
   `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ɵngcc0.Renderer2 }]; }, { valueChange: [{
            type: Output
        }], onBlur: [{
            type: Output
        }], onFocus: [{
            type: Output
        }], onClick: [{
            type: Output
        }], onNavigate: [{
            type: Output
        }], searchBarClass: [{
            type: HostBinding,
            args: ['class.k-searchbar']
        }], userInput: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], id: [{
            type: Input
        }], listId: [{
            type: Input
        }], tagListId: [{
            type: Input
        }], activeDescendant: [{
            type: Input
        }], noDataLabel: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], tabIndex: [{
            type: Input
        }], popupOpen: [{
            type: Input
        }], role: [{
            type: Input
        }], suggestedText: [{
            type: Input
        }], input: [{
            type: ViewChild,
            args: ["input", { static: true }]
        }] }); })();

/* tslint:disable:max-line-length */
/**
 * Renders the list item content. To define the item template, nest an `<ng-template>` tag
 * with the `kendo<ComponentName>ItemTemplate` directive inside the component tag. The template context is
 * set to the current component. To get a reference to the current data item, use the `let-dataItem` directive.
 *
 * - [Using `ItemTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-item-template)
 * - [Using `ItemTemplate` with the ComboBox]({% slug templates_combobox %}#toc-item-template)
 * - [Using `ItemTemplate` with the DropDownList]({% slug templates_ddl %}#toc-item-template)
 * - [Using `ItemTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-item-template)
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-combobox [data]="listItems">
 *    <ng-template kendoComboBoxItemTemplate let-dataItem>
 *      <span>{{dataItem}} option</span>
 *    </ng-template>
 *  </kendo-combobox>
 * `
 * })
 * class AppComponent {
 *   public listItems: Array<string> = ["Item 1", "Item 2", "Item 3", "Item 4"];
 * }
 * ```
 */
class ItemTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
ItemTemplateDirective.ɵfac = function ItemTemplateDirective_Factory(t) { return new (t || ItemTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
ItemTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ItemTemplateDirective, selectors: [["", "kendoDropDownListItemTemplate", ""], ["", "kendoComboBoxItemTemplate", ""], ["", "kendoAutoCompleteItemTemplate", ""], ["", "kendoMultiSelectItemTemplate", ""]] });
/** @nocollapse */
ItemTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ItemTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDropDownListItemTemplate],[kendoComboBoxItemTemplate],[kendoAutoCompleteItemTemplate],[kendoMultiSelectItemTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();

/* tslint:disable:max-line-length */
/**
 * Renders the header content of the list. To define the header template, nest an `<ng-template>` tag
 * with the `kendo<ComponentName>HeaderTemplate` directive inside the component tag.
 *
 * - [Using `HeaderTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-header-template)
 * - [Using `HeaderTemplate` with the ComboBox]({% slug templates_combobox %}#toc-header-template)
 * - [Using `HeaderTemplate` with the DropDownList]({% slug templates_ddl %}#toc-header-template)
 * - [Using `HeaderTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-header-template)
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-combobox [data]="listItems">
 *    <ng-template kendoComboBoxHeaderTemplate>
 *      <h4>Header template</h4>
 *    </ng-template>
 *  </kendo-combobox>
 * `
 * })
 * class AppComponent {
 *   public listItems: Array<string> = ["Item 1", "Item 2", "Item 3", "Item 4"];
 * }
 * ```
 */
class HeaderTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
HeaderTemplateDirective.ɵfac = function HeaderTemplateDirective_Factory(t) { return new (t || HeaderTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
HeaderTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: HeaderTemplateDirective, selectors: [["", "kendoDropDownListHeaderTemplate", ""], ["", "kendoComboBoxHeaderTemplate", ""], ["", "kendoAutoCompleteHeaderTemplate", ""], ["", "kendoMultiSelectHeaderTemplate", ""]] });
/** @nocollapse */
HeaderTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HeaderTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDropDownListHeaderTemplate],[kendoComboBoxHeaderTemplate],[kendoAutoCompleteHeaderTemplate],[kendoMultiSelectHeaderTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();

/* tslint:disable:max-line-length */
/**
 * Renders the footer content of the list. To define the footer template, nest an `<ng-template>` tag
 * with the `kendo<ComponentName>FooterTemplate` directive inside the component tag.
 *
 * - [Using `FooterTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-footer-template)
 * - [Using `FooterTemplate` with the ComboBox]({% slug templates_combobox %}#toc-footer-template)
 * - [Using `FooterTemplate` with the DropDownList]({% slug templates_ddl %}#toc-footer-template)
 * - [Using `FooterTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-footer-template)
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-combobox [data]="listItems">
 *    <ng-template kendoComboBoxFooterTemplate>
 *      <h4>Footer template</h4>
 *    </ng-template>
 *  </kendo-combobox>
 * `
 * })
 * class AppComponent {
 *   public listItems: Array<string> = ["Item 1", "Item 2", "Item 3", "Item 4"];
 * }
 * ```
 */
class FooterTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
FooterTemplateDirective.ɵfac = function FooterTemplateDirective_Factory(t) { return new (t || FooterTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
FooterTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FooterTemplateDirective, selectors: [["", "kendoDropDownListFooterTemplate", ""], ["", "kendoComboBoxFooterTemplate", ""], ["", "kendoAutoCompleteFooterTemplate", ""], ["", "kendoMultiSelectFooterTemplate", ""]] });
/** @nocollapse */
FooterTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FooterTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDropDownListFooterTemplate],[kendoComboBoxFooterTemplate],[kendoAutoCompleteFooterTemplate],[kendoMultiSelectFooterTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();

/* tslint:disable:max-line-length */
/**
 * Renders the group header content. To define the group template, nest an `<ng-template>` tag
 * with the `kendo<ComponentName>GroupTemplate` directive inside the component tag. The template context is
 * set to the current component. To get a reference to the current data item, use the `let-groupName` directive.
 *
 * - [Using `GroupTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-group-template)
 * - [Using `GroupTemplate` with the ComboBox]({% slug templates_combobox %}#toc-group-template)
 * - [Using `GroupTemplate` with the DropDownList]({% slug templates_ddl %}#toc-group-template)
 * - [Using `GroupTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-group-template)
 *
 * @example
 * ```ts
 * import { groupBy } from '@progress/kendo-data-query';
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-combobox [data]="groupedData" [textField]="'name'" [valueField]="'name'">
 *    <ng-template kendoComboBoxGroupTemplate let-groupName>
 *      <span>Food type: {{groupName}} option</span>
 *    </ng-template>
 *  </kendo-combobox>
 * `
 * })
 * class AppComponent {
 *   public data = [
 *       { name: "Pork", category: "Food", subcategory: "Meat" },
 *       { name: "Pepper", category: "Food", subcategory: "Vegetables" },
 *       { name: "Beef", category: "Food", subcategory: "Meat" }
 *   ];
 *   public groupedData = groupBy(this.data, [{field: "subcategory"}]);
 * }
 * ```
 */
class GroupTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
GroupTemplateDirective.ɵfac = function GroupTemplateDirective_Factory(t) { return new (t || GroupTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
GroupTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: GroupTemplateDirective, selectors: [["", "kendoDropDownListGroupTemplate", ""], ["", "kendoComboBoxGroupTemplate", ""], ["", "kendoAutoCompleteGroupTemplate", ""], ["", "kendoMultiSelectGroupTemplate", ""]] });
/** @nocollapse */
GroupTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GroupTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDropDownListGroupTemplate],[kendoComboBoxGroupTemplate],[kendoAutoCompleteGroupTemplate],[kendoMultiSelectGroupTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();

/* tslint:disable:max-line-length */
/**
 * Renders the fixed group header content. To define the fixed group template, nest an `<ng-template>` tag
 * with the `kendo<ComponentName>FixedGroupTemplate` directive inside the component tag. The template context is
 * set to the current component. To get a reference to the current data item, use the `let-groupName` directive.
 *
 * - [Using `FixedGroupTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-fixed-group-template)
 * - [Using `FixedGroupTemplate` with the ComboBox]({% slug templates_combobox %}#toc-fixed-group-template)
 * - [Using `FixedGroupTemplate` with the DropDownList]({% slug templates_ddl %}#toc-fixed-group-template)
 * - [Using `FixedGroupTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-fixed-group-template)
 *
 * @example
 * ```ts
 * import { groupBy } from '@progress/kendo-data-query';
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-combobox [data]="groupedData" [textField]="'name'" [valueField]="'name'">
 *    <ng-template kendoComboBoxFixedGroupTemplate let-groupName>
 *      <span>Food type: {{groupName}} option</span>
 *    </ng-template>
 *  </kendo-combobox>
 * `
 * })
 * class AppComponent {
 *   public data = [
 *       { name: "Pork", category: "Food", subcategory: "Meat" },
 *       { name: "Pepper", category: "Food", subcategory: "Vegetables" },
 *       { name: "Beef", category: "Food", subcategory: "Meat" }
 *   ];
 *   public groupedData = groupBy(this.data, [{field: "subcategory"}]);
 * }
 * ```
 */
class FixedGroupTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
FixedGroupTemplateDirective.ɵfac = function FixedGroupTemplateDirective_Factory(t) { return new (t || FixedGroupTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
FixedGroupTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FixedGroupTemplateDirective, selectors: [["", "kendoDropDownListFixedGroupTemplate", ""], ["", "kendoComboBoxFixedGroupTemplate", ""], ["", "kendoAutoCompleteFixedGroupTemplate", ""], ["", "kendoMultiSelectFixedGroupTemplate", ""]] });
/** @nocollapse */
FixedGroupTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FixedGroupTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDropDownListFixedGroupTemplate],[kendoComboBoxFixedGroupTemplate],[kendoAutoCompleteFixedGroupTemplate],[kendoMultiSelectFixedGroupTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();

/**
 * @hidden
 */
class SelectionService {
    constructor() {
        this.onSelect = new EventEmitter();
        this.onChange = new EventEmitter();
        this.onFocus = new EventEmitter();
        this.total = 0;
        this.selectedIndices = [];
    }
    getTotal() {
        return this.total;
    }
    isSelected(index) {
        return isPresent(this.selectedIndices.find(current => current === index));
    }
    isFocused(index) {
        return index === this.focused;
    }
    focus(index) {
        if (this.isFocused(index)) {
            return;
        }
        this.focused = index;
        this.onFocus.emit(index);
    }
    select(index) {
        if (this.isSelected(index)) {
            return;
        }
        this.selectedIndices = [index];
        this.focused = index;
        this.onSelect.emit({
            indices: [index],
            newSelection: isPresent(index)
        });
    }
    add(index) {
        if (this.isSelected(index)) {
            return;
        }
        this.selectedIndices.push(index);
        this.focused = index;
        this.onChange.emit({
            added: index,
            indices: this.selectedIndices.slice()
        });
    }
    unselect(index) {
        if (!this.isSelected(index)) {
            return;
        }
        const position = this.selectedIndices.indexOf(index);
        this.selectedIndices.splice(position, 1);
        this.focused = index;
        this.onChange.emit({
            indices: this.selectedIndices.slice(),
            removed: index
        });
    }
    change(index) {
        const newSelection = isPresent(index) && !this.isSelected(index);
        this.selectedIndices = [index];
        this.focused = index;
        this.onChange.emit({
            indices: [index],
            newSelection: newSelection
        });
    }
    resetSelection(index) {
        this.selectedIndices = index instanceof Array ? index : [index];
        this.focused = this.selectedIndices[this.selectedIndices.length - 1];
    }
    get selected() {
        return this.selectedIndices.slice();
    }
    get focused() {
        return this.focusedIndex;
    }
    set focused(index) {
        if (this.focusedIndex !== index) {
            this.focusedIndex = index;
            this.onFocus.emit(index);
        }
    }
}
SelectionService.ɵfac = function SelectionService_Factory(t) { return new (t || SelectionService)(); };
SelectionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: SelectionService, factory: SelectionService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SelectionService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @hidden
 */
var NavigationAction;
(function (NavigationAction) {
    NavigationAction[NavigationAction["Undefined"] = 0] = "Undefined";
    NavigationAction[NavigationAction["Open"] = 1] = "Open";
    NavigationAction[NavigationAction["Close"] = 2] = "Close";
    NavigationAction[NavigationAction["Enter"] = 3] = "Enter";
    NavigationAction[NavigationAction["Tab"] = 4] = "Tab";
    NavigationAction[NavigationAction["Esc"] = 5] = "Esc";
    NavigationAction[NavigationAction["Delete"] = 6] = "Delete";
    NavigationAction[NavigationAction["Backspace"] = 7] = "Backspace";
    NavigationAction[NavigationAction["Home"] = 8] = "Home";
    NavigationAction[NavigationAction["End"] = 9] = "End";
    NavigationAction[NavigationAction["Up"] = 10] = "Up";
    NavigationAction[NavigationAction["Down"] = 11] = "Down";
    NavigationAction[NavigationAction["Left"] = 12] = "Left";
    NavigationAction[NavigationAction["Right"] = 13] = "Right";
})(NavigationAction || (NavigationAction = {}));

/**
 * @hidden
 */
class DataService {
    constructor() {
        this.grouped = false;
        this.groupIndices = [];
    }
    set data(data) {
        this._data = data;
        this.grouped = this.isGrouped(data);
        if (this.grouped) {
            this.groupIndices = this.getGroupIndices(data);
            this._flatData = this.flatten(data);
        }
    }
    get data() {
        if (this.grouped) {
            return this._flatData;
        }
        return this._data;
    }
    /**
     * @hidden
     * Used to get the actual items count, i.e. excluding the header items in case of grouping.
     */
    get itemsCount() {
        if (!isPresent(this.data) || this.data.length === 0) {
            return 0;
        }
        const items = this.grouped ? this._flatData.filter(item => !item.header) : this.data;
        return items.length;
    }
    /**
     * @hidden
     * Used to determine if the component received grouped data.
     */
    isGrouped(data) {
        // GroupResult { aggregates: AggregateResult, field: string, items: object[], value: any }
        // https://www.telerik.com/kendo-angular-ui/components/dataquery/api/GroupResult/
        return (isPresent(data) && data.length !== 0) && isPresent(data[0]) && hasProps(data[0], ['aggregates', 'field', 'items', 'value']);
    }
    /**
     * @hidden
     * Used to calculate the last item index of each group.
     */
    getGroupIndices(data) {
        let groupIndices = [];
        for (let i = 0; i <= data.length - 1; i++) {
            groupIndices[i] = (groupIndices[i - 1] || 0) + data[i].items.length;
        }
        return groupIndices;
    }
    /**
     * @hidden
     * Used to get a flat array containing all items matching certain criteria.
     */
    filter(predicate) {
        let result = [];
        if (this.isGrouped(this.data)) {
            for (let i = 0; i <= this.groupIndices.length - 1; i++) {
                const matches = this.data[i].items.filter(predicate);
                if (matches) {
                    result = result.concat(matches);
                }
            }
        }
        else {
            result = this.data.filter(predicate);
        }
        return result;
    }
    /**
     * @hidden
     * Used to get the index of a given data item.
     */
    indexOf(item, startFrom = 0) {
        let predicate = (element) => {
            return element === item;
        };
        if (this.grouped) {
            predicate = (element) => {
                return element.value === item;
            };
        }
        return this.findIndex(predicate, startFrom);
    }
    /**
     * @hidden
     * Used to get the index of a data item based on an expression.
     */
    findIndex(predicate, startFrom = 0) {
        let index = -1;
        if (this.grouped) {
            const data = this._flatData.filter(item => !item.header && item.offsetIndex >= startFrom);
            index = data.findIndex(predicate);
            index = data[index] ? data[index].offsetIndex : -1;
        }
        else {
            const data = this.data.slice(startFrom);
            const itemIndex = data.findIndex(predicate);
            index = itemIndex !== -1 ? itemIndex + startFrom : -1;
        }
        return index;
    }
    /**
     * @hidden
     * Used to get the closest group header prior to an item index.
     */
    closestGroup(index) {
        for (let i = index; i >= 0; i--) {
            if (this._flatData[i].header) {
                return this._flatData[i];
            }
        }
    }
    /**
     * @hidden
     * Used to get the first item matching the criteria.
     */
    find(predicate) {
        const index = this.findIndex(predicate);
        return this.itemAt(index);
    }
    /**
     * @hidden
     * Used to get the true index in a flattened data array.
     */
    flatIndex(index) {
        if (this.itemsCount === 0) {
            return -1;
        }
        if (this.grouped) {
            const match = this._flatData.find((item) => !item.header && item.offsetIndex === index);
            if (match) {
                return match.index;
            }
        }
        else {
            return index;
        }
        return -1;
    }
    /**
     * @hidden
     * Used to get the item at the provided index.
     */
    itemAt(index) {
        let dataItem;
        if (this.itemsCount === 0) {
            return dataItem;
        }
        if (this.grouped) {
            const match = this._flatData.find((item) => !item.header && item.offsetIndex === index);
            if (match) {
                dataItem = match.value;
            }
        }
        else {
            dataItem = this.data[index];
        }
        return dataItem;
    }
    /**
     * @hidden
     * Used to get the group at the provided index.
     */
    groupAt(index) {
        if (this.itemsCount === 0 || !this.isGrouped) {
            return;
        }
        return this._flatData.find((item) => item.header && item.index === index);
    }
    /**
     * @hidden
     * Used to get the field by which the data is grouped.
     */
    groupField() {
        if (this.itemsCount === 0 || !this.isGrouped) {
            return;
        }
        return this._data[0].field;
    }
    /**
     * @hidden
     * Used to get the group to which a dataItem belongs.
     */
    itemGroup(item) {
        if (!item || this.itemsCount === 0 || !this.isGrouped) {
            return;
        }
        const fieldName = this.groupField();
        if (fieldName) {
            return item[fieldName];
        }
    }
    flatten(data, group = undefined, offset = 0, groupIndex = 0) {
        let flat = [];
        if (isPresent(group)) {
            flat.push({
                header: true,
                index: groupIndex + offset,
                offsetIndex: groupIndex,
                value: group
            });
        }
        for (let i = 0; i < data.length; i++) {
            let result = [];
            if (data[i].items) {
                result = this.flatten(data[i].items, data[i].value, offset, i);
                offset = offset + data[i].items.length;
            }
            else {
                result.push({
                    header: false,
                    index: groupIndex + offset + i + 1,
                    offsetIndex: offset + i,
                    value: data[i]
                });
            }
            flat = flat.concat(result);
        }
        return flat;
    }
}
DataService.ɵfac = function DataService_Factory(t) { return new (t || DataService)(); };
DataService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DataService, factory: DataService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DataService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @hidden
 */
class DisabledItemsService {
    constructor(dataService) {
        this.dataService = dataService;
        this.itemDisabled = null;
    }
    isIndexDisabled(index) {
        if (this.itemDisabled) {
            const item = this.dataService.itemAt(index);
            if (isPresent(item)) {
                return this.itemDisabled({ dataItem: item, index });
            }
            else if (isPresent(this.defaultItem)) {
                return this.itemDisabled({ dataItem: this.defaultItem, index: -1 });
            }
        }
    }
    isItemDisabled(item) {
        if (this.itemDisabled) {
            const index = this.dataService.indexOf(item);
            if (index !== -1) {
                return this.itemDisabled({ dataItem: item, index });
            }
            else if (isPresent(this.defaultItem)) {
                return this.itemDisabled({ dataItem: this.defaultItem, index: -1 });
            }
        }
    }
}
DisabledItemsService.ɵfac = function DisabledItemsService_Factory(t) { return new (t || DisabledItemsService)(ɵngcc0.ɵɵinject(DataService)); };
DisabledItemsService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DisabledItemsService, factory: DisabledItemsService.ɵfac });
/** @nocollapse */
DisabledItemsService.ctorParameters = () => [
    { type: DataService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DisabledItemsService, [{
        type: Injectable
    }], function () { return [{ type: DataService }]; }, null); })();

const MIN_INDEX = 0;
/**
 * @hidden
 */
class NavigationEvent {
    /**
     * The index of the item to which the user navigated.
     */
    constructor(index, originalEvent) {
        this.index = index;
        this.originalEvent = originalEvent;
    }
}
/**
 * @hidden
 */
class NavigationService {
    constructor(disabledItemsService, selectionService) {
        this.disabledItemsService = disabledItemsService;
        this.selectionService = selectionService;
        this.open = new EventEmitter();
        this.close = new EventEmitter();
        this.enter = new EventEmitter();
        this.tab = new EventEmitter();
        this.esc = new EventEmitter();
        this.up = new EventEmitter();
        this.right = new EventEmitter();
        this.down = new EventEmitter();
        this.left = new EventEmitter();
        this.delete = new EventEmitter();
        this.backspace = new EventEmitter();
        this.home = new EventEmitter();
        this.end = new EventEmitter();
    }
    process(args) {
        const keyCode = args.originalEvent.keyCode;
        const altKey = args.originalEvent.altKey;
        let index;
        let action = NavigationAction.Undefined;
        if (altKey && keyCode === Keys.down) {
            action = NavigationAction.Open;
        }
        else if (altKey && keyCode === Keys.up) {
            action = NavigationAction.Close;
        }
        else if (keyCode === Keys.enter) {
            action = NavigationAction.Enter;
        }
        else if (keyCode === Keys.esc) {
            action = NavigationAction.Esc;
        }
        else if (keyCode === Keys.tab) {
            action = NavigationAction.Tab;
        }
        else if (keyCode === Keys.up) {
            index = this.next({ current: args.current, start: args.min, end: args.max, step: -1 });
            action = NavigationAction.Up;
        }
        else if (keyCode === Keys.left) {
            index = this.next({ current: args.current, start: args.min, end: args.max, step: -1 });
            action = NavigationAction.Left;
        }
        else if (keyCode === Keys.down) {
            index = this.next({ current: args.current, start: args.min, end: args.max, step: 1 });
            action = NavigationAction.Down;
        }
        else if (keyCode === Keys.right) {
            index = this.next({ current: args.current, start: args.min, end: args.max, step: 1 });
            action = NavigationAction.Right;
        }
        else if (keyCode === Keys.home) {
            index = this.isDisabled(MIN_INDEX) ? args.current : MIN_INDEX;
            action = NavigationAction.Home;
        }
        else if (keyCode === Keys.end) {
            index = this.isDisabled(args.max) ? args.current : args.max;
            action = NavigationAction.End;
        }
        else if (keyCode === Keys.delete) {
            action = NavigationAction.Delete;
        }
        else if (keyCode === Keys.backspace) {
            action = NavigationAction.Backspace;
        }
        const eventData = new NavigationEvent(index, args.originalEvent);
        if (action !== NavigationAction.Undefined) {
            this[NavigationAction[action].toLowerCase()].emit(eventData);
        }
        return action;
    }
    next(args) {
        const { current, start, end, step } = args;
        const nextIndex = !isPresent(current) ? start : this.clampIndex(current + step, start, end);
        const firstFocusableIndex = this.firstFocusableIndex(nextIndex, start, end, step);
        if (isPresent(firstFocusableIndex)) {
            return firstFocusableIndex;
        }
        if (this.selectionService.isSelected(current) && current >= start) {
            return current;
        }
        const inversedStep = -1 * step;
        return this.firstFocusableIndex(nextIndex, start, end, inversedStep);
    }
    clampIndex(index, min, max) {
        if (!isPresent(index) || index < min) {
            return min;
        }
        if (index > max) {
            return max;
        }
        return index;
    }
    firstFocusableIndex(startIndex, min, max, step) {
        while (min <= startIndex && startIndex <= max) {
            if (!this.isDisabled(startIndex)) {
                return startIndex;
            }
            startIndex += step;
        }
        return undefined;
    }
    isDisabled(index) {
        if (this.disabledItemsService) {
            return this.disabledItemsService.isIndexDisabled(index);
        }
    }
}
NavigationService.ɵfac = function NavigationService_Factory(t) { return new (t || NavigationService)(ɵngcc0.ɵɵinject(DisabledItemsService), ɵngcc0.ɵɵinject(SelectionService)); };
NavigationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NavigationService, factory: NavigationService.ɵfac });
/** @nocollapse */
NavigationService.ctorParameters = () => [
    { type: DisabledItemsService },
    { type: SelectionService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NavigationService, [{
        type: Injectable
    }], function () { return [{ type: DisabledItemsService }, { type: SelectionService }]; }, null); })();

/* tslint:disable:max-line-length */
/**
 * Renders content when no data is available. To define the no-data template, nest a `<ng-template>` tag
 * with the `kendo<ComponentName>NoDataTemplate` directive inside the component tag.
 *
 * - [Using `NoDataTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-no-data-template)
 * - [Using `NoDataTemplate` with the ComboBox]({% slug templates_combobox %}#toc-no-data-template)
 * - [Using `NoDataTemplate` with the DropDownList]({% slug templates_ddl %}#toc-no-data-template)
 * - [Using `NoDataTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-no-data-template)
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-combobox [data]="listItems">
 *    <ng-template kendoComboBoxNoDataTemplate>
 *      <h4>No data!</h4>
 *    </ng-template>
 *  </kendo-combobox>
 * `
 * })
 * class AppComponent {
 *   public listItems: Array<string> = [];
 * }
 * ```
 */
class NoDataTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NoDataTemplateDirective.ɵfac = function NoDataTemplateDirective_Factory(t) { return new (t || NoDataTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NoDataTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NoDataTemplateDirective, selectors: [["", "kendoDropDownListNoDataTemplate", ""], ["", "kendoComboBoxNoDataTemplate", ""], ["", "kendoAutoCompleteNoDataTemplate", ""], ["", "kendoMultiSelectNoDataTemplate", ""]] });
/** @nocollapse */
NoDataTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NoDataTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDropDownListNoDataTemplate],[kendoComboBoxNoDataTemplate],[kendoAutoCompleteNoDataTemplate],[kendoMultiSelectNoDataTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();

/**
 * @hidden
 */
class PreventableEvent {
    constructor() {
        this.prevented = false;
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * If the event is prevented by any of its subscribers, returns `true`.
     *
     * @returns `true` if the default action was prevented. Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}

/**
 * Defines the mandatory properties of the `kendoDropDownFilter` directive
 * so that `kendoDropDownFilter` can be used with any of the DropDowns components
 * which implement the `FilterableDropDownComponentBase` class.
 *
 * @hidden
 */
class FilterableDropDownComponentBase {
}

/**
 * @hidden
 */
class ListItemDirective {
    constructor(element) {
        this.element = element;
    }
}
ListItemDirective.ɵfac = function ListItemDirective_Factory(t) { return new (t || ListItemDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ListItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ListItemDirective, selectors: [["li", "role", "option"], ["li", "role", "group"]] });
/** @nocollapse */
ListItemDirective.ctorParameters = () => [
    { type: ElementRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ListItemDirective, [{
        type: Directive,
        args: [{
                selector: '"li[role=option], li[role=group]"' // tslint:disable-line
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, null); })();

/**
 * @hidden
 */
class ListComponent {
    /* tslint:disable:member-ordering */
    constructor(dataService, wrapper, selectionService, disabledItemsService, cdr, zone, renderer) {
        this.dataService = dataService;
        this.wrapper = wrapper;
        this.selectionService = selectionService;
        this.disabledItemsService = disabledItemsService;
        this.cdr = cdr;
        this.zone = zone;
        this.renderer = renderer;
        this.selected = [];
        this.focused = -1;
        this.show = true;
        this.multipleSelection = false;
        this.onClick = new EventEmitter();
        this.pageChange = new EventEmitter();
        this.startFrom = 0;
        this.lastLoaded = 0;
        this.lastScrollTop = 0;
        this.scrollToFocused = false;
        this.selectSubscription = merge(this.selectionService.onSelect.pipe(map((args) => args.indices[0])), this.selectionService.onFocus).subscribe(this.scrollToItem.bind(this));
    }
    set data(data) {
        this._data = data[0] && data[0].header ? data.slice(0) : data;
    }
    get data() {
        return this._data;
    }
    set items(items) {
        this._items = items;
    }
    get items() {
        return this._items;
    }
    get pageSize() {
        if (this.virtual.pageSize) {
            return this.virtual.pageSize;
        }
        let size = Math.round(this.height / this.virtual.itemHeight);
        return size;
    }
    get scrollHeight() {
        return (this.dataService.grouped ? this.virtual.total - 1 : this.virtual.total) * this.virtual.itemHeight;
    }
    ngOnChanges(changes) {
        if (isChanged('data', changes, false)) {
            if (this.lastLoaded <= 0) {
                this.lastLoaded = this.data.length - 1;
                this.scrollToFocused = !changes.data.isFirstChange();
            }
        }
    }
    ngAfterViewInit() {
        this.zone.runOutsideAngular(() => {
            this.scrollSubscription = fromEvent(this.content.nativeElement, "scroll").pipe(auditTime(100), tap(this.prefetchData.bind(this)), tap(this.findCurrentGroup.bind(this))).subscribe(() => {
                this.lastScrollTop = this.content.nativeElement.scrollTop;
            });
        });
    }
    ngAfterViewChecked() {
        if (this.virtual) {
            this.positionItems();
        }
        if (this.items && this.scrollToFocused) {
            this.scrollToFocused = false;
            const scrollTarget = this.items.length && this.selectionService.focused === -1 ? 0 : this.selectionService.focused;
            this.scrollToItem(scrollTarget);
        }
        if (this.dataService.grouped) {
            this.findCurrentGroup();
        }
    }
    ngOnDestroy() {
        this.selectSubscription.unsubscribe();
        if (this.scrollSubscription) {
            this.scrollSubscription.unsubscribe();
        }
    }
    firstVisibleItem() {
        const content = this.content.nativeElement;
        const contentParent = content.offsetParent;
        const offsetY = (contentParent ? contentParent.offsetTop : 0) + content.offsetTop + 1;
        const offsetX = (contentParent ? contentParent.offsetLeft : 0) + content.offsetLeft + 1;
        const item = document.elementFromPoint(offsetX, offsetY);
        return item;
    }
    findCurrentGroup() {
        if (!this.dataService.grouped) {
            this.currentGroup = undefined;
            return;
        }
        const item = this.firstVisibleItem();
        if (item) {
            let index;
            if (item.getAttribute("role") === "group") {
                index = parseInt(item.getAttribute("group-index"), 10);
                this.currentGroup = this.dataService.groupAt(index).value;
            }
            else {
                index = parseInt(item.getAttribute("index"), 10);
                this.currentGroup = this.dataService.itemGroup(this.dataService.itemAt(index));
            }
        }
        else {
            this.currentGroup = undefined;
        }
        this.cdr.detectChanges();
    }
    prefetchData() {
        if (!this.virtual) {
            return;
        }
        const visibleItems = Math.trunc(this.content.nativeElement.clientHeight / this.virtual.itemHeight);
        const offsetY = this.content.nativeElement.scrollTop;
        const start = Math.trunc(offsetY / this.virtual.itemHeight);
        const down = offsetY > this.lastScrollTop;
        const nextPage = (start + visibleItems >= this.lastLoaded) && this.lastLoaded < this.virtual.total - 1;
        const leftOver = this.pageSize - (this.lastLoaded - this.startFrom);
        const prevPage = this.lastLoaded - this.pageSize + visibleItems >= start - leftOver;
        if (down && nextPage) {
            this.changePage(start);
        }
        if (!down && prevPage) {
            this.changePage(start - this.pageSize + visibleItems + 1);
        }
    }
    changePage(start) {
        this.zone.run(() => {
            let end = this.pageSize + start;
            if (end > this.virtual.total) {
                start--;
                end = this.virtual.total;
            }
            if (start < 0) {
                start = 0;
            }
            this.startFrom = start;
            this.lastLoaded = end;
            this.pageChange.emit({ skip: start, take: this.pageSize });
        });
    }
    index(groupIndex, itemIndex) {
        return groupIndex > 0 ? (this.dataService.groupIndices[groupIndex - 1] + itemIndex) : itemIndex;
    }
    getText(dataItem) {
        return getter(dataItem, this.textField);
    }
    getValue(dataItem) {
        return getter(dataItem, this.valueField);
    }
    isDisabled(index) {
        return this.disabledItemsService.isIndexDisabled(index);
    }
    scrollToItem(index) {
        let flatIndex = index;
        if (this.dataService.grouped) {
            // takes into account the group header items
            flatIndex = this.dataService.flatIndex(index);
            /* The first group header item is not rendered in the list (see template), so subtract 1 when calulating the flat index.
               With virtualization enabled, the first group header could be in a previous page, in which case don't subtract anything. */
            const groupHeaderOffset = this.firstGroupHeaderInTargetedPage(flatIndex) ? -1 : 0;
            flatIndex += groupHeaderOffset;
        }
        if (this.virtual && flatIndex > -1) {
            this.scrollToIndex(flatIndex);
            return;
        }
        const items = this.items.toArray();
        if (isPresent(items[flatIndex]) && flatIndex !== -1) {
            this.scroll(items[flatIndex].element);
        }
    }
    scrollToIndex(index) {
        let content = this.content.nativeElement;
        let contentScrollTop = content.scrollTop;
        const itemOffsetTop = index * this.virtual.itemHeight;
        const itemOffsetHeight = this.virtual.itemHeight;
        const contentOffsetHeight = content.clientHeight;
        const bottomDistance = itemOffsetTop + itemOffsetHeight;
        if (contentScrollTop > itemOffsetTop) {
            contentScrollTop = itemOffsetTop;
        }
        else if (bottomDistance > (contentScrollTop + contentOffsetHeight)) {
            contentScrollTop = (bottomDistance - contentOffsetHeight);
        }
        content.scrollTop = contentScrollTop;
    }
    scroll(item) {
        if (!item) {
            return;
        }
        const nativeElement = item.nativeElement;
        let content = this.content.nativeElement, itemOffsetTop = nativeElement.offsetTop, itemOffsetHeight = nativeElement.offsetHeight, contentScrollTop = content.scrollTop, contentOffsetHeight = content.clientHeight, bottomDistance = itemOffsetTop + itemOffsetHeight;
        if (contentScrollTop > itemOffsetTop) {
            contentScrollTop = itemOffsetTop;
        }
        else if (bottomDistance > (contentScrollTop + contentOffsetHeight)) {
            contentScrollTop = (bottomDistance - contentOffsetHeight);
        }
        content.scrollTop = contentScrollTop;
    }
    positionItems() {
        this.items.forEach((item, index) => {
            const offsetY = (index + this.startFrom) * this.virtual.itemHeight;
            this.renderer.setStyle(item.element.nativeElement, "transform", `translateY(${offsetY}px`);
        });
    }
    /**
     * Indicates whether the first group header from the data set is in the targeted virtual page.
     */
    firstGroupHeaderInTargetedPage(itemIndex) {
        if (!isPresent(this.virtual)) {
            return true;
        }
        return this.virtual.skip === 0 && (this.virtual.pageSize > itemIndex);
    }
}
ListComponent.ɵfac = function ListComponent_Factory(t) { return new (t || ListComponent)(ɵngcc0.ɵɵdirectiveInject(DataService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(DisabledItemsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
ListComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ListComponent, selectors: [["kendo-list"]], viewQuery: function ListComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c1, true);
        ɵngcc0.ɵɵviewQuery(_c2, true);
        ɵngcc0.ɵɵviewQuery(ListItemDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.content = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.list = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.items = _t);
    } }, inputs: { selected: "selected", focused: "focused", show: "show", multipleSelection: "multipleSelection", data: "data", textField: "textField", valueField: "valueField", height: "height", template: "template", groupTemplate: "groupTemplate", fixedGroupTemplate: "fixedGroupTemplate", id: "id", optionPrefix: "optionPrefix", virtual: "virtual" }, outputs: { onClick: "onClick", pageChange: "pageChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], decls: 8, vars: 15, consts: [["class", "k-outer-group-header k-first", 3, "ngClass", "ngStyle", 4, "ngIf"], ["unselectable", "on", 3, "ngClass"], ["content", ""], ["role", "listbox", 1, "k-list", "k-reset", 3, "ngClass"], ["list", ""], [4, "ngIf"], ["class", "k-height-container", "role", "presentation", 4, "ngIf"], [1, "k-outer-group-header", "k-first", 3, "ngClass", "ngStyle"], [3, "ngIf"], [3, "templateContext"], ["ngFor", "", 3, "ngForOf"], ["role", "option", "kendoDropDownsSelectable", "", 1, "k-item", 3, "height", "index", "multipleSelection", "ngClass"], ["role", "group", "class", "k-outer-group-header", 3, "ngClass", "ngStyle", 4, "ngIf"], ["role", "option", "kendoDropDownsSelectable", "", "class", "k-item", 3, "height", "index", "multipleSelection", "ngClass", 4, "ngIf"], ["role", "group", 1, "k-outer-group-header", 3, "ngClass", "ngStyle"], ["role", "presentation", 1, "k-height-container"]], template: function ListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ListComponent_div_0_Template, 3, 10, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1, 2);
        ɵngcc0.ɵɵelementStart(3, "ul", 3, 4);
        ɵngcc0.ɵɵtemplate(5, ListComponent_5_Template, 1, 1, undefined, 5);
        ɵngcc0.ɵɵtemplate(6, ListComponent_6_Template, 1, 1, undefined, 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, ListComponent_div_7_Template, 2, 2, "div", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.dataService.grouped);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("max-height", ctx.height, "px");
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(10, _c7, ctx.virtual, !ctx.virtual));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(13, _c8, ctx.virtual));
        ɵngcc0.ɵɵattribute("id", ctx.id)("aria-hidden", !ctx.show);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.dataService.grouped && ctx.show);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.dataService.grouped);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.virtual);
    } }, directives: function () { return [ɵngcc2.NgIf, ɵngcc2.NgClass, ɵngcc2.NgStyle, TemplateContextDirective, ɵngcc2.NgForOf, ListItemDirective,
        SelectableDirective]; }, encapsulation: 2 });
/** @nocollapse */
ListComponent.ctorParameters = () => [
    { type: DataService },
    { type: ElementRef },
    { type: SelectionService },
    { type: DisabledItemsService },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: Renderer2 }
];
ListComponent.propDecorators = {
    selected: [{ type: Input }],
    focused: [{ type: Input }],
    textField: [{ type: Input }],
    valueField: [{ type: Input }],
    height: [{ type: Input }],
    template: [{ type: Input }],
    groupTemplate: [{ type: Input }],
    fixedGroupTemplate: [{ type: Input }],
    show: [{ type: Input }],
    id: [{ type: Input }],
    optionPrefix: [{ type: Input }],
    multipleSelection: [{ type: Input }],
    virtual: [{ type: Input }],
    data: [{ type: Input }],
    onClick: [{ type: Output }],
    pageChange: [{ type: Output }],
    items: [{ type: ViewChildren, args: [ListItemDirective,] }],
    content: [{ type: ViewChild, args: ['content',] }],
    list: [{ type: ViewChild, args: ['list',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ListComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-list',
                template: `
    <div *ngIf="dataService.grouped"
        class='k-outer-group-header k-first'
        [ngClass]="{'k-virtual-item': virtual}"
        [ngStyle]="{
            'height.px': virtual?.itemHeight,
            'minHeight.px' : virtual?.itemHeight,
            'boxSizing' : virtual ? 'border-box' : 'inherit'}"
        >
        <ng-template *ngIf="fixedGroupTemplate"
            [templateContext]="{
                templateRef: fixedGroupTemplate.templateRef,
                $implicit: currentGroup
            }">
        </ng-template>
        <ng-template [ngIf]="!fixedGroupTemplate"><strong>{{ currentGroup }}</strong> </ng-template>
    </div>
    <div #content
         [ngClass]="{ 'k-virtual-content': virtual, 'k-list-scroller': !virtual }"
         [style.maxHeight.px]="height"
         unselectable="on">
    <ul #list
        role="listbox"
        class="k-list k-reset"
        [ngClass]="{ 'k-virtual-list': virtual }"
        [attr.id]="id"
        [attr.aria-hidden]="!show">
         <ng-template *ngIf="!dataService.grouped && show" ngFor let-dataItem let-itemIndex="index" [ngForOf]="data">
            <li
                role="option"
                kendoDropDownsSelectable
                [height]="virtual?.itemHeight"
                [index]="itemIndex + startFrom"
                [multipleSelection]="multipleSelection"
                [attr.id]="optionPrefix + '-' + getValue(dataItem)"
                [attr.tabIndex]="-1"
                class="k-item"
                [ngClass]="{ 'k-virtual-item': virtual, 'k-state-disabled': isDisabled(itemIndex) }">
                <ng-template *ngIf="template"
                    [templateContext]="{
                        templateRef: template.templateRef,
                        $implicit: dataItem
                    }">
                </ng-template>
                <ng-template [ngIf]="!template">{{ getText(dataItem) }}</ng-template>
            </li>
         </ng-template>
         <ng-template *ngIf="dataService.grouped" ngFor let-dataItem let-itemIndex="index" [ngForOf]="data">
            <li
                *ngIf="dataItem.header && dataItem.index > 0"
                role="group"
                class='k-outer-group-header'
                [ngClass]="{ 'k-virtual-item': virtual }"
                [ngStyle]="{
                    'height.px': virtual?.itemHeight,
                    'minHeight.px' : virtual?.itemHeight,
                    'boxSizing' : virtual ? 'border-box' : 'inherit'}"
                [attr.group-index]="dataItem.index"
                [attr.id]="optionPrefix + '-' + getValue(dataItem.value)"
                [attr.tabIndex]="-1">
                    <ng-template *ngIf="groupTemplate"
                          [templateContext]="{
                            templateRef: groupTemplate.templateRef,
                            $implicit: dataItem.value
                    }">
                    </ng-template>
                    <ng-template [ngIf]="!groupTemplate"><strong> {{ dataItem.value }}</strong> </ng-template>
              </li>
            <li
                *ngIf="!dataItem.header"
                role="option"
                kendoDropDownsSelectable
                [height]="virtual?.itemHeight"
                [index]="dataItem.offsetIndex"
                [multipleSelection]="multipleSelection"
                [attr.absolute-index]="dataItem.index"
                [attr.id]="optionPrefix + '-' + getValue(dataItem.value)"
                [attr.tabIndex]="-1"
                class="k-item"
                [ngClass]="{ 'k-virtual-item': virtual, 'k-state-disabled': isDisabled(dataItem.offsetIndex) }">
                <ng-template *ngIf="template"
                    [templateContext]="{
                        templateRef: template.templateRef,
                        $implicit: dataItem.value
                    }">
                </ng-template>
                <ng-template [ngIf]="!template">{{ getText(dataItem.value) }}</ng-template>
            </li>
        </ng-template>
    </ul>
    <div *ngIf="virtual" class="k-height-container" role="presentation">
        <div [style.height.px]="scrollHeight"></div>
    </div>
    </div>
  `
            }]
    }], function () { return [{ type: DataService }, { type: ɵngcc0.ElementRef }, { type: SelectionService }, { type: DisabledItemsService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }]; }, { selected: [{
            type: Input
        }], focused: [{
            type: Input
        }], show: [{
            type: Input
        }], multipleSelection: [{
            type: Input
        }], onClick: [{
            type: Output
        }], pageChange: [{
            type: Output
        }], data: [{
            type: Input
        }], items: [{
            type: ViewChildren,
            args: [ListItemDirective]
        }], textField: [{
            type: Input
        }], valueField: [{
            type: Input
        }], height: [{
            type: Input
        }], template: [{
            type: Input
        }], groupTemplate: [{
            type: Input
        }], fixedGroupTemplate: [{
            type: Input
        }], id: [{
            type: Input
        }], optionPrefix: [{
            type: Input
        }], virtual: [{
            type: Input
        }], content: [{
            type: ViewChild,
            args: ['content']
        }], list: [{
            type: ViewChild,
            args: ['list']
        }] }); })();

/**
 * @hidden
 */
const DEFAULTS = {
    pageSize: 50,
    itemHeight: 28
};
/**
 * @hidden
 */
const normalizeVirtualizationSettings = (settings) => {
    if (settings === true) {
        return DEFAULTS;
    }
    if (!settings) {
        return null;
    }
    return Object.assign({ pageSize: DEFAULTS.pageSize }, settings);
};

/* tslint:disable:no-null-keyword */
const NO_VALUE = "";
/**
 * @hidden
 */
const AUTOCOMPLETE_VALUE_ACCESSOR = {
    multi: true,
    provide: NG_VALUE_ACCESSOR,
    // tslint:disable-next-line:no-use-before-declare
    useExisting: forwardRef(() => AutoCompleteComponent)
};
/**
 * Represents the [Kendo UI AutoComplete component for Angular]({% slug overview_autocomplete %}).
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-autocomplete
 *      [data]="listItems"
 *      [placeholder]="placeholder"
 *  >
 * `
 * })
 * class AppComponent {
 *   public placeholder: string = 'Type "it" for suggestions';
 *   public listItems: Array<string> = ["Item 1", "Item 2", "Item 3", "Item 4"];
 * }
 * ```
 */
class AutoCompleteComponent {
    constructor(localization, dataService, popupService, selectionService, navigationService, disabledItemsService, _zone, cdr, renderer, wrapper) {
        this.localization = localization;
        this.dataService = dataService;
        this.popupService = popupService;
        this.selectionService = selectionService;
        this.navigationService = navigationService;
        this.disabledItemsService = disabledItemsService;
        this._zone = _zone;
        this.cdr = cdr;
        this.renderer = renderer;
        /**
         * Defines whether the first match from the suggestions list will be automatically focused.
         * By default, `highlightFirst` is set to `true`.
         */
        this.highlightFirst = true;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * The hint which is displayed when the component is empty.
         */
        this.placeholder = "";
        /**
         * Sets the height of the suggestions list. By default, `listHeight` is 200px.
         *
         * > The `listHeight` property affects only the list of suggestions and not the whole popup container.
         * > To set the height of the popup container, use `popupSettings.height`.
         */
        this.listHeight = 200;
        /**
         * @hidden
         *
         * If set to `true`, renders a button on hovering over the component.
         * Clicking this button resets the value of the component to `undefined` and triggers the `change` event.
         */
        this.clearButton = true;
        /**
         * Sets the disabled state of the component.
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the component.
         */
        this.readonly = false;
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Enables the [filtering]({% slug filtering_autocomplete %}) functionality.
         * If set to `true`, the component emits the `filterChange` event.
         */
        this.filterable = false;
        /**
         * Fires each time the value is changed&mdash;
         * when the component is blurred or the value is cleared through the **Clear** button
         * ([see example]({% slug overview_autocomplete %}#toc-events)).
         * When the value of the component is programmatically changed to `ngModel` or `formControl`
         * through its API or form binding, the `valueChange` event is not triggered because it
         * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the user types in the input field.
         * You can filter the source based on the passed filtration value
         * ([see example]({% slug overview_autocomplete %}#toc-events)).
         */
        this.filterChange = new EventEmitter();
        /**
         * Fires each time the popup is about to open.
         * This event is preventable. If you cancel it, the popup will remain closed.
         */
        this.open = new EventEmitter();
        /**
         * Fires each time the popup is about to close.
         * This event is preventable. If you cancel it, the popup will remain open.
         */
        this.close = new EventEmitter();
        /**
         * Fires each time the user focuses the AutoComplete.
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the AutoComplete gets blurred.
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        this.widgetClasses = true;
        this.listBoxId = guid();
        this.optionPrefix = guid();
        this.onChangeCallback = (_value) => { };
        this.onTouchedCallback = (_) => { };
        this.popupMouseDownHandler = (event) => event.preventDefault();
        this._popupSettings = { animate: true };
        this._open = false;
        this._value = "";
        this._previousValue = NO_VALUE;
        this._filtering = false;
        this.valueChangeSubject = new Subject();
        this._isFocused = false;
        this.direction = localization.rtl ? 'rtl' : 'ltr';
        this.wrapper = wrapper.nativeElement;
        this.data = [];
        this.subscribeEvents();
        this.selectionService.resetSelection([-1]);
    }
    get width() {
        let wrapperOffsetWidth = 0;
        if (isDocumentAvailable()) {
            wrapperOffsetWidth = this.wrapper.offsetWidth;
        }
        const width = this.popupSettings.width || wrapperOffsetWidth;
        const minWidth = isNaN(wrapperOffsetWidth) ? wrapperOffsetWidth : `${wrapperOffsetWidth}px`;
        const maxWidth = isNaN(width) ? width : `${width}px`;
        return { min: minWidth, max: maxWidth };
    }
    get height() {
        const popupHeight = this.popupSettings.height;
        return isPresent(popupHeight) ? `${popupHeight}px` : 'auto';
    }
    get listContainerClasses() {
        const containerClasses = ['k-list-container', 'k-reset'];
        if (this.popupSettings.popupClass) {
            containerClasses.push(this.popupSettings.popupClass);
        }
        return containerClasses;
    }
    get suggestion() {
        if (!this.text || !this.suggestedText) {
            this.suggestedText = undefined;
            return;
        }
        const hasMatch = this.suggestedText.toLowerCase().startsWith(this.text.toLowerCase());
        const shouldSuggest = this.suggest && !this.backspacePressed;
        if (shouldSuggest && hasMatch) {
            return this.suggestedText;
        }
    }
    get appendTo() {
        const { appendTo } = this.popupSettings;
        if (!appendTo || appendTo === 'root') {
            return undefined;
        }
        return appendTo === 'component' ? this.container : appendTo;
    }
    /**
     * Toggles the visibility of the popup.
     * If you use the `toggle` method to open or close the popup, the `open` and `close` events will not be fired.
     *
     * @param open - The state of the popup.
     */
    toggle(open) {
        Promise.resolve(null).then(() => {
            this._toggle(open);
        });
    }
    /**
     * Returns the current open state of the popup.
     */
    get isOpen() {
        return this._open;
    }
    /**
     * @hidden
     */
    togglePopup(open) {
        const isDisabled = this.disabled || this.readonly;
        const sameState = this.isOpen === open;
        if (isDisabled || sameState) {
            return;
        }
        const isDefaultPrevented = this.triggerPopupEvents(open);
        if (!isDefaultPrevented) {
            this._toggle(open);
        }
    }
    get activeDescendant() {
        if (!this.isOpen || !isPresent(this.selectionService.focused) || this.selectionService.focused === -1) {
            return null;
        }
        const dataItem = this.dataService.itemAt(this.selectionService.focused);
        return this.optionPrefix + "-" + getter(dataItem, this.valueField);
    }
    get noDataLabel() {
        if (this.data.length === 0) {
            return this.noDataText;
        }
    }
    get clearTitle() {
        return this.localization.get('clearTitle');
    }
    /**
     * Sets the data of the AutoComplete.
     *
     * > The data has to be provided in an array-like list.
     */
    set data(data) {
        this.dataService.data = data || [];
        if (this.virtual) {
            this.virtual.skip = 0;
        }
        this.setState(this.value);
        if (this.filterable) {
            this.selectionService.focused = this.isOpen && this.data.length && this.highlightFirst ? this.firstFocusableIndex(0) : -1;
        }
        if (this.suggest && this.dataService.itemsCount > 0) {
            this.suggestedText = getter(this.dataService.itemAt(0), this.valueField);
        }
    }
    get data() {
        const virtual = this.virtual;
        if (virtual) {
            const start = virtual.skip || 0;
            const end = start + virtual.pageSize;
            // Use length instead of itemsCount because of the grouping.
            virtual.total = this.dataService.data.length;
            return this.dataService.data.slice(start, end);
        }
        return this.dataService.data;
    }
    /**
     * Sets the value of the AutoComplete.
     */
    set value(newValue) {
        this.verifySettings(newValue);
        this._value = newValue || NO_VALUE;
        this.cdr.markForCheck();
    }
    get value() {
        return this._value || NO_VALUE;
    }
    /**
     * Configures the popup of the AutoComplete.
     *
     * The available options are:
     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
     * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.
     * - `height: Number`&mdash;Sets the height of the popup container.
     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
     * - `appendTo: "root" | "component" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.
     */
    set popupSettings(settings) {
        this._popupSettings = Object.assign({ animate: true }, settings);
    }
    get popupSettings() {
        return this._popupSettings;
    }
    /**
     * Defines a Boolean function that is executed for each data item in the component
     * ([see examples]({% slug disableditems_autocomplete %})).
     * Determines whether the item will be disabled.
     */
    set itemDisabled(fn) {
        if (typeof fn !== 'function') {
            throw new Error(`itemDisabled must be a function, but received ${JSON.stringify(fn)}.`);
        }
        this.disabledItemsService.itemDisabled = fn;
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    /**
     * Enables the [virtualization]({% slug virtualization_autocomplete %}) functionality.
     */
    set virtual(settings) {
        this._virtualSettings = normalizeVirtualizationSettings(settings);
    }
    get virtual() {
        return this._virtualSettings;
    }
    get isFocused() {
        return this._isFocused;
    }
    set isFocused(isFocused) {
        this._isFocused = isFocused;
    }
    get isDisabled() {
        return this.disabled;
    }
    get dir() {
        return this.direction;
    }
    ngOnInit() {
        this.renderer.removeAttribute(this.wrapper, "tabindex");
        this.localizationChangeSubscription = this.localization
            .changes
            .subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
            this.setMessages();
        });
        this.setMessages();
    }
    ngOnDestroy() {
        this.destroyPopup();
        this.unsubscribeEvents();
        clearTimeout(this.messagesTimeout);
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
    }
    ngOnChanges(changes) {
        const virtual = this.virtual;
        const requestInitialData = virtual && changes.data && changes.data.isFirstChange();
        if (requestInitialData) {
            this.pageChange({ skip: 0, take: virtual.pageSize });
        }
        const STATE_PROPS = /(value|valueField)/g;
        if (STATE_PROPS.test(Object.keys(changes).join())) {
            this.setState(this.value);
        }
    }
    /**
     * Resets the value of the AutoComplete.
     * If you use the `reset` method to clear the value of the component,
     * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.
     */
    reset() {
        this.setState(NO_VALUE);
    }
    /**
     * @hidden
     */
    clearValue(event) {
        event.stopImmediatePropagation();
        this.focus();
        this.change(NO_VALUE);
        if (this.filterable) {
            this.filterChange.emit('');
        }
        this.selectionService.resetSelection([]);
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.setState(value);
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * Focuses the AutoComplete.
     */
    focus() {
        if (!this.disabled) {
            this.searchbar.focus();
        }
    }
    /**
     * Blurs the AutoComplete.
     */
    blur() {
        if (!this.disabled) {
            this.searchbar.blur();
        }
    }
    /**
     * @hidden
     */
    onResize() {
        if (this._open) {
            const popupWrapper = this.popupRef.popupElement;
            const { min, max } = this.width;
            popupWrapper.style.minWidth = min;
            popupWrapper.style.width = max;
        }
    }
    emitChange() {
        if (this.value === this._previousValue) {
            return;
        }
        this._previousValue = this.value;
        this.onChangeCallback(this.value);
        this.valueChange.emit(this.value);
    }
    verifySettings(newValue) {
        if (!isDevMode()) {
            return;
        }
        if (isPresent(newValue) && typeof newValue !== "string") {
            throw new Error("Expected value of type string. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/autocomplete/#toc-value");
        }
    }
    search(text, startFrom = 0) {
        let index;
        if (text.length && this.dataService.itemsCount) {
            index = this.dataService.findIndex(this.findIndexPredicate(text), startFrom);
        }
        else {
            index = -1;
        }
        if (this.disabledItemsService.isIndexDisabled(index)) {
            if (index + 1 < this.dataService.itemsCount) {
                this.search(text, index + 1);
            }
            else {
                this.selectionService.focus(-1);
            }
        }
        else {
            this.selectionService.focus(index);
            if (this.suggest) {
                this.suggestedText = getter(this.dataService.itemAt(index), this.valueField);
            }
        }
    }
    navigate(index) {
        if (!this.isOpen) {
            return;
        }
        this.selectionService.focus(index);
    }
    /**
     * @hidden
     */
    handleNavigate(event) {
        const focused = isNaN(this.selectionService.focused) ? this.firstFocusableIndex(0) : this.selectionService.focused;
        if (this.disabled || this.readonly || isNaN(focused)) {
            return;
        }
        const action = this.navigationService.process({
            current: focused,
            max: this.dataService.itemsCount - 1,
            min: 0,
            originalEvent: event
        });
        if (action !== NavigationAction.Undefined &&
            action !== NavigationAction.Backspace &&
            action !== NavigationAction.Delete &&
            action !== NavigationAction.Home &&
            action !== NavigationAction.End &&
            action !== NavigationAction.Left &&
            action !== NavigationAction.Right &&
            ((action === NavigationAction.Enter && this.isOpen) || action !== NavigationAction.Enter)) {
            event.preventDefault();
        }
    }
    handleEnter(event) {
        const focused = this.selectionService.focused;
        let value;
        this._filtering = false;
        if (this.isOpen) {
            event.originalEvent.preventDefault();
        }
        if (focused >= 0) {
            value = getter(this.dataService.itemAt(focused), this.valueField);
        }
        else {
            const match = this.suggest && this.suggestedText && this.data.length &&
                getter(this.dataService.itemAt(0), this.valueField, true).toLowerCase() === this.searchbar.value.toLowerCase();
            if (this.isOpen && match) {
                value = this.suggestedText;
            }
            else {
                value = this.searchbar.value;
            }
        }
        this.change(value);
    }
    handleEscape() {
        this.togglePopup(false);
        this.selectionService.focused = -1;
        this.suggestedText = null;
    }
    /**
     * @hidden
     */
    searchBarChange(text) {
        const currentTextLength = isPresent(this.text) ? this.text.length : 0;
        this.backspacePressed = (text.length < currentTextLength) ? true : false;
        this.text = text;
        this.togglePopup(text.length > 0);
        this._filtering = true;
        if (!this.highlightFirst) {
            this.selectionService.focused = -1;
        }
        if (this.filterable) {
            this.filterChange.emit(text);
        }
        else if (this.highlightFirst) {
            this.search(text);
        }
    }
    /**
     * @hidden
     */
    handleFocus() {
        this.isFocused = true;
        this.onFocus.emit();
    }
    /**
     * @hidden
     */
    handleBlur() {
        this._filtering = false;
        const focused = this.filterable ? this.selectionService.focused : -1;
        let dataItem;
        let text;
        if (focused !== -1) {
            dataItem = this.dataService.itemAt(focused);
            text = getter(dataItem, this.valueField, true) || "";
        }
        else {
            text = this.searchbar.value;
        }
        const exactMatch = text === this.searchbar.value;
        const insensitiveMatch = text.toLowerCase() === this.searchbar.value.toLowerCase();
        if (!exactMatch && insensitiveMatch) {
            this.selectionService.resetSelection([]);
        }
        this.change(this.searchbar.value);
        this.togglePopup(false);
        this.isFocused = false;
        this.onBlur.emit();
        this.onTouchedCallback();
    }
    /**
     * @hidden
     */
    pageChange(event) {
        const virtual = this.virtual;
        virtual.skip = event.skip;
    }
    setState(newValue) {
        if (this._filtering) {
            return;
        }
        this.value = newValue;
        this._previousValue = this.value;
        this.text = this.value;
    }
    change(value) {
        this.togglePopup(false);
        this.valueChangeSubject.next(value);
    }
    subscribeEvents() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.valueChangeSubscription = this.valueChangeSubject.pipe(filter((candidate) => {
            return !(this.value === candidate && this.text === candidate);
        }))
            .subscribe((value) => {
            this.value = value;
            this.text = value;
            this.emitChange();
        });
        this.changeSubscription = this.selectionService.onChange.subscribe(this.handleItemChange.bind(this));
        this.focusSubscription = this.selectionService.onFocus.subscribe(this.handleItemFocus.bind(this));
        this.navigationSubscription = merge(this.navigationService.up, this.navigationService.down).subscribe((event) => this.navigate(event.index));
        this.closeSubscription = this.navigationService.close.subscribe(() => this.togglePopup(false));
        this.enterSubscription = this.navigationService.enter.subscribe(this.handleEnter.bind(this));
        this.escSubscription = this.navigationService.esc.subscribe(this.handleEscape.bind(this));
    }
    unsubscribeEvents() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.changeSubscription.unsubscribe();
        this.navigationSubscription.unsubscribe();
        this.closeSubscription.unsubscribe();
        this.enterSubscription.unsubscribe();
        this.escSubscription.unsubscribe();
        this.valueChangeSubscription.unsubscribe();
        this.focusSubscription.unsubscribe();
    }
    handleItemChange(event) {
        const index = event.indices.length ? event.indices[0] : undefined;
        this._filtering = false;
        this.selectionService.resetSelection([-1]);
        if (!isPresent(index)) {
            return;
        }
        let text = getter(this.dataService.itemAt(index), this.valueField);
        this.change(text);
    }
    handleItemFocus(_event) {
        const focused = this.selectionService.focused;
        const shouldSuggest = Boolean(this.suggest && this.data && this.data.length && focused >= 0);
        if (shouldSuggest) {
            this.suggestedText = getter(this.dataService.itemAt(focused), this.valueField);
        }
    }
    createPopup() {
        if (this.virtual) {
            this.virtual.skip = 0;
        }
        const horizontalAlign = this.direction === "rtl" ? "right" : "left";
        const anchorPosition = { horizontal: horizontalAlign, vertical: "bottom" };
        const popupPosition = { horizontal: horizontalAlign, vertical: "top" };
        this.popupRef = this.popupService.open({
            anchor: this.wrapper,
            animate: this.popupSettings.animate,
            appendTo: this.appendTo,
            content: this.popupTemplate,
            popupClass: this.listContainerClasses,
            positionMode: 'absolute',
            popupAlign: popupPosition,
            anchorAlign: anchorPosition
        });
        const popupWrapper = this.popupRef.popupElement;
        const { min, max } = this.width;
        popupWrapper.addEventListener('mousedown', this.popupMouseDownHandler);
        popupWrapper.style.minWidth = min;
        popupWrapper.style.width = max;
        popupWrapper.style.height = this.height;
        popupWrapper.setAttribute("dir", this.direction);
        this.popupRef.popupOpen.subscribe(() => {
            this.cdr.detectChanges();
            this.optionsList.scrollToItem(this.selectionService.focused);
        });
        this.popupRef.popupAnchorViewportLeave.subscribe(() => this.togglePopup(false));
    }
    destroyPopup() {
        if (this.popupRef) {
            this.popupRef.popupElement
                .removeEventListener('mousedown', this.popupMouseDownHandler);
            this.popupRef.close();
            this.popupRef = null;
        }
    }
    _toggle(open) {
        this._open = (open === undefined) ? !this._open : open;
        this.destroyPopup();
        if (this._open) {
            this.createPopup();
        }
    }
    triggerPopupEvents(open) {
        const eventArgs = new PreventableEvent();
        if (open) {
            this.open.emit(eventArgs);
        }
        else {
            this.close.emit(eventArgs);
        }
        return eventArgs.isDefaultPrevented();
    }
    firstFocusableIndex(index) {
        const maxIndex = this.data.length - 1;
        if (this.disabledItemsService.isIndexDisabled(index)) {
            return (index < maxIndex) ? this.firstFocusableIndex(index + 1) : undefined;
        }
        else {
            return index;
        }
    }
    findIndexPredicate(text) {
        if (this.dataService.grouped) {
            return (item) => {
                let itemText = getter(item.value, this.valueField);
                itemText = !isPresent(itemText) ? "" : itemText.toString().toLowerCase();
                return itemText.startsWith(text.toLowerCase());
            };
        }
        else {
            return (item) => {
                let itemText = getter(item, this.valueField);
                itemText = !isPresent(itemText) ? "" : itemText.toString().toLowerCase();
                return itemText.startsWith(text.toLowerCase());
            };
        }
    }
    setMessages() {
        this._zone.runOutsideAngular(() => {
            clearTimeout(this.messagesTimeout);
            this.messagesTimeout = setTimeout(() => {
                this.noDataText = this.localization.get('noDataText');
                this.cdr.detectChanges();
            });
        });
    }
}
AutoCompleteComponent.ɵfac = function AutoCompleteComponent_Factory(t) { return new (t || AutoCompleteComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(DataService), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.PopupService), ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(DisabledItemsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AutoCompleteComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AutoCompleteComponent, selectors: [["kendo-autocomplete"]], contentQueries: function AutoCompleteComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ItemTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, GroupTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, FixedGroupTemplateDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.fixedGroupTemplate = _t.first);
    } }, viewQuery: function AutoCompleteComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c9, true, ViewContainerRef);
        ɵngcc0.ɵɵviewQuery(_c10, true);
        ɵngcc0.ɵɵviewQuery(SearchBarComponent, true);
        ɵngcc0.ɵɵviewQuery(_c11, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.searchbar = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.optionsList = _t.first);
    } }, hostVars: 11, hostBindings: function AutoCompleteComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.dir);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.widgetClasses)("k-autocomplete", ctx.widgetClasses)("k-header", ctx.widgetClasses)("k-state-focused", ctx.isFocused)("k-state-disabled", ctx.isDisabled);
    } }, inputs: { highlightFirst: "highlightFirst", focusableId: "focusableId", placeholder: "placeholder", listHeight: "listHeight", clearButton: "clearButton", disabled: "disabled", readonly: "readonly", tabindex: "tabindex", filterable: "filterable", data: "data", value: "value", popupSettings: "popupSettings", itemDisabled: "itemDisabled", tabIndex: "tabIndex", virtual: "virtual", valueField: "valueField", loading: "loading", suggest: "suggest" }, outputs: { valueChange: "valueChange", filterChange: "filterChange", open: "open", close: "close", onFocus: "focus", onBlur: "blur" }, exportAs: ["kendoAutoComplete"], features: [ɵngcc0.ɵɵProvidersFeature([
            AUTOCOMPLETE_VALUE_ACCESSOR,
            DataService,
            SelectionService,
            NavigationService,
            DisabledItemsService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.autocomplete'
            },
            {
                provide: FilterableDropDownComponentBase, useExisting: forwardRef(() => AutoCompleteComponent)
            },
            {
                provide: KendoInput, useExisting: forwardRef(() => AutoCompleteComponent)
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature()], decls: 11, vars: 15, consts: [["kendoAutoCompleteLocalizedMessages", "", 6, "noDataText", "clearTitle"], [3, "role", "id", "listId", "activeDescendant", "noDataLabel", "userInput", "suggestedText", "disabled", "readonly", "tabIndex", "popupOpen", "placeholder", "onNavigate", "valueChange", "onBlur", "onFocus"], ["searchbar", ""], ["class", "k-icon k-clear-value k-i-close", "role", "button", "tabindex", "-1", 3, "click", "mousedown", 4, "ngIf"], ["class", "k-icon k-i-loading", 4, "ngIf"], ["popupTemplate", ""], [3, "ngIf"], ["container", ""], ["role", "button", "tabindex", "-1", 1, "k-icon", "k-clear-value", "k-i-close", 3, "click", "mousedown"], [1, "k-icon", "k-i-loading"], [4, "ngIf"], [3, "id", "optionPrefix", "data", "textField", "valueField", "template", "groupTemplate", "fixedGroupTemplate", "height", "show", "virtual", "pageChange"], ["optionsList", ""], ["class", "k-nodata", 4, "ngIf"], [3, "templateContext"], [1, "k-nodata"], [3, "ngIf", "templateContext"], [3, "resize"]], template: function AutoCompleteComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵi18nAttributes(1, _c16);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(2, "kendo-searchbar", 1, 2);
        ɵngcc0.ɵɵlistener("onNavigate", function AutoCompleteComponent_Template_kendo_searchbar_onNavigate_2_listener($event) { return ctx.handleNavigate($event); })("valueChange", function AutoCompleteComponent_Template_kendo_searchbar_valueChange_2_listener($event) { return ctx.searchBarChange($event); })("onBlur", function AutoCompleteComponent_Template_kendo_searchbar_onBlur_2_listener() { return ctx.handleBlur(); })("onFocus", function AutoCompleteComponent_Template_kendo_searchbar_onFocus_2_listener() { return ctx.handleFocus(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(4, AutoCompleteComponent_span_4_Template, 1, 1, "span", 3);
        ɵngcc0.ɵɵtemplate(5, AutoCompleteComponent_span_5_Template, 1, 0, "span", 4);
        ɵngcc0.ɵɵtemplate(6, AutoCompleteComponent_ng_template_6_Template, 5, 14, "ng-template", null, 5, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(8, AutoCompleteComponent_ng_template_8_Template, 1, 0, "ng-template", 6);
        ɵngcc0.ɵɵelementContainer(9, null, 7);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("role", "combobox")("id", ctx.focusableId)("listId", ctx.listBoxId)("activeDescendant", ctx.activeDescendant)("noDataLabel", ctx.noDataLabel)("userInput", ctx.text)("suggestedText", ctx.suggestion)("disabled", ctx.disabled)("readonly", ctx.readonly)("tabIndex", ctx.tabIndex)("popupOpen", ctx.isOpen)("placeholder", ctx.placeholder);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.loading && !ctx.readonly && (ctx.clearButton && (ctx.text == null ? null : ctx.text.length)));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.loading);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isOpen);
    } }, directives: function () { return [LocalizedMessagesDirective,
        SearchBarComponent, ɵngcc2.NgIf, ListComponent,
        TemplateContextDirective, ɵngcc4.ResizeSensorComponent]; }, encapsulation: 2 });
/** @nocollapse */
AutoCompleteComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: DataService },
    { type: PopupService },
    { type: SelectionService },
    { type: NavigationService },
    { type: DisabledItemsService },
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: ElementRef }
];
AutoCompleteComponent.propDecorators = {
    highlightFirst: [{ type: Input }],
    focusableId: [{ type: Input }],
    data: [{ type: Input }],
    value: [{ type: Input }],
    valueField: [{ type: Input }],
    placeholder: [{ type: Input }],
    popupSettings: [{ type: Input }],
    listHeight: [{ type: Input }],
    loading: [{ type: Input }],
    clearButton: [{ type: Input }],
    suggest: [{ type: Input }],
    disabled: [{ type: Input }],
    itemDisabled: [{ type: Input }],
    readonly: [{ type: Input }],
    tabindex: [{ type: Input }],
    tabIndex: [{ type: Input, args: ["tabIndex",] }],
    filterable: [{ type: Input }],
    virtual: [{ type: Input }],
    valueChange: [{ type: Output }],
    filterChange: [{ type: Output }],
    open: [{ type: Output }],
    close: [{ type: Output }],
    onFocus: [{ type: Output, args: ['focus',] }],
    onBlur: [{ type: Output, args: ['blur',] }],
    template: [{ type: ContentChild, args: [ItemTemplateDirective,] }],
    headerTemplate: [{ type: ContentChild, args: [HeaderTemplateDirective,] }],
    footerTemplate: [{ type: ContentChild, args: [FooterTemplateDirective,] }],
    noDataTemplate: [{ type: ContentChild, args: [NoDataTemplateDirective,] }],
    groupTemplate: [{ type: ContentChild, args: [GroupTemplateDirective,] }],
    fixedGroupTemplate: [{ type: ContentChild, args: [FixedGroupTemplateDirective,] }],
    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] }],
    popupTemplate: [{ type: ViewChild, args: ['popupTemplate',] }],
    searchbar: [{ type: ViewChild, args: [SearchBarComponent,] }],
    optionsList: [{ type: ViewChild, args: ['optionsList',] }],
    widgetClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-autocomplete',] }, { type: HostBinding, args: ['class.k-header',] }],
    isFocused: [{ type: HostBinding, args: ['class.k-state-focused',] }],
    isDisabled: [{ type: HostBinding, args: ['class.k-state-disabled',] }],
    dir: [{ type: HostBinding, args: ['attr.dir',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AutoCompleteComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoAutoComplete',
                providers: [
                    AUTOCOMPLETE_VALUE_ACCESSOR,
                    DataService,
                    SelectionService,
                    NavigationService,
                    DisabledItemsService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.autocomplete'
                    },
                    {
                        provide: FilterableDropDownComponentBase, useExisting: forwardRef(() => AutoCompleteComponent)
                    },
                    {
                        provide: KendoInput, useExisting: forwardRef(() => AutoCompleteComponent)
                    }
                ],
                selector: 'kendo-autocomplete',
                template: `
        <ng-container kendoAutoCompleteLocalizedMessages
            i18n-noDataText="kendo.autocomplete.noDataText|The text displayed in the popup when there are no items"
            noDataText="NO DATA FOUND"

            i18n-clearTitle="kendo.autocomplete.clearTitle|The title of the clear button"
            clearTitle="clear"
        >
        </ng-container>
        <kendo-searchbar #searchbar
            [role]="'combobox'"
            [id]="focusableId"
            [listId]="listBoxId"
            [activeDescendant]="activeDescendant"
            [noDataLabel]="noDataLabel"
            [userInput]="text"
            [suggestedText]="suggestion"
            [disabled]="disabled"
            [readonly]="readonly"
            [tabIndex]="tabIndex"
            [popupOpen]="isOpen"
            [placeholder]="placeholder"
            (onNavigate)="handleNavigate($event)"
            (valueChange)="searchBarChange($event)"
            (onBlur)="handleBlur()"
            (onFocus)="handleFocus()"
        ></kendo-searchbar>
        <span *ngIf="!loading && !readonly && (clearButton && text?.length)" class="k-icon k-clear-value k-i-close" [attr.title]="clearTitle" role="button" tabindex="-1" (click)="clearValue($event)" (mousedown)="$event.preventDefault()">
</span>
        <span *ngIf="loading" class="k-icon k-i-loading"></span>
        <ng-template #popupTemplate>
            <!--header template-->
            <ng-template *ngIf="headerTemplate"
                [templateContext]="{
                    templateRef: headerTemplate.templateRef
                }">
            </ng-template>
            <!--list-->
            <kendo-list
                #optionsList
                [id]="listBoxId"
                [optionPrefix]="optionPrefix"
                [data]="data"
                [textField]="valueField"
                [valueField]="valueField"
                [template]="template"
                [groupTemplate]="groupTemplate"
                [fixedGroupTemplate]="fixedGroupTemplate"
                [height]="listHeight"
                [show]="isOpen"
                [virtual]="virtual"
                (pageChange)="pageChange($event)"
            >
            </kendo-list>
            <!--no-data template-->
            <div class="k-nodata" *ngIf="data.length === 0">
                <ng-template [ngIf]="noDataTemplate"
                    [templateContext]="{
                        templateRef: noDataTemplate?.templateRef
                    }">
                </ng-template>
                <ng-template [ngIf]="!noDataTemplate">
                    <div>{{ noDataText }}</div>
                </ng-template>
            </div>
            <!--footer template-->
            <ng-template *ngIf="footerTemplate"
                [templateContext]="{
                    templateRef: footerTemplate.templateRef
                }">
            </ng-template>
        </ng-template>
        <ng-template [ngIf]="isOpen">
            <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>
        </ng-template>
        <ng-container #container></ng-container>
  `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: DataService }, { type: ɵngcc3.PopupService }, { type: SelectionService }, { type: NavigationService }, { type: DisabledItemsService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { highlightFirst: [{
            type: Input
        }], focusableId: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], listHeight: [{
            type: Input
        }], clearButton: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], filterable: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], filterChange: [{
            type: Output
        }], open: [{
            type: Output
        }], close: [{
            type: Output
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], widgetClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-autocomplete']
        }, {
            type: HostBinding,
            args: ['class.k-header']
        }], data: [{
            type: Input
        }], value: [{
            type: Input
        }], popupSettings: [{
            type: Input
        }], itemDisabled: [{
            type: Input
        }], tabIndex: [{
            type: Input,
            args: ["tabIndex"]
        }], virtual: [{
            type: Input
        }], isFocused: [{
            type: HostBinding,
            args: ['class.k-state-focused']
        }], isDisabled: [{
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], dir: [{
            type: HostBinding,
            args: ['attr.dir']
        }], valueField: [{
            type: Input
        }], loading: [{
            type: Input
        }], suggest: [{
            type: Input
        }], template: [{
            type: ContentChild,
            args: [ItemTemplateDirective]
        }], headerTemplate: [{
            type: ContentChild,
            args: [HeaderTemplateDirective]
        }], footerTemplate: [{
            type: ContentChild,
            args: [FooterTemplateDirective]
        }], noDataTemplate: [{
            type: ContentChild,
            args: [NoDataTemplateDirective]
        }], groupTemplate: [{
            type: ContentChild,
            args: [GroupTemplateDirective]
        }], fixedGroupTemplate: [{
            type: ContentChild,
            args: [FixedGroupTemplateDirective]
        }], container: [{
            type: ViewChild,
            args: ['container', { read: ViewContainerRef }]
        }], popupTemplate: [{
            type: ViewChild,
            args: ['popupTemplate']
        }], searchbar: [{
            type: ViewChild,
            args: [SearchBarComponent]
        }], optionsList: [{
            type: ViewChild,
            args: ['optionsList']
        }] }); })();

/**
 * @hidden
 */
const TOUCH_ENABLED = new InjectionToken('dropdowns-touch-enabled');

/**
 * @hidden
 */
/* tslint:disable:max-line-length */
/* tslint:disable:variable-name */
const MultiselectMessages = {
    'array': 'Expected values of array type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/#value-selection',
    'object': 'Expected values of Object type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/#value-selection',
    'primitive': 'Expected values of primitive type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/#value-selection',
    'textAndValue': 'Expected textField and valueField options to be set. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/#toc-bind-to-arrays-of-complex-data'
};
/**
 * @hidden
 */
/* tslint:disable:max-line-length */
/* tslint:disable:variable-name */
const ComboBoxMessages = {
    'object': 'Expected value of type Object. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/combobox/#toc-value-selection',
    'primitive': 'Expected value of primitive type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/combobox/#toc-value-selection',
    'textAndValue': 'Expected textField and valueField options to be set. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/combobox/#toc-bind-to-arrays-of-complex-data',
    'noItemHeight': 'Expected virtual.itemHeight of type number.'
};
/**
 * @hidden
 */
/* tslint:disable:max-line-length */
/* tslint:disable:variable-name */
const DropDownListMessages = {
    'defaultItem': 'defaultItem and data items must be of same type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/api/DropDownListComponent/#toc-defaultitem',
    'object': 'Expected value of type Object. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdownlist/#toc-value-selection',
    'primitive': 'Expected value of primitive type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdownlist/#toc-value-selection',
    'textAndValue': 'Expected textField and valueField options to be set. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdownlist/#toc-bind-to-arrays-of-complex-data'
};

/* tslint:disable:no-null-keyword */
/**
 * @hidden
 */
const COMBOBOX_VALUE_ACCESSOR = {
    multi: true,
    provide: NG_VALUE_ACCESSOR,
    // tslint:disable-next-line:no-use-before-declare
    useExisting: forwardRef(() => ComboBoxComponent)
};
/**
 * Represents the [Kendo UI ComboBox component for Angular]({% slug overview_combobox %}).
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-combobox [data]="listItems">
 *  </kendo-combobox>
 * `
 * })
 * class AppComponent {
 *   public listItems: Array<string> = ["Item 1", "Item 2", "Item 3", "Item 4"];
 * }
 * ```
 */
class ComboBoxComponent {
    constructor(localization, popupService, selectionService, navigationService, disabledItemsService, dataService, _zone, cdr, renderer, wrapper, touchEnabled) {
        this.localization = localization;
        this.popupService = popupService;
        this.selectionService = selectionService;
        this.navigationService = navigationService;
        this.disabledItemsService = disabledItemsService;
        this.dataService = dataService;
        this._zone = _zone;
        this.cdr = cdr;
        this.renderer = renderer;
        this.touchEnabled = touchEnabled;
        this.selected = [];
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Specifies whether the ComboBox allows user-defined values that are not present in the dataset
         * ([more information and examples]({% slug custom_values_combobox %})).
         * Defaults to `false`.
         */
        this.allowCustom = false;
        /**
         * A user-defined callback which returns normalized custom values.
         * Typically used when the data items are different from type `string`.
         * @param { Any } value - The custom value defined by the user.
         * @returns { Any }
         *
         * @example
         * ```ts
         * import { map } from 'rxjs/operators';
         *
         * _@Component({
         * selector: 'my-app',
         * template: `
         *   <kendo-combobox
         *       [allowCustom]="true"
         *       [data]="listItems"
         *       [textField]="'text'"
         *       [valueField]="'value'"
         *       [valueNormalizer]="valueNormalizer"
         *       (valueChange)="onValueChange($event)"
         *   >
         *   </kendo-combobox>
         * `
         * })
         *
         * class AppComponent {
         *   public listItems: Array<{ text: string, value: number }> = [
         *       { text: "Small", value: 1 },
         *       { text: "Medium", value: 2 },
         *       { text: "Large", value: 3 }
         *   ];
         *
         *   public onValueChange(value) {
         *       console.log("valueChange : ", value);
         *   }
         *
         *   public valueNormalizer = (text$: Observable<string>) => text$.pipe(map((text: string) => {
         *      return { ProductID: null, ProductName: text };
         *   }));
         *
         * }
         * ```
         */
        this.valueNormalizer = (text) => text.pipe(map((userInput) => userInput));
        /**
         * The hint that is displayed when the component is empty.
         *
         */
        this.placeholder = "";
        /**
         * Sets the height of the suggestions list. By default, `listHeight` is 200px.
         *
         * > The `listHeight` property affects only the list of suggestions and not the whole popup container.
         * > To set the height of the popup container, use `popupSettings.height`.
         */
        this.listHeight = 200;
        /**
         * Enables the auto-completion of the text based on the first data item.
         */
        this.suggest = false;
        /**
         * If set to `true`, renders a button on hovering over the component.
         * Clicking this button resets the value of the component to `undefined` and triggers the `change` event.
         */
        this.clearButton = true;
        /**
         * Sets the disabled state of the component.
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the component.
         */
        this.readonly = false;
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Enables the [filtering]({% slug filtering_combobox %}) functionality.
         * If set to `true`, the component emits the `filterChange` event.
         */
        this.filterable = false;
        /**
         * Fires each time the value is changed&mdash;
         * when the component is blurred or the value is cleared through the **Clear** button
         * ([see example]({% slug overview_combobox %}#toc-events)).
         * When the value of the component is programmatically changed to `ngModel` or `formControl`
         * through its API or form binding, the `valueChange` event is not triggered because it
         * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time an item selection is changed
         * ([see example]({% slug overview_combobox %}#toc-events)).
         */
        this.selectionChange = new EventEmitter();
        /**
         * Fires each time the user types in the input field.
         * You can filter the source based on the passed filtration value
         * ([see example]({% slug overview_combobox %}#toc-events)).
         */
        this.filterChange = new EventEmitter();
        /**
         * Fires each time the popup is about to open.
         * This event is preventable. If you cancel it, the popup will remain closed.
         */
        this.open = new EventEmitter();
        /**
         * Fires each time the popup is about to close.
         * This event is preventable. If you cancel it, the popup will remain open.
         */
        this.close = new EventEmitter();
        /**
         * Fires each time the user focuses the ComboBox.
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the ComboBox gets blurred.
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        this.widgetClasses = true;
        this.isFocused = false;
        this.listBoxId = guid();
        this.optionPrefix = guid();
        this.onChangeCallback = (_) => { };
        this.onTouchedCallback = (_) => { };
        this._filtering = false;
        this._text = '';
        this.filterText = '';
        this._open = false;
        this._popupSettings = { animate: true };
        this.popupMouseDownHandler = (event) => event.preventDefault();
        this.customValueSubject = new Subject();
        this.valueSubject = new Subject();
        this.clearValueSubject = new Subject();
        this.selectionSubject = new Subject();
        this.subs = new Subscription();
        this.direction = localization.rtl ? 'rtl' : 'ltr';
        this.wrapper = wrapper.nativeElement;
        this.data = [];
    }
    get width() {
        let wrapperOffsetWidth = 0;
        if (isDocumentAvailable()) {
            wrapperOffsetWidth = this.wrapper.offsetWidth;
        }
        const width = this.popupSettings.width || wrapperOffsetWidth;
        const minWidth = isNaN(wrapperOffsetWidth) ? wrapperOffsetWidth : `${wrapperOffsetWidth}px`;
        const maxWidth = isNaN(width) ? width : `${width}px`;
        return { min: minWidth, max: maxWidth };
    }
    get height() {
        const popupHeight = this.popupSettings.height;
        return isPresent(popupHeight) ? `${popupHeight}px` : 'auto';
    }
    set text(text) {
        this._text = isPresent(text) ? text.toString() : "";
    }
    get text() {
        return this._text;
    }
    /**
     * @hidden
     */
    togglePopup(open) {
        const isDisabled = this.disabled || this.readonly;
        const sameState = this.isOpen === open;
        if (isDisabled || sameState) {
            return;
        }
        const isDefaultPrevented = this.triggerPopupEvents(open);
        if (!isDefaultPrevented) {
            this._toggle(open);
        }
    }
    get activeDescendant() {
        if (!this.isOpen || !isPresent(this.selectionService.focused) || this.selectionService.focused === -1) {
            return null;
        }
        const dataItem = this.dataService.itemAt(this.selectionService.focused);
        return this.optionPrefix + "-" + (dataItem ? getter(dataItem, this.valueField) : "");
    }
    get noDataLabel() {
        if (this.data.length === 0) {
            return this.noDataText;
        }
    }
    get clearTitle() {
        return this.localization.get('clearTitle');
    }
    get appendTo() {
        const { appendTo } = this.popupSettings;
        if (!appendTo || appendTo === 'root') {
            return undefined;
        }
        return appendTo === 'component' ? this.container : appendTo;
    }
    /**
     * Sets the data of the ComboBox.
     *
     * > The data has to be provided in an array-like list.
     */
    set data(data) {
        this.dataService.data = data || [];
        if (this.virtual) {
            this.virtual.skip = 0;
        }
        this.setState();
        if (this._filtering) {
            const queryAndDataPresent = this.text.length > 0 && this.dataService.itemsCount > 0;
            const index = queryAndDataPresent ? this.firstFocusableIndex(0) : -1;
            this.selectionService.focused = index;
        }
        if (this.suggest && this.dataService.itemsCount && this.text) {
            this.suggestedText = getter(this.dataService.itemAt(0), this.textField);
        }
    }
    get data() {
        const virtual = this.virtual;
        if (virtual) {
            const start = virtual.skip || 0;
            const end = start + virtual.pageSize;
            // Use length instead of itemsCount because of the grouping.
            virtual.total = this.dataService.data.length;
            return this.dataService.data.slice(start, end);
        }
        return this.dataService.data;
    }
    /**
     * Sets the value of the ComboBox.
     * It can either be of the primitive (string, numbers) or of the complex (objects) type.
     * To define the type, use the `valuePrimitive` option.
     *
     * > All selected values which are not present in the dataset are considered custom values.
     * > When the `Enter` key is pressed or the component loses focus, custom values get dismissed unless `allowCustom` is set to `true`.
     */
    set value(newValue) {
        this.verifySettings(newValue);
        this._value = newValue;
        this.cdr.markForCheck();
    }
    get value() {
        return this._value;
    }
    /**
     * Configures the popup of the ComboBox.
     *
     * The available options are:
     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
     * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.
     * - `height: Number`&mdash;Sets the height of the popup container.
     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
     * - `appendTo: "root" | "component" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.
     */
    set popupSettings(settings) {
        this._popupSettings = Object.assign({ animate: true }, settings);
    }
    get popupSettings() {
        return this._popupSettings;
    }
    /**
     * Defines a Boolean function that is executed for each data item in the component
     * ([see examples]({% slug disableditems_combobox %})). Determines whether the item will be disabled.
     */
    set itemDisabled(fn) {
        if (typeof fn !== 'function') {
            throw new Error(`itemDisabled must be a function, but received ${JSON.stringify(fn)}.`);
        }
        this.disabledItemsService.itemDisabled = fn;
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    /**
     * Enables the [virtualization]({% slug virtualization_combobox %}) functionality.
     */
    set virtual(settings) {
        this._virtualSettings = normalizeVirtualizationSettings(settings);
    }
    get virtual() {
        return this._virtualSettings;
    }
    get clearable() {
        return this.clearButton;
    }
    get dir() {
        return this.direction;
    }
    ngOnInit() {
        this.renderer.removeAttribute(this.wrapper, "tabindex");
        this.attachStreams();
        this.createSelectionStream();
        this.createValueStream();
        this.setMessages();
    }
    createValueStream() {
        const valueStream = this.valueSubject.pipe(filter((candidate) => {
            const valueFrom = this.prop(this.valueField, this.valuePrimitive);
            const textFrom = this.prop(this.textField, this.valuePrimitive);
            const current = valueFrom(this.value);
            const newValue = valueFrom(candidate);
            let newText = textFrom(candidate);
            if (!isPresent(this.value) && !isPresent(newValue)) {
                return false;
            }
            if (isPresent(newText)) {
                newText = newText.toString();
            }
            if (current === newValue && this.text === newText) {
                this.clearFilter();
                return false;
            }
            else {
                return true;
            }
        }), map((candidate) => {
            const valueFrom = this.prop(this.valueField, this.valuePrimitive);
            const textFrom = this.prop(this.textField, this.valuePrimitive);
            const newValue = valueFrom(candidate);
            const newText = textFrom(candidate);
            return {
                dataItem: candidate,
                text: newText,
                value: this.valuePrimitive ? newValue : candidate
            };
        }));
        const customValueStreams = partition(() => this.allowCustom)(this.customValueSubject.pipe(throttleTime(300)));
        const allowCustomValueStream = customValueStreams[0].pipe(tap(() => {
            this.loading = true;
            this.disabled = true;
            this.cdr.detectChanges();
        }), filter(() => {
            const valueFrom = this.prop(this.valueField, this.valuePrimitive);
            const hasChange = this.text !== valueFrom(this.value);
            this.loading = hasChange;
            this.disabled = hasChange;
            if (!hasChange) {
                this.clearFilter();
            }
            return hasChange;
        }), this.valueNormalizer, map((normalizedValue) => {
            return {
                custom: true,
                dataItem: normalizedValue,
                text: this.text,
                value: normalizedValue
            };
        }));
        const disableCustomValueStream = customValueStreams[1].pipe(map(() => {
            return {
                custom: true,
                dataItem: undefined,
                text: undefined,
                value: undefined
            };
        }));
        const clearValueStream = this.clearValueSubject.pipe(map(() => ({
            dataItem: undefined,
            text: undefined,
            value: undefined
        })));
        if (this.valueSubscription) {
            this.valueSubscription.unsubscribe();
        }
        const merged = merge(valueStream, allowCustomValueStream, disableCustomValueStream, clearValueStream);
        this.valueSubscription = merged.pipe(catchError(() => {
            this.dataItem = undefined;
            this.value = undefined;
            this.text = undefined;
            this.loading = false;
            this.disabled = false;
            this.emitSelectionChange(undefined);
            this.emitValueChange();
            this.createValueStream();
            return of(null);
        }))
            .subscribe((state) => {
            this.dataItem = state.dataItem;
            this.value = state.value;
            this.text = state.text;
            this.loading = false;
            this.disabled = false;
            this.clearFilter();
            if (state.custom) {
                this.selectionService.focused = -1;
            }
            this.emitSelectionChange(state.custom ? undefined : this.dataItem);
            this.emitValueChange();
        });
    }
    attachStreams() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.subs.add(this.localization
            .changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
            this.setMessages();
        }));
        this.subs.add(merge(this.navigationService.up, this.navigationService.down, this.navigationService.home, this.navigationService.end)
            .pipe(filter((event) => isPresent(event.index)))
            .subscribe((event) => this.navigate(event.index)));
        this.subs.add(this.navigationService.open.subscribe(this.handleNavigationOpen.bind(this)));
        this.subs.add(this.navigationService.close.subscribe(() => this.togglePopup(false)));
        this.subs.add(this.navigationService.esc.subscribe(this.handleEscape.bind(this)));
        this.subs.add(this.navigationService.enter.pipe(tap((event) => {
            if (this.isOpen) {
                event.originalEvent.preventDefault();
            }
        }))
            .subscribe(this.handleEnter.bind(this)));
        this.subs.add(merge(this.selectionService.onChange, this.selectionService.onSelect.pipe(filter(_ => !this.isOpen)))
            .pipe(tap(_ => {
            this._filtering = false;
            this.togglePopup(false);
        }), map((event) => this.dataService.itemAt(event.indices[0])))
            .subscribe(dataItem => {
            this.change(dataItem);
        }));
        this.subs.add(this.selectionService.onSelect.pipe(filter(_ => this.isOpen), tap(_ => this._filtering = false), map((event) => this.dataService.itemAt(event.indices[0])))
            .subscribe(dataItem => {
            this.updateState({ dataItem });
            this.emitSelectionChange(dataItem);
        }));
    }
    ngOnDestroy() {
        this.destroyPopup();
        clearTimeout(this.messagesTimeout);
        this.subs.unsubscribe();
        [this.valueSubscription, this.selectionSubscription].forEach(sub => isPresent(sub) && sub.unsubscribe());
    }
    ngOnChanges(changes) {
        const virtual = this.virtual;
        const requestInitialData = virtual && changes.data && changes.data.isFirstChange();
        if (requestInitialData) {
            this.pageChange({ skip: 0, take: virtual.pageSize });
        }
        if (this.valuePrimitive === undefined) {
            this.valuePrimitive = this.valueField ? false : true;
        }
        this.verifySettings(this.value);
        if (isChanged("valueNormalizer", changes)) {
            this.createValueStream();
        }
        if (isChanged("value", changes)) {
            this.createSelectionStream();
        }
        if (this.valuePrimitive === undefined) {
            this.valuePrimitive = this.valueField ? false : true;
        }
        const STATE_PROPS = /(value|textField|valueField|valuePrimitive)/g;
        if (STATE_PROPS.test(Object.keys(changes).join())) {
            this.setState();
        }
    }
    /**
     * Focuses the ComboBox.
     */
    focus() {
        if (!this.disabled) {
            this.searchbar.focus();
        }
    }
    /**
     * Blurs the ComboBox.
     */
    blur() {
        if (!this.disabled) {
            this.searchbar.blur();
        }
    }
    /**
     * Toggles the visibility of the popup. If you use the `toggle` method to open or close the popup,
     * the `open` and `close` events will not be fired.
     *
     * @param open - The state of the popup.
     */
    toggle(open) {
        Promise.resolve(null).then(() => {
            this._toggle(open);
            this.cdr.markForCheck();
        });
    }
    /**
     * Returns the current open state of the popup.
     */
    get isOpen() {
        return this._open;
    }
    /**
     * Resets the value of the ComboBox.
     * If you use the `reset` method to clear the value of the component,
     * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.
     */
    reset() {
        this.value = undefined;
        this.clearState();
        this.resetSelection();
        this.createSelectionStream();
    }
    /**
     * @hidden
     *
     * Used by the TextBoxContainer to determine if the floating label
     * should be rendered in the input when the component is not focused.
     */
    isEmpty() {
        const textEmpty = !isPresent(this.text) || isEmptyString(this.text);
        const valueEmpty = !isPresent(this.value) || isEmptyString(this.value);
        return textEmpty && valueEmpty;
    }
    /**
     * @hidden
     */
    clearValue(event) {
        event.stopImmediatePropagation();
        this.focus();
        this._filtering = true;
        this._previousDataItem = undefined;
        this.selectionService.resetSelection([]);
        this.clearValueSubject.next();
        this._filtering = false;
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.text = "";
        this.value = value === null ? undefined : value;
        this.setState();
        this.createSelectionStream();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    get buttonClasses() {
        return this.loading ? 'k-i-loading' : this.iconClass || 'k-i-arrow-s';
    }
    /**
     * @hidden
     */
    onResize() {
        if (this.isOpen) {
            const popupWrapper = this.popupRef.popupElement;
            const { min, max } = this.width;
            popupWrapper.style.minWidth = min;
            popupWrapper.style.width = max;
        }
    }
    verifySettings(newValue) {
        const valueOrText = !isPresent(this.valueField) !== !isPresent(this.textField);
        if (!isDevMode()) {
            return;
        }
        if (this.valuePrimitive === true && isPresent(newValue) && typeof newValue === "object") {
            throw new Error(ComboBoxMessages.primitive);
        }
        if (this.valuePrimitive === false && isPresent(newValue) && typeof newValue !== "object") {
            throw new Error(ComboBoxMessages.object);
        }
        if (valueOrText) {
            throw new Error(ComboBoxMessages.textAndValue);
        }
        if (this.virtual && isNaN(this.virtual.itemHeight)) {
            throw new Error(ComboBoxMessages.noItemHeight);
        }
    }
    setState() {
        // Filtering in process, do nothing.
        if (this._filtering) {
            return;
        }
        const value = this.value;
        const valueField = this.valueField;
        const primitive = this.valuePrimitive;
        const resolved = this.findDataItem({ primitive, valueField, value });
        if (isPresent(resolved.dataItem)) {
            this.updateState({ dataItem: resolved.dataItem, confirm: true });
            this.resetSelection(resolved.index);
        }
        else if (isPresent(value) && this.allowCustom) {
            this.updateState({ dataItem: value });
            this.resetSelection(-1);
        }
        else if (this._previousDataItem && this.value) {
            this.updateState({ dataItem: this._previousDataItem });
            this.resetSelection();
        }
        else {
            this.clearState();
            this.resetSelection(-1);
        }
    }
    updateState({ dataItem, confirm = false }) {
        this.dataItem = dataItem;
        this.text = this.prop(this.textField, this.valuePrimitive)(dataItem);
        if (confirm) {
            this._previousDataItem = dataItem;
        }
    }
    clearState() {
        this.text = undefined;
        this.dataItem = undefined;
    }
    resetSelection(index) {
        const clear = !isPresent(index) || index < 0;
        this.selectionService.resetSelection(clear ? [] : [index]);
        this.selectionService.focused = index;
    }
    firstFocusableIndex(index) {
        const maxIndex = this.data.length - 1;
        if (this.disabledItemsService.isIndexDisabled(index)) {
            return (index < maxIndex) ? this.firstFocusableIndex(index + 1) : undefined;
        }
        else {
            return index;
        }
    }
    findIndexPredicate(text) {
        if (this.dataService.grouped) {
            return (item) => {
                let itemText = this.prop(this.textField, this.valuePrimitive)(item.value);
                itemText = !isPresent(itemText) ? "" : itemText.toString().toLowerCase();
                return itemText.startsWith(text.toLowerCase());
            };
        }
        else {
            return (item) => {
                let itemText = this.prop(this.textField, this.valuePrimitive)(item);
                itemText = !isPresent(itemText) ? "" : itemText.toString().toLowerCase();
                return itemText.startsWith(text.toLowerCase());
            };
        }
    }
    prop(field, usePrimitive) {
        return (dataItem) => {
            if (isPresent(dataItem)) {
                if (usePrimitive) {
                    return field && isObject(dataItem) ? dataItem[field] : dataItem;
                }
                else {
                    return dataItem[field];
                }
            }
            return null;
        };
    }
    findDataItem({ primitive, valueField, value }) {
        const result = {
            dataItem: null,
            index: -1
        };
        const prop = this.prop(valueField, primitive);
        let comparer;
        if (this.dataService.grouped) {
            comparer = (element) => {
                return prop(element.value) === prop(value);
            };
        }
        else {
            comparer = (element) => {
                return prop(element) === prop(value);
            };
        }
        const index = this.dataService.findIndex(comparer);
        result.dataItem = this.dataService.itemAt(index);
        result.index = index;
        return result;
    }
    search(text, startFrom = 0) {
        let index;
        if (text.length && this.dataService.itemsCount) {
            index = this.dataService.findIndex(this.findIndexPredicate(text), startFrom);
        }
        else {
            index = -1;
        }
        if (this.disabledItemsService.isIndexDisabled(index)) {
            if (index + 1 < this.dataService.itemsCount) {
                this.search(text, index + 1);
            }
            else {
                this.selectionService.focus(-1);
            }
        }
        else {
            this.selectionService.focus(index);
            if (this.suggest) {
                this.suggestedText = getter(this.dataService.itemAt(index), this.textField);
            }
        }
    }
    /**
     * @hidden
     */
    getSuggestion() {
        const hasSelected = !!this.selectionService.selected.length;
        const shouldSuggest = this.suggest && !this.backspacePressed && this.suggestedText && this.text;
        if (!hasSelected && shouldSuggest && this.suggestedText.toLowerCase().startsWith(this.text.toLowerCase())) {
            return this.suggestedText;
        }
        else {
            this.suggestedText = undefined;
        }
    }
    navigate(index) {
        if (this.dataService.itemsCount === 0) {
            return;
        }
        this.text = this.prop(this.textField, this.valuePrimitive)(this.dataService.itemAt(index));
        this.selectionService.select(index);
    }
    /**
     * @hidden
     */
    handleNavigate(event) {
        const hasSelected = isPresent(this.selectionService.selected[0]);
        const focused = isNaN(this.selectionService.focused) ? this.firstFocusableIndex(0) : this.selectionService.focused;
        let offset = 0;
        if (this.disabled || this.readonly) {
            return;
        }
        if (event.keyCode === Keys.home || event.keyCode === Keys.end) {
            return;
        }
        if (!hasSelected) {
            if (event.keyCode === Keys.down) {
                offset = -1;
            }
            else if (event.keyCode === Keys.up) {
                offset = 1;
            }
        }
        const action = this.navigationService.process({
            current: offset + focused,
            max: this.dataService.itemsCount - 1,
            min: 0,
            originalEvent: event
        });
        if (action !== NavigationAction.Undefined &&
            action !== NavigationAction.Left &&
            action !== NavigationAction.Right &&
            action !== NavigationAction.Backspace &&
            action !== NavigationAction.Delete &&
            ((action === NavigationAction.Enter && this.isOpen) || action !== NavigationAction.Enter)) {
            event.preventDefault();
        }
    }
    handleEnter() {
        const text = this.text;
        const focused = this.selectionService.focused;
        const hasFocused = isPresent(focused) && focused !== -1;
        const previousText = getter(this._previousDataItem, this.textField) || "";
        const focusedItemText = getter(this.dataService.itemAt(focused), this.textField);
        const textHasChanged = text !== previousText;
        this.togglePopup(false);
        this._filtering = false;
        if (this.allowCustom && textHasChanged) {
            if (text === focusedItemText || this.useSuggestion()) {
                this.selectionService.change(focused);
            }
            else {
                this.change(text, true);
            }
        }
        if (!this.allowCustom) {
            if (hasFocused) {
                this.selectionService.change(focused);
            }
            else if (textHasChanged) {
                this.change(text, true);
            }
        }
    }
    /**
     * @hidden
     */
    handleBlur() {
        this._filtering = false;
        const currentText = this.searchbar.value; // The value is updated, but the Angular `change` event is not emitted yet and `this.text` is not updated. Fails on suggested text.
        if (!currentText && !isPresent(this._previousDataItem) && !isPresent(this.dataItem)) {
            this.togglePopup(false);
            this.isFocused = false;
            this.onBlur.emit();
            this.onTouchedCallback();
            return;
        }
        const focused = this.selectionService.focused;
        let itemText;
        const isItemFocused = focused !== -1 && focused !== undefined;
        if (isItemFocused) {
            itemText = getter(this.dataService.itemAt(focused), this.textField);
            itemText = !isPresent(itemText) ? "" : itemText.toString().toLowerCase();
        }
        if (itemText === currentText.toLowerCase()) {
            this.selectionService.change(focused);
        }
        else {
            this.change(currentText, true);
        }
        this.togglePopup(false);
        this.isFocused = false;
        this.onBlur.emit();
        this.onTouchedCallback();
    }
    /**
     * @hidden
     */
    handleEscape() {
        this.togglePopup(false);
        // clear the focus only if the focused item is not selected
        const hasSelected = this.selectionService.selected.length > 0;
        if (!hasSelected) {
            this.suggestedText = null;
            this.selectionService.focused = -1;
        }
    }
    /**
     * @hidden
     */
    handleNavigationOpen() {
        this.restoreItemFocus();
        this.togglePopup(true);
    }
    /**
     * @hidden
     */
    searchBarChange(text) {
        const currentTextLength = this.text ? this.text.length : 0;
        this.backspacePressed = (text.length < currentTextLength) ? true : false;
        this.text = text;
        // Reset the selection prior to filter. If a match is present, it will be resolved. If a match is not present, it is not needed.
        this.selectionService.resetSelection([]);
        this.togglePopup(true);
        this._filtering = true;
        if (this.filterable && this.filterText !== text) {
            this.filterText = text;
            this.filterChange.emit(text);
        }
        else {
            this.search(text);
        }
    }
    /**
     * @hidden
     */
    handleFocus() {
        this.isFocused = true;
        this.onFocus.emit();
    }
    /**
     * @hidden
     */
    pageChange(event) {
        const virtual = this.virtual;
        virtual.skip = event.skip;
    }
    change(candidate, isCustom = false) {
        if (isCustom) {
            this.customValueSubject.next(candidate);
        }
        else {
            this.valueSubject.next(candidate);
        }
    }
    emitSelectionChange(dataItem) {
        this.selectionSubject.next(dataItem);
    }
    emitValueChange() {
        this.onChangeCallback(this.value);
        this.valueChange.emit(this.value);
        this._previousDataItem = this.dataItem;
    }
    /**
     * @hidden
     */
    selectClick() {
        if (!this.touchEnabled) {
            this.searchbar.focus();
        }
        if (!this.isOpen) {
            this.restoreItemFocus();
        }
        this.togglePopup(!this.isOpen);
    }
    get listContainerClasses() {
        const containerClasses = ['k-list-container', 'k-reset'];
        if (this.popupSettings.popupClass) {
            containerClasses.push(this.popupSettings.popupClass);
        }
        return containerClasses;
    }
    /**
     * Focuses the first match when there's text in the input field, but no focused item.
     */
    restoreItemFocus() {
        const hasFocus = isPresent(this.selectionService.focused) && this.selectionService.focused > -1;
        if (!hasFocus && this.text && this.dataService.itemsCount) {
            if (this.filterable) {
                this.selectionService.focused = this.firstFocusableIndex(0);
            }
            else {
                this.search(this.text);
            }
        }
    }
    useSuggestion() {
        if (!(this.suggest && isPresent(this.searchbar.value))) {
            return false;
        }
        const focusedDataItem = this.dataService.itemAt(this.selectionService.focused);
        const focusedItemText = this.prop(this.textField, this.valuePrimitive)(focusedDataItem);
        if (!isPresent(focusedItemText)) {
            return false;
        }
        return this.searchbar.value.toLowerCase() === focusedItemText.toLowerCase();
    }
    destroyPopup() {
        if (this.popupRef) {
            this.popupRef.popupElement
                .removeEventListener('mousedown', this.popupMouseDownHandler);
            this.popupRef.close();
            this.popupRef = null;
        }
    }
    createPopup() {
        if (this.virtual) {
            this.virtual.skip = 0;
        }
        const horizontalAlign = this.direction === "rtl" ? "right" : "left";
        const anchorPosition = { horizontal: horizontalAlign, vertical: "bottom" };
        const popupPosition = { horizontal: horizontalAlign, vertical: "top" };
        this.popupRef = this.popupService.open({
            anchor: this.wrapper,
            animate: this.popupSettings.animate,
            appendTo: this.appendTo,
            content: this.popupTemplate,
            popupClass: this.listContainerClasses,
            positionMode: 'absolute',
            anchorAlign: anchorPosition,
            popupAlign: popupPosition
        });
        const popupWrapper = this.popupRef.popupElement;
        const { min, max } = this.width;
        popupWrapper.addEventListener('mousedown', this.popupMouseDownHandler);
        popupWrapper.style.minWidth = min;
        popupWrapper.style.width = max;
        popupWrapper.style.height = this.height;
        popupWrapper.setAttribute("dir", this.direction);
        this.popupRef.popupOpen.subscribe(() => {
            this.cdr.detectChanges();
            this.optionsList.scrollToItem(this.selectionService.focused);
        });
        this.popupRef.popupAnchorViewportLeave.subscribe(() => this.togglePopup(false));
    }
    _toggle(open) {
        this._open = (open === undefined) ? !this._open : open;
        this.destroyPopup();
        if (this._open) {
            this.createPopup();
        }
    }
    triggerPopupEvents(open) {
        const eventArgs = new PreventableEvent();
        if (open) {
            this.open.emit(eventArgs);
        }
        else {
            this.close.emit(eventArgs);
        }
        return eventArgs.isDefaultPrevented();
    }
    clearFilter() {
        if (!(this.filterable && this.filterText)) {
            return;
        }
        this.filterText = '';
        this.filterChange.emit(this.filterText);
    }
    setMessages() {
        this._zone.runOutsideAngular(() => {
            clearTimeout(this.messagesTimeout);
            this.messagesTimeout = setTimeout(() => {
                this.noDataText = this.localization.get('noDataText');
                this.cdr.detectChanges();
            });
        });
    }
    createSelectionStream() {
        if (isPresent(this.selectionSubscription)) {
            this.selectionSubscription.unsubscribe();
        }
        this.selectionSubscription = this.selectionSubject
            .pipe(distinctUntilChanged())
            .subscribe(dataItem => this.selectionChange.emit(dataItem));
    }
}
ComboBoxComponent.ɵfac = function ComboBoxComponent_Factory(t) { return new (t || ComboBoxComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.PopupService), ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(DisabledItemsService), ɵngcc0.ɵɵdirectiveInject(DataService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(TOUCH_ENABLED, 8)); };
ComboBoxComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ComboBoxComponent, selectors: [["kendo-combobox"]], contentQueries: function ComboBoxComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ItemTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, GroupTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, FixedGroupTemplateDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.fixedGroupTemplate = _t.first);
    } }, viewQuery: function ComboBoxComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c9, true, ViewContainerRef);
        ɵngcc0.ɵɵviewQuery(_c10, true);
        ɵngcc0.ɵɵviewQuery(SearchBarComponent, true);
        ɵngcc0.ɵɵviewQuery(_c11, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.searchbar = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.optionsList = _t.first);
    } }, hostVars: 9, hostBindings: function ComboBoxComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.dir);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.widgetClasses)("k-combobox", ctx.widgetClasses)("k-header", ctx.widgetClasses)("k-combobox-clearable", ctx.clearable);
    } }, inputs: { focusableId: "focusableId", allowCustom: "allowCustom", valueNormalizer: "valueNormalizer", placeholder: "placeholder", listHeight: "listHeight", suggest: "suggest", clearButton: "clearButton", disabled: "disabled", readonly: "readonly", tabindex: "tabindex", filterable: "filterable", data: "data", value: "value", popupSettings: "popupSettings", itemDisabled: "itemDisabled", tabIndex: "tabIndex", virtual: "virtual", loading: "loading", valuePrimitive: "valuePrimitive", textField: "textField", valueField: "valueField", iconClass: "iconClass" }, outputs: { valueChange: "valueChange", selectionChange: "selectionChange", filterChange: "filterChange", open: "open", close: "close", onFocus: "focus", onBlur: "blur" }, exportAs: ["kendoComboBox"], features: [ɵngcc0.ɵɵProvidersFeature([
            COMBOBOX_VALUE_ACCESSOR,
            DataService,
            SelectionService,
            NavigationService,
            DisabledItemsService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.combobox'
            },
            {
                provide: FilterableDropDownComponentBase, useExisting: forwardRef(() => ComboBoxComponent)
            },
            {
                provide: KendoInput, useExisting: forwardRef(() => ComboBoxComponent)
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature()], decls: 14, vars: 20, consts: [["kendoComboBoxLocalizedMessages", "", 6, "noDataText", "clearTitle"], ["unselectable", "on", 1, "k-dropdown-wrap", 3, "ngClass"], ["wrapper", ""], [3, "role", "id", "listId", "activeDescendant", "noDataLabel", "userInput", "suggestedText", "disabled", "readonly", "tabIndex", "popupOpen", "placeholder", "onNavigate", "valueChange", "onBlur", "onFocus"], ["searchbar", ""], ["class", "k-icon k-clear-value k-i-close", "role", "button", "tabindex", "-1", 3, "click", "mousedown", 4, "ngIf"], ["unselectable", "on", 1, "k-select", 3, "click", "mousedown"], [1, "k-icon", 3, "ngClass"], ["popupTemplate", ""], [3, "ngIf"], ["container", ""], ["role", "button", "tabindex", "-1", 1, "k-icon", "k-clear-value", "k-i-close", 3, "click", "mousedown"], [4, "ngIf"], [3, "id", "optionPrefix", "data", "textField", "valueField", "template", "groupTemplate", "fixedGroupTemplate", "height", "show", "virtual", "pageChange"], ["optionsList", ""], ["class", "k-nodata", 4, "ngIf"], [3, "templateContext"], [1, "k-nodata"], [3, "ngIf", "templateContext"], [3, "resize"]], template: function ComboBoxComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵi18nAttributes(1, _c22);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(2, "span", 1, 2);
        ɵngcc0.ɵɵelementStart(4, "kendo-searchbar", 3, 4);
        ɵngcc0.ɵɵlistener("onNavigate", function ComboBoxComponent_Template_kendo_searchbar_onNavigate_4_listener($event) { return ctx.handleNavigate($event); })("valueChange", function ComboBoxComponent_Template_kendo_searchbar_valueChange_4_listener($event) { return ctx.searchBarChange($event); })("onBlur", function ComboBoxComponent_Template_kendo_searchbar_onBlur_4_listener() { return ctx.handleBlur(); })("onFocus", function ComboBoxComponent_Template_kendo_searchbar_onFocus_4_listener() { return ctx.handleFocus(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(6, ComboBoxComponent_span_6_Template, 1, 1, "span", 5);
        ɵngcc0.ɵɵelementStart(7, "span", 6);
        ɵngcc0.ɵɵlistener("click", function ComboBoxComponent_Template_span_click_7_listener() { return ctx.selectClick(); })("mousedown", function ComboBoxComponent_Template_span_mousedown_7_listener($event) { return $event.preventDefault(); });
        ɵngcc0.ɵɵelement(8, "span", 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(9, ComboBoxComponent_ng_template_9_Template, 5, 14, "ng-template", null, 8, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(11, ComboBoxComponent_ng_template_11_Template, 1, 0, "ng-template", 9);
        ɵngcc0.ɵɵelementContainer(12, null, 10);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction3(16, _c23, !ctx.disabled, ctx.disabled, ctx.isFocused));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("role", "combobox")("id", ctx.focusableId)("listId", ctx.listBoxId)("activeDescendant", ctx.activeDescendant)("noDataLabel", ctx.noDataLabel)("userInput", ctx.text)("suggestedText", ctx.getSuggestion())("disabled", ctx.disabled)("readonly", ctx.readonly)("tabIndex", ctx.tabIndex)("popupOpen", ctx.isOpen)("placeholder", ctx.placeholder);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.loading && !ctx.readonly && (ctx.clearButton && (ctx.text == null ? null : ctx.text.length)));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngClass", ctx.buttonClasses);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isOpen);
    } }, directives: function () { return [LocalizedMessagesDirective, ɵngcc2.NgClass, SearchBarComponent, ɵngcc2.NgIf, ListComponent,
        TemplateContextDirective, ɵngcc4.ResizeSensorComponent]; }, encapsulation: 2 });
/** @nocollapse */
ComboBoxComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: PopupService },
    { type: SelectionService },
    { type: NavigationService },
    { type: DisabledItemsService },
    { type: DataService },
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: ElementRef },
    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [TOUCH_ENABLED,] }] }
];
ComboBoxComponent.propDecorators = {
    focusableId: [{ type: Input }],
    allowCustom: [{ type: Input }],
    data: [{ type: Input }],
    value: [{ type: Input }],
    textField: [{ type: Input }],
    valueField: [{ type: Input }],
    valuePrimitive: [{ type: Input }],
    valueNormalizer: [{ type: Input }],
    placeholder: [{ type: Input }],
    popupSettings: [{ type: Input }],
    listHeight: [{ type: Input }],
    iconClass: [{ type: Input }],
    loading: [{ type: Input }],
    suggest: [{ type: Input }],
    clearButton: [{ type: Input }],
    disabled: [{ type: Input }],
    itemDisabled: [{ type: Input }],
    readonly: [{ type: Input }],
    tabindex: [{ type: Input }],
    tabIndex: [{ type: Input, args: ["tabIndex",] }],
    filterable: [{ type: Input }],
    virtual: [{ type: Input }],
    valueChange: [{ type: Output }],
    selectionChange: [{ type: Output }],
    filterChange: [{ type: Output }],
    open: [{ type: Output }],
    close: [{ type: Output }],
    onFocus: [{ type: Output, args: ['focus',] }],
    onBlur: [{ type: Output, args: ['blur',] }],
    template: [{ type: ContentChild, args: [ItemTemplateDirective,] }],
    headerTemplate: [{ type: ContentChild, args: [HeaderTemplateDirective,] }],
    footerTemplate: [{ type: ContentChild, args: [FooterTemplateDirective,] }],
    noDataTemplate: [{ type: ContentChild, args: [NoDataTemplateDirective,] }],
    groupTemplate: [{ type: ContentChild, args: [GroupTemplateDirective,] }],
    fixedGroupTemplate: [{ type: ContentChild, args: [FixedGroupTemplateDirective,] }],
    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] }],
    popupTemplate: [{ type: ViewChild, args: ['popupTemplate',] }],
    searchbar: [{ type: ViewChild, args: [SearchBarComponent,] }],
    optionsList: [{ type: ViewChild, args: ['optionsList',] }],
    widgetClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-combobox',] }, { type: HostBinding, args: ['class.k-header',] }],
    clearable: [{ type: HostBinding, args: ['class.k-combobox-clearable',] }],
    dir: [{ type: HostBinding, args: ['attr.dir',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ComboBoxComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoComboBox',
                providers: [
                    COMBOBOX_VALUE_ACCESSOR,
                    DataService,
                    SelectionService,
                    NavigationService,
                    DisabledItemsService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.combobox'
                    },
                    {
                        provide: FilterableDropDownComponentBase, useExisting: forwardRef(() => ComboBoxComponent)
                    },
                    {
                        provide: KendoInput, useExisting: forwardRef(() => ComboBoxComponent)
                    }
                ],
                selector: 'kendo-combobox',
                template: `
        <ng-container kendoComboBoxLocalizedMessages
            i18n-noDataText="kendo.combobox.noDataText|The text displayed in the popup when there are no items"
            noDataText="NO DATA FOUND"

            i18n-clearTitle="kendo.combobox.clearTitle|The title of the clear button"
            clearTitle="clear"
        >
        </ng-container>
        <span #wrapper unselectable="on"
            class="k-dropdown-wrap"
            [ngClass]="{ 'k-state-default': !disabled, 'k-state-disabled': disabled, 'k-state-focused': isFocused }"
        >
          <kendo-searchbar #searchbar
              [role]="'combobox'"
              [id]="focusableId"
              [listId]="listBoxId"
              [activeDescendant]="activeDescendant"
              [noDataLabel]="noDataLabel"
              [userInput]="text"
              [suggestedText]="getSuggestion()"
              [disabled]="disabled"
              [readonly]="readonly"
              [tabIndex]="tabIndex"
              [popupOpen]="isOpen"
              [placeholder]="placeholder"
              (onNavigate)="handleNavigate($event)"
              (valueChange)="searchBarChange($event)"
              (onBlur)="handleBlur()"
              (onFocus)="handleFocus()"
          ></kendo-searchbar>
          <span *ngIf="!loading && !readonly && (clearButton && text?.length)" class="k-icon k-clear-value k-i-close" [attr.title]="clearTitle" role="button" tabindex="-1" (click)="clearValue($event)" (mousedown)="$event.preventDefault()"></span>
          <span unselectable="on"
              class="k-select"
              (click)="selectClick()"
              (mousedown)="$event.preventDefault()" >
              <span class="k-icon" [ngClass]="buttonClasses">
               </span>
          </span>
          <ng-template #popupTemplate>
              <!--header template-->
              <ng-template *ngIf="headerTemplate"
                  [templateContext]="{
                      templateRef: headerTemplate.templateRef
                  }">
              </ng-template>
              <!--list-->
              <kendo-list
                  #optionsList
                  [id]="listBoxId"
                  [optionPrefix]="optionPrefix"
                  [data]="data"
                  [textField]="textField"
                  [valueField]="valueField"
                  [template]="template"
                  [groupTemplate]="groupTemplate"
                  [fixedGroupTemplate]="fixedGroupTemplate"
                  [height]="listHeight"
                  [show]="isOpen"
                  [virtual]="virtual"
                  (pageChange)="pageChange($event)"
              >
              </kendo-list>
              <!--no-data template-->
              <div class="k-nodata" *ngIf="data.length === 0">
                  <ng-template [ngIf]="noDataTemplate"
                      [templateContext]="{
                          templateRef: noDataTemplate ? noDataTemplate.templateRef : undefined
                      }">
                  </ng-template>
                  <ng-template [ngIf]="!noDataTemplate">
                      <div>{{ noDataText }}</div>
                  </ng-template>
              </div>
              <!--footer template-->
              <ng-template *ngIf="footerTemplate"
                  [templateContext]="{
                      templateRef: footerTemplate.templateRef
                  }">
              </ng-template>
          </ng-template>
        </span>
        <ng-template [ngIf]="isOpen">
            <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>
        </ng-template>
        <ng-container #container></ng-container>
  `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ɵngcc3.PopupService }, { type: SelectionService }, { type: NavigationService }, { type: DisabledItemsService }, { type: DataService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [TOUCH_ENABLED]
            }] }]; }, { focusableId: [{
            type: Input
        }], allowCustom: [{
            type: Input
        }], valueNormalizer: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], listHeight: [{
            type: Input
        }], suggest: [{
            type: Input
        }], clearButton: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], filterable: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], selectionChange: [{
            type: Output
        }], filterChange: [{
            type: Output
        }], open: [{
            type: Output
        }], close: [{
            type: Output
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], widgetClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-combobox']
        }, {
            type: HostBinding,
            args: ['class.k-header']
        }], data: [{
            type: Input
        }], value: [{
            type: Input
        }], popupSettings: [{
            type: Input
        }], itemDisabled: [{
            type: Input
        }], tabIndex: [{
            type: Input,
            args: ["tabIndex"]
        }], virtual: [{
            type: Input
        }], clearable: [{
            type: HostBinding,
            args: ['class.k-combobox-clearable']
        }], dir: [{
            type: HostBinding,
            args: ['attr.dir']
        }], loading: [{
            type: Input
        }], valuePrimitive: [{
            type: Input
        }], textField: [{
            type: Input
        }], valueField: [{
            type: Input
        }], iconClass: [{
            type: Input
        }], template: [{
            type: ContentChild,
            args: [ItemTemplateDirective]
        }], headerTemplate: [{
            type: ContentChild,
            args: [HeaderTemplateDirective]
        }], footerTemplate: [{
            type: ContentChild,
            args: [FooterTemplateDirective]
        }], noDataTemplate: [{
            type: ContentChild,
            args: [NoDataTemplateDirective]
        }], groupTemplate: [{
            type: ContentChild,
            args: [GroupTemplateDirective]
        }], fixedGroupTemplate: [{
            type: ContentChild,
            args: [FixedGroupTemplateDirective]
        }], container: [{
            type: ViewChild,
            args: ['container', { read: ViewContainerRef }]
        }], popupTemplate: [{
            type: ViewChild,
            args: ['popupTemplate']
        }], searchbar: [{
            type: ViewChild,
            args: [SearchBarComponent]
        }], optionsList: [{
            type: ViewChild,
            args: ['optionsList']
        }] }); })();

/* tslint:disable:max-line-length */
/**
 * Renders the selected value of the DropDownList
 * ([see example]({% slug templates_ddl %}#toc-value-template)).
 * The template context is set to the current component.
 * To get a reference to the current data item, use the `let-dataItem` directive.
 *
 * > The `ValueTemplate` directive can only be used with the DropDownList component.
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-dropdownlist [data]="listItems">
 *    <ng-template kendoDropDownListValueTemplate let-dataItem>
 *      <span>{{dataItem}} option</span>
 *    </ng-template>
 *  </kendo-dropdownlist>
 * `
 * })
 * class AppComponent {
 *   public listItems: Array<string> = ["Item 1", "Item 2", "Item 3", "Item 4"];
 * }
 * ```
 */
class ValueTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
ValueTemplateDirective.ɵfac = function ValueTemplateDirective_Factory(t) { return new (t || ValueTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
ValueTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ValueTemplateDirective, selectors: [["", "kendoDropDownListValueTemplate", ""]] });
/** @nocollapse */
ValueTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ValueTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDropDownListValueTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();

/* tslint:disable:max-line-length */
/**
 * @hidden
 */
const DROPDOWNLIST_VALUE_ACCESSOR = {
    multi: true,
    provide: NG_VALUE_ACCESSOR,
    // tslint:disable-next-line:no-use-before-declare
    useExisting: forwardRef(() => DropDownListComponent)
};
/**
 * Represents the [Kendo UI DropDownList component for Angular]({% slug overview_ddl %}).
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-dropdownlist [data]="listItems">
 *  </kendo-dropdownlist>
 * `
 * })
 * class AppComponent {
 *   public listItems: Array<string> = ["Item 1", "Item 2", "Item 3", "Item 4"];
 * }
 * ```
 */
class DropDownListComponent {
    constructor(localization, popupService, selectionService, navigationService, disabledItemsService, dataService, _zone, renderer, hostElement, cdr, touchEnabled) {
        this.localization = localization;
        this.popupService = popupService;
        this.selectionService = selectionService;
        this.navigationService = navigationService;
        this.disabledItemsService = disabledItemsService;
        this.dataService = dataService;
        this._zone = _zone;
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.cdr = cdr;
        this.touchEnabled = touchEnabled;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Sets the height of the options list. By default, `listHeight` is 200px.
         *
         * > The `listHeight` property affects only the list of options and not the whole popup container.
         * > To set the height of the popup container, use `popupSettings.height`.
         */
        this.listHeight = 200;
        /**
         * Sets the disabled state of the component.
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the component.
         */
        this.readonly = false;
        /**
         * Enables the [filtering]({% slug filtering_ddl %}) functionality of the DropDownList.
         */
        this.filterable = false;
        /**
         * Enables a case-insensitive search. When filtration is disabled, use this option.
         */
        this.ignoreCase = true;
        /**
         * Sets the delay before an item search is performed. When filtration is disabled, use this option.
         */
        this.delay = 500;
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Fires each time the value is changed ([see example]({% slug overview_ddl %}#toc-events)).
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the user types in the input field
         * ([see example]({% slug overview_ddl %}#toc-events)).
         * You can filter the source based on the passed filtration value.
         * When the value of the component is programmatically changed to `ngModel` or `formControl`
         * through its API or form binding, the `valueChange` event is not triggered because it
         * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
         */
        this.filterChange = new EventEmitter();
        /**
         * Fires each time the item selection is changed
         * ([see example]({% slug overview_ddl %}#toc-events)).
         */
        this.selectionChange = new EventEmitter();
        /**
         * Fires each time the popup is about to open
         * ([see example]({% slug openstate_ddl %}#toc-preventing-opening-and-closing)).
         * This event is preventable. If you cancel it, the popup will remain closed.
         */
        this.open = new EventEmitter();
        /**
         * Fires each time the popup is about to close
         * ([see example]({% slug openstate_ddl %}#toc-preventing-opening-and-closing)).
         * This event is preventable. If you cancel it, the popup will remain open.
         */
        this.close = new EventEmitter();
        /**
         * Fires each time the user focuses the DropDownList.
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the DropDownList gets blurred.
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        this.widgetClasses = true;
        this.groupIndices = [];
        this.listBoxId = guid();
        this.optionPrefix = guid();
        this.valueLabelId = guid();
        this.filterText = "";
        this.isFocused = false;
        this.onTouchedCallback = (_) => { };
        this.onChangeCallback = (_) => { };
        this.word = "";
        this.last = "";
        this.filterFocused = new EventEmitter();
        this.filterBlurred = new EventEmitter();
        this.wrapperFocused = new EventEmitter();
        this.wrapperBlurred = new EventEmitter();
        this.selectionSubscription = new Subscription();
        this._open = false;
        this._popupSettings = { animate: true };
        this.direction = localization.rtl ? 'rtl' : 'ltr';
        this.data = [];
        this.subscribeEvents();
        this.hostElement = hostElement.nativeElement;
        this.popupMouseDownHandler = this.onMouseDown.bind(this);
    }
    get width() {
        const wrapperWidth = isDocumentAvailable() ? this.wrapper.nativeElement.offsetWidth : 0;
        const width = this.popupSettings.width || wrapperWidth;
        const minWidth = isNaN(wrapperWidth) ? wrapperWidth : `${wrapperWidth}px`;
        const maxWidth = isNaN(width) ? width : `${width}px`;
        return { min: minWidth, max: maxWidth };
    }
    get height() {
        const popupHeight = this.popupSettings.height;
        return isPresent(popupHeight) ? `${popupHeight}px` : 'auto';
    }
    get widgetTabIndex() {
        if (this.disabled) {
            return undefined;
        }
        const providedTabIndex = Number(this.tabIndex);
        const defaultTabIndex = 0;
        return !isNaN(providedTabIndex) ? providedTabIndex : defaultTabIndex;
    }
    get ariaExpanded() {
        return this.isOpen;
    }
    get ariaOwns() {
        if (!this.isOpen) {
            return;
        }
        return this.listBoxId;
    }
    get ariaActivedescendant() {
        if (!isPresent(this.dataItem)) {
            return;
        }
        return this.optionPrefix + "-" + getter(this.dataItem, this.valueField);
    }
    get noDataLabel() {
        if (this.dataService.itemsCount === 0) {
            return this.noDataText;
        }
    }
    get appendTo() {
        const { appendTo } = this.popupSettings;
        if (!appendTo || appendTo === 'root') {
            return undefined;
        }
        return appendTo === 'component' ? this.container : appendTo;
    }
    /**
     * Sets the data of the DropDownList.
     *
     * > The data has to be provided in an array-like list.
     */
    set data(data) {
        this.dataService.data = data || [];
        if (this.virtual) {
            this.virtual.skip = 0;
        }
        this.setState();
    }
    get data() {
        const virtual = this.virtual;
        if (virtual) {
            const start = virtual.skip || 0;
            const end = start + virtual.pageSize;
            // Use length instead of itemsCount because of the grouping.
            virtual.total = this.dataService.data.length;
            return this.dataService.data.slice(start, end);
        }
        return this.dataService.data;
    }
    /**
     * Sets the value of the DropDownList.
     * It can either be of the primitive (string, numbers) or of the complex (objects) type.
     * To define the type, use the `valuePrimitive` option.
     *
     * > All selected values which are not present in the source are ignored.
     */
    set value(newValue) {
        this._value = newValue;
        this.cdr.markForCheck();
    }
    get value() {
        return this._value;
    }
    /**
     * Configures the popup of the DropDownList.
     *
     * The available options are:
     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
     * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.
     * - `height: Number`&mdash;Sets the height of the popup container.
     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
     * - `appendTo: "root" | "component" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.
     */
    set popupSettings(settings) {
        this._popupSettings = Object.assign({ animate: true }, settings);
    }
    get popupSettings() {
        return this._popupSettings;
    }
    /**
     * Defines a Boolean function that is executed for each data item in the component
     * ([see examples]({% slug disableditems_ddl %})). Determines whether the item will be disabled.
     */
    set itemDisabled(fn) {
        if (typeof fn !== 'function') {
            throw new Error(`itemDisabled must be a function, but received ${JSON.stringify(fn)}.`);
        }
        this.disabledItemsService.itemDisabled = fn;
    }
    /**
     * Enables the [virtualization]({% slug virtualization_ddl %}) functionality.
     */
    set virtual(settings) {
        this._virtualSettings = normalizeVirtualizationSettings(settings);
    }
    get virtual() {
        return this._virtualSettings;
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    /**
     * @hidden
     */
    blurComponent() {
        this.wrapperBlurred.emit();
    }
    /**
     * @hidden
     */
    blurFilterInput() {
        this.filterBlurred.emit();
    }
    /**
     * @hidden
     */
    focusComponent() {
        this.wrapperFocused.emit();
        if (!this.isFocused) {
            this.isFocused = true;
            this.onFocus.emit();
        }
    }
    /**
     * @hidden
     */
    keydown(event) {
        const firstIndex = isPresent(this.defaultItem) ? -1 : 0;
        let focused = isNaN(this.selectionService.focused) ? this.firstFocusableIndex(firstIndex) : this.selectionService.focused;
        let offset = 0;
        if (this.disabled || this.readonly) {
            return;
        }
        const isHomeEnd = event.keyCode === Keys.home || event.keyCode === Keys.end;
        const isFilterFocused = this.filterable && this.isFocused && this.isOpen;
        if (isFilterFocused && isHomeEnd) {
            return;
        }
        const hasSelected = isPresent(this.selectionService.selected[0]);
        const focusedItemNotSelected = isPresent(this.selectionService.focused) && !this.selectionService.isSelected(this.selectionService.focused);
        if (!hasSelected || focusedItemNotSelected) {
            if (event.keyCode === Keys.down || event.keyCode === Keys.right) {
                offset = -1;
            }
            else if (event.keyCode === Keys.up || event.keyCode === Keys.left) {
                offset = 1;
            }
        }
        const eventData = event;
        const action = this.navigationService.process({
            current: focused + offset,
            max: this.dataService.itemsCount - 1,
            min: this.defaultItem ? -1 : 0,
            originalEvent: eventData
        });
        const leftRightKeys = (action === NavigationAction.Left) || (action === NavigationAction.Right);
        if (action !== NavigationAction.Undefined &&
            action !== NavigationAction.Tab &&
            action !== NavigationAction.Backspace &&
            action !== NavigationAction.Delete &&
            !(leftRightKeys && this.filterable) &&
            action !== NavigationAction.Enter //enter when popup is opened is handled before `handleEnter`
        ) {
            eventData.preventDefault();
        }
    }
    /**
     * @hidden
     */
    keypress(event) {
        if (this.disabled || this.readonly || this.filterable) {
            return;
        }
        this.onKeyPress(event);
    }
    /**
     * @hidden
     */
    click() {
        this.focus();
        this.togglePopup(!this.isOpen);
    }
    /**
     * @hidden
     */
    onResize() {
        if (this._open) {
            const popupWrapper = this.popupRef.popupElement;
            const { min, max } = this.width;
            popupWrapper.style.minWidth = min;
            popupWrapper.style.width = max;
        }
    }
    get dir() {
        return this.direction;
    }
    ngOnInit() {
        this.renderer.removeAttribute(this.hostElement, "tabindex");
        this.localizationChangesSubscription = this.localization
            .changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
            this.setMessages();
        });
        this.setMessages();
    }
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty.
     */
    isEmpty() {
        const value = this.value;
        return !(value === 0 || value === false || value || this.defaultItem);
    }
    /**
     * @hidden
     */
    onFilterFocus() {
        this.filterFocused.emit();
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.destroyPopup();
        this.unsubscribeEvents();
        clearTimeout(this.messagesTimeout);
        if (this.localizationChangesSubscription) {
            this.localizationChangesSubscription.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    ngOnChanges(_changes) {
        const virtual = this.virtual;
        const requestInitialData = virtual && _changes.data && _changes.data.isFirstChange();
        if (requestInitialData) {
            this.pageChange({ skip: 0, take: virtual.pageSize });
        }
        if (this.valuePrimitive === undefined) {
            this.valuePrimitive = this.valueField ? false : true;
        }
        if (_changes.hasOwnProperty("value")) {
            this.verifySettings(_changes.value.currentValue);
            if (!isPresent(this.value)) {
                this._previousDataItem = undefined;
            }
        }
        if (_changes.hasOwnProperty("defaultItem")) {
            this.disabledItemsService.defaultItem = this.defaultItem;
        }
        const STATE_PROPS = /(value|textField|valueField|valuePrimitive|defaultItem|itemDisabled)/g;
        if (STATE_PROPS.test(Object.keys(_changes).join())) {
            this.setState();
        }
    }
    /**
     * Focuses the DropDownList.
     */
    focus() {
        if (!this.disabled) {
            this.wrapper.nativeElement.focus();
        }
    }
    /**
     * Blurs the DropDownList.
     */
    blur() {
        if (!this.disabled) {
            this.wrapper.nativeElement.blur();
        }
    }
    /**
     * Toggles the visibility of the popup
     * ([see example]({% slug openstate_ddl %}#toc-setting-the-initially-opened-component)).
     * If you use the `toggle` method to open or close the popup, the `open` and `close` events will not be fired.
     *
     * @param open - The state of the popup.
     */
    toggle(open) {
        // The Promise is required to open the popup on load.
        // Otherwise, the "Expression has changed..." type error will be thrown.
        Promise.resolve(null).then(() => {
            this._toggle(open);
        });
    }
    _toggle(open) {
        this._open = (open === undefined) ? !this._open : open;
        this.destroyPopup();
        if (this._open) {
            this.createPopup();
        }
    }
    triggerPopupEvents(open) {
        const eventArgs = new PreventableEvent();
        if (open) {
            this.open.emit(eventArgs);
        }
        else {
            this.close.emit(eventArgs);
        }
        return eventArgs.isDefaultPrevented();
    }
    /**
     * @hidden
     */
    togglePopup(open) {
        const isDisabled = this.disabled || this.readonly;
        const sameState = this.isOpen === open;
        if (isDisabled || sameState) {
            return;
        }
        const isDefaultPrevented = this.triggerPopupEvents(open);
        if (!isDefaultPrevented) {
            if (!open && this.filterable && this.isFocused) {
                this.focus();
            }
            this._toggle(open);
        }
    }
    /**
     * Returns the current open state of the popup.
     */
    get isOpen() {
        return this._open;
    }
    /**
     * Resets the value of the DropDownList.
     * If you use the `reset` method to clear the value of the component,
     * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.
     */
    reset() {
        this._previousDataItem = undefined;
        this.value = undefined;
        this.setState();
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.verifySettings(value);
        this.value = value === null ? undefined : value;
        if (!isPresent(value)) {
            this._previousDataItem = undefined;
        }
        this.setState();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    get buttonClasses() {
        return this.loading ? 'k-i-loading' : this.iconClass || 'k-i-arrow-s';
    }
    /**
     * @hidden
     */
    get listContainerClasses() {
        const containerClasses = ['k-list-container', 'k-reset'];
        if (this.popupSettings.popupClass) {
            containerClasses.push(this.popupSettings.popupClass);
        }
        return containerClasses;
    }
    /**
     * @hidden
     */
    get isDisabledDefaultItem() {
        return this.disabledItemsService.isItemDisabled(this.defaultItem);
    }
    /**
     * @hidden
     */
    getText() {
        return this.text;
    }
    /**
     * @hidden
     */
    getDefaultItemText() {
        return getter(this.defaultItem, this.textField);
    }
    createPopup() {
        if (this.virtual) {
            this.virtual.skip = 0;
        }
        const horizontalAlign = this.direction === "rtl" ? "right" : "left";
        const anchorPosition = { horizontal: horizontalAlign, vertical: "bottom" };
        const popupPosition = { horizontal: horizontalAlign, vertical: "top" };
        this.popupRef = this.popupService.open({
            anchor: this.wrapper,
            anchorAlign: anchorPosition,
            animate: this.popupSettings.animate,
            appendTo: this.appendTo,
            content: this.popupTemplate,
            popupAlign: popupPosition,
            popupClass: this.listContainerClasses,
            positionMode: 'absolute'
        });
        const popupWrapper = this.popupRef.popupElement;
        const { min, max } = this.width;
        popupWrapper.addEventListener('mousedown', this.popupMouseDownHandler);
        popupWrapper.style.minWidth = min;
        popupWrapper.style.width = max;
        popupWrapper.style.height = this.height;
        popupWrapper.setAttribute("dir", this.direction);
        this.popupRef.popupOpen.subscribe(() => {
            this.cdr.detectChanges();
            this.optionsList.scrollToItem(this.selectionService.focused);
        });
        if (!this.filterable) {
            this.popupRef.popupAnchorViewportLeave.subscribe(() => this.togglePopup(false));
        }
    }
    destroyPopup() {
        if (this.popupRef) {
            this.popupRef.popupElement
                .removeEventListener('mousedown', this.popupMouseDownHandler);
            this.popupRef.close();
            this.popupRef = null;
        }
    }
    updateState({ dataItem, confirm = false }) {
        this.dataItem = dataItem;
        this.text = this.prop(this.textField, this.valuePrimitive)(dataItem);
        if (confirm) {
            this._previousDataItem = dataItem;
        }
    }
    clearState() {
        this.text = undefined;
        this.dataItem = undefined;
    }
    resetSelection(index) {
        const clear = !isPresent(index);
        this.selectionService.resetSelection(clear ? [] : [index]);
        this.selectionService.focused = clear ? this.firstFocusableIndex(0) : index;
    }
    onSelectionChange({ dataItem }) {
        this.updateState({ dataItem });
        this.selectionChange.emit(dataItem);
        /* forces firefox/nvda, forefox/jaws, ie/jaws to read the new value when
         the popup is closed and the value is changed with the arrow keys (up/down) */
        this.valueLabelId = guid();
    }
    subscribeEvents() {
        if (!isDocumentAvailable()) {
            return;
        }
        // Item selection when the popup is open.
        this.selectionSubscription.add(this.selectionService.onSelect.pipe(filter(_ => this.isOpen), map(this.itemFromEvent.bind(this)))
            .subscribe(this.onSelectionChange.bind(this)));
        // Item selection when the popup is closed | clicked | enter, and so on.
        this.selectionSubscription.add(merge(this.selectionService.onSelect.pipe(filter(_ => !this.isOpen)), this.selectionService.onChange).pipe(map(this.itemFromEvent.bind(this)), tap(_ => this.togglePopup(false)))
            .subscribe(({ dataItem, value: newValue, newSelection }) => {
            if (newSelection) {
                this.onSelectionChange({ dataItem });
            }
            const shouldUsePrevious = !isPresent(dataItem) && this._previousDataItem;
            const shouldUseNewValue = newValue !== this.prop(this.valueField, this.valuePrimitive)(this.value);
            if (shouldUsePrevious) {
                this.updateState({ dataItem: this._previousDataItem });
                this.resetSelection();
            }
            else if (shouldUseNewValue) {
                this.value = this.valuePrimitive ? newValue : dataItem;
                this._previousDataItem = dataItem;
                this.emitChange(this.value);
            }
            this.clearFilter();
        }));
        this.navigationSubscription = merge(this.navigationService.up, this.navigationService.down, this.navigationService.left.pipe(skipWhile(() => this.filterable)), this.navigationService.right.pipe(skipWhile(() => this.filterable)), this.navigationService.home, this.navigationService.end)
            .pipe(filter((event) => !isNaN(event.index)))
            .subscribe((event) => this.selectionService.select(event.index));
        this.openSubscription = this.navigationService.open.subscribe(() => this.togglePopup(true));
        this.closeSubscription = this.navigationService.close.subscribe(() => {
            this.togglePopup(false);
            this.focus();
        });
        this.enterSubscription = this.navigationService.enter
            .pipe(tap((event) => event.originalEvent.preventDefault()))
            .subscribe(this.handleEnter.bind(this));
        this.escSubscription = this.navigationService.esc
            .subscribe(this.handleEscape.bind(this));
        this.filterBlurredSubscription = this.filterBlurred.pipe(concatMap(() => interval(10).pipe(take(1), takeUntil(this.wrapperFocused))))
            .subscribe(() => {
            this.wrapperBlurred.emit();
        });
        this._zone.runOutsideAngular(() => {
            this.componentBlurredSubscription =
                merge(this.wrapperBlurred.pipe(concatMap(() => interval(10).pipe(take(1), takeUntil(this.filterFocused)))), this.navigationService.tab).pipe(tap(event => event instanceof NavigationEvent && this.focus()), filter(() => this.isFocused))
                    .subscribe(() => this._zone.run(() => {
                    this.componentBlur();
                }));
        });
    }
    unsubscribeEvents() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.navigationSubscription.unsubscribe();
        this.openSubscription.unsubscribe();
        this.closeSubscription.unsubscribe();
        this.enterSubscription.unsubscribe();
        this.escSubscription.unsubscribe();
        this.componentBlurredSubscription.unsubscribe();
        this.filterBlurredSubscription.unsubscribe();
        if (this.selectionSubscription) {
            this.selectionSubscription.unsubscribe();
        }
    }
    itemFromEvent(event) {
        const index = event.indices[0];
        let dataItem = this.dataService.itemAt(index);
        dataItem = isPresent(dataItem) ? dataItem : this.currentOrDefault(index);
        const value = this.prop(this.valueField, this.valuePrimitive)(dataItem);
        const newSelection = event.newSelection;
        return {
            dataItem,
            index,
            newSelection,
            value
        };
    }
    currentOrDefault(selectedIndex) {
        const defaultItemIndex = -1;
        if (isPresent(this.dataItem) && selectedIndex !== defaultItemIndex) {
            return this.dataItem;
        }
        else {
            return this.defaultItem;
        }
    }
    firstFocusableIndex(index) {
        const maxIndex = this.dataService.itemsCount - 1;
        if (this.disabledItemsService.isIndexDisabled(index)) {
            return (index < maxIndex) ? this.firstFocusableIndex(index + 1) : undefined;
        }
        else {
            return index;
        }
    }
    handleEnter() {
        if (this.isOpen) {
            this.selectionService.change(this.selectionService.focused);
            this.focus();
        }
        else {
            this.togglePopup(true);
        }
    }
    handleEscape() {
        this.selectionService.change(this.selectionService.selected[0]);
        this.focus();
    }
    clearFilter() {
        if (!(this.filterable && this.filterText)) {
            return;
        }
        this.filterText = "";
        this.cdr.markForCheck();
        this.filterChange.emit(this.filterText);
    }
    verifySettings(newValue) {
        const valueOrText = !isPresent(this.valueField) !== !isPresent(this.textField);
        if (!isDevMode()) {
            return;
        }
        if (this.defaultItem && this.valueField && typeof this.defaultItem !== "object") {
            throw new Error(DropDownListMessages.defaultItem);
        }
        if (this.valuePrimitive === true && isPresent(newValue) && typeof newValue === "object") {
            throw new Error(DropDownListMessages.primitive);
        }
        if (this.valuePrimitive === false && isPresent(newValue) && typeof newValue !== "object") {
            throw new Error(DropDownListMessages.object);
        }
        if (valueOrText) {
            throw new Error(DropDownListMessages.textAndValue);
        }
    }
    componentBlur() {
        this.isFocused = false;
        this.selectionService.change(this.selectionService.selected[0]);
        this.onBlur.emit();
        this.onTouchedCallback();
    }
    /**
     * @hidden
     */
    onMouseDown(event) {
        const tagName = event.target.tagName.toLowerCase();
        if (tagName !== "input") {
            event.preventDefault();
        }
    }
    onKeyPress(event) {
        if (event.which === 0 || event.keyCode === Keys.enter) {
            return;
        }
        let character = String.fromCharCode(event.charCode || event.keyCode);
        if (this.ignoreCase) {
            character = character.toLowerCase();
        }
        if (character === " ") {
            event.preventDefault();
        }
        this.word += character;
        this.last = character;
        this.search();
    }
    search() {
        clearTimeout(this.typingTimeout);
        if (!this.filterable) {
            this.typingTimeout = setTimeout(() => { this.word = ""; }, this.delay);
            this.selectNext();
        }
    }
    selectNext() {
        let data = this.dataService
            .filter((item) => isPresent(item) && !item.header && !this.disabledItemsService.isItemDisabled(item))
            .map((item) => {
            if (this.dataService.grouped) {
                return { item: item.value, itemIndex: item.offsetIndex };
            }
            return { item: item, itemIndex: this.dataService.indexOf(item) };
        });
        const isInLoop = sameCharsOnly(this.word, this.last);
        let dataLength = data.length;
        let hasSelected = !isNaN(this.selectionService.selected[0]);
        let startIndex = !hasSelected ? 0 : this.selectionService.selected[0];
        let text, index, defaultItem;
        if (this.defaultItem && !this.disabledItemsService.isItemDisabled(this.defaultItem)) {
            defaultItem = { item: this.defaultItem, itemIndex: -1 };
            dataLength += 1;
            startIndex += 1;
        }
        startIndex += isInLoop && hasSelected ? 1 : 0;
        data = shuffleData(data, startIndex, defaultItem);
        index = 0;
        for (; index < dataLength; index++) {
            text = getter(data[index].item, this.textField);
            const loopMatch = Boolean(isInLoop && matchText(text, this.last, this.ignoreCase));
            const nextMatch = Boolean(matchText(text, this.word, this.ignoreCase));
            if (loopMatch || nextMatch) {
                index = data[index].itemIndex;
                break;
            }
        }
        if (index !== dataLength) {
            this.navigate(index);
        }
    }
    emitChange(value) {
        this.onChangeCallback(value);
        this.valueChange.emit(value);
    }
    navigate(index) {
        this.selectionService.select(index);
    }
    prop(field, usePrimitive) {
        return (dataItem) => {
            if (isPresent(dataItem)) {
                if (usePrimitive) {
                    return field && isObject(dataItem) ? dataItem[field] : dataItem;
                }
                else {
                    return dataItem[field];
                }
            }
            return null;
        };
    }
    findDataItem({ primitive, valueField, value }) {
        const result = {
            dataItem: null,
            index: -1
        };
        const prop = this.prop(valueField, primitive);
        let comparer;
        if (this.dataService.grouped) {
            comparer = (element) => {
                return prop(element.value) === prop(value);
            };
        }
        else {
            comparer = (element) => {
                return prop(element) === prop(value);
            };
        }
        const index = this.dataService.findIndex(comparer);
        result.dataItem = this.dataService.itemAt(index);
        result.index = index;
        return result;
    }
    setState() {
        const value = this.value;
        const valueField = this.valueField;
        const textField = this.textField;
        const primitive = this.valuePrimitive;
        if (this.defaultItem) {
            const defaultValue = this.prop(valueField, primitive)(this.defaultItem);
            const currentValue = this.prop(valueField, primitive)(value);
            if (!isPresent(value) || (currentValue === defaultValue)) {
                this.updateState({ dataItem: this.defaultItem, confirm: true });
                this.resetSelection(-1);
                if (this.filterable && this.filterText && this.dataService.itemsCount) {
                    this.selectionService.focused = this.firstFocusableIndex(0);
                }
                return;
            }
        }
        const resolved = this.findDataItem({ primitive, valueField, value });
        // The data and value are of same shape,
        // for example, value: 'foo', data: ['foo', 'bar']
        // or value: { value: 1, text: 'foo' }, data: [{ value: 1, text: 'foo' }].
        const ofSameType = !(primitive && textField);
        if (resolved.dataItem) {
            this.updateState({ dataItem: resolved.dataItem, confirm: true });
            this.resetSelection(resolved.index);
        }
        else if (isPresent(value) && ofSameType) {
            this.updateState({ dataItem: value });
            this.resetSelection();
        }
        else if (this._previousDataItem) {
            this.updateState({ dataItem: this._previousDataItem });
            this.resetSelection();
        }
        else {
            this.clearState();
            this.resetSelection();
        }
    }
    /**
     * @hidden
     */
    handleFilter(event) {
        this.filterChange.emit(event.target.value);
    }
    /**
     * @hidden
     */
    pageChange(event) {
        const virtual = this.virtual;
        virtual.skip = event.skip;
    }
    setMessages() {
        this._zone.runOutsideAngular(() => {
            clearTimeout(this.messagesTimeout);
            this.messagesTimeout = setTimeout(() => {
                this.noDataText = this.localization.get('noDataText');
                this.cdr.detectChanges();
            });
        });
    }
}
DropDownListComponent.ɵfac = function DropDownListComponent_Factory(t) { return new (t || DropDownListComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.PopupService), ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(DisabledItemsService), ɵngcc0.ɵɵdirectiveInject(DataService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(TOUCH_ENABLED, 8)); };
DropDownListComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DropDownListComponent, selectors: [["kendo-dropdownlist"]], contentQueries: function DropDownListComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ItemTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, GroupTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, FixedGroupTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ValueTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.fixedGroupTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.valueTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);
    } }, viewQuery: function DropDownListComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c9, true, ViewContainerRef);
        ɵngcc0.ɵɵviewQuery(_c10, true);
        ɵngcc0.ɵɵviewQuery(_c24, true);
        ɵngcc0.ɵɵviewQuery(_c11, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.wrapper = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.optionsList = _t.first);
    } }, hostVars: 7, hostBindings: function DropDownListComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.dir);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.widgetClasses)("k-dropdown", ctx.widgetClasses)("k-header", ctx.widgetClasses);
    } }, inputs: { focusableId: "focusableId", listHeight: "listHeight", disabled: "disabled", readonly: "readonly", filterable: "filterable", ignoreCase: "ignoreCase", delay: "delay", tabindex: "tabindex", data: "data", value: "value", popupSettings: "popupSettings", itemDisabled: "itemDisabled", virtual: "virtual", tabIndex: "tabIndex", valuePrimitive: "valuePrimitive", iconClass: "iconClass", loading: "loading", textField: "textField", valueField: "valueField", defaultItem: "defaultItem" }, outputs: { valueChange: "valueChange", filterChange: "filterChange", selectionChange: "selectionChange", open: "open", close: "close", onFocus: "focus", onBlur: "blur" }, exportAs: ["kendoDropDownList"], features: [ɵngcc0.ɵɵProvidersFeature([
            DROPDOWNLIST_VALUE_ACCESSOR,
            DataService,
            SelectionService,
            NavigationService,
            DisabledItemsService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.dropdownlist'
            },
            {
                provide: FilterableDropDownComponentBase, useExisting: forwardRef(() => DropDownListComponent)
            },
            {
                provide: KendoInput, useExisting: forwardRef(() => DropDownListComponent)
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature()], decls: 14, vars: 21, consts: [["kendoDropDownListLocalizedMessages", "", 6, "noDataText"], ["unselectable", "on", "role", "listbox", "aria-haspopup", "listbox", 3, "id", "ngClass", "focus", "blur", "keydown", "keypress", "click"], ["wrapper", ""], ["unselectable", "on", 1, "k-input", 3, "id"], [4, "ngIf"], [3, "ngIf"], ["unselectable", "on", 1, "k-select"], ["unselectable", "on", 1, "k-icon", 3, "ngClass"], ["popupTemplate", ""], ["container", ""], [3, "templateContext"], [3, "id", "optionPrefix", "data", "textField", "valueField", "template", "groupTemplate", "fixedGroupTemplate", "height", "show", "virtual", "pageChange"], ["optionsList", ""], ["class", "k-nodata", 4, "ngIf"], [1, "k-list-filter", 3, "click"], ["tabindex", "-1", 1, "k-textbox", 3, "filterInput", "dir", "ngModel", "ngModelChange", "keydown", "input", "focus", "blur"], ["unselectable", "on", 1, "k-icon", "k-i-search"], ["kendoDropDownsSelectable", "", 1, "k-list-optionlabel", 3, "ngClass", "index"], [1, "k-nodata"], [3, "ngIf", "templateContext"], [3, "resize"]], template: function DropDownListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵi18nAttributes(1, _c27);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(2, "span", 1, 2);
        ɵngcc0.ɵɵlistener("focus", function DropDownListComponent_Template_span_focus_2_listener() { return ctx.focusComponent(); })("blur", function DropDownListComponent_Template_span_blur_2_listener() { return ctx.blurComponent(); })("keydown", function DropDownListComponent_Template_span_keydown_2_listener($event) { return ctx.keydown($event); })("keypress", function DropDownListComponent_Template_span_keypress_2_listener($event) { return ctx.keypress($event); })("click", function DropDownListComponent_Template_span_click_2_listener() { return ctx.click(); });
        ɵngcc0.ɵɵelementStart(4, "span", 3);
        ɵngcc0.ɵɵtemplate(5, DropDownListComponent_5_Template, 1, 4, undefined, 4);
        ɵngcc0.ɵɵtemplate(6, DropDownListComponent_ng_template_6_Template, 1, 1, "ng-template", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(7, "span", 6);
        ɵngcc0.ɵɵelement(8, "span", 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(9, DropDownListComponent_ng_template_9_Template, 8, 17, "ng-template", null, 8, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(11, DropDownListComponent_ng_template_11_Template, 1, 0, "ng-template", 5);
        ɵngcc0.ɵɵelementContainer(12, null, 9);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("id", ctx.focusableId)("ngClass", ɵngcc0.ɵɵpureFunction3(17, _c29, !ctx.disabled, ctx.disabled, ctx.isFocused));
        ɵngcc0.ɵɵattribute("dir", ctx.direction)("readonly", ctx.readonly)("tabindex", ctx.widgetTabIndex)("aria-disabled", ctx.disabled)("aria-readonly", ctx.readonly)("aria-expanded", ctx.ariaExpanded)("aria-owns", ctx.ariaOwns)("aria-activedescendant", ctx.ariaActivedescendant)("aria-describedby", ctx.valueLabelId)("aria-label", ctx.noDataLabel);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("id", ctx.valueLabelId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.valueTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.valueTemplate);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngClass", ctx.buttonClasses);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isOpen);
    } }, directives: function () { return [LocalizedMessagesDirective, ɵngcc2.NgClass, ɵngcc2.NgIf, TemplateContextDirective,
        ListComponent, ɵngcc5.DefaultValueAccessor, FilterInputDirective, ɵngcc5.NgControlStatus, ɵngcc5.NgModel, SelectableDirective, ɵngcc4.ResizeSensorComponent]; }, encapsulation: 2 });
/** @nocollapse */
DropDownListComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: PopupService },
    { type: SelectionService },
    { type: NavigationService },
    { type: DisabledItemsService },
    { type: DataService },
    { type: NgZone },
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [TOUCH_ENABLED,] }] }
];
DropDownListComponent.propDecorators = {
    focusableId: [{ type: Input }],
    iconClass: [{ type: Input }],
    loading: [{ type: Input }],
    data: [{ type: Input }],
    value: [{ type: Input }],
    textField: [{ type: Input }],
    valueField: [{ type: Input }],
    popupSettings: [{ type: Input }],
    listHeight: [{ type: Input }],
    defaultItem: [{ type: Input }],
    disabled: [{ type: Input }],
    itemDisabled: [{ type: Input }],
    readonly: [{ type: Input }],
    filterable: [{ type: Input }],
    virtual: [{ type: Input }],
    ignoreCase: [{ type: Input }],
    delay: [{ type: Input }],
    valuePrimitive: [{ type: Input }],
    tabindex: [{ type: Input }],
    tabIndex: [{ type: Input, args: ["tabIndex",] }],
    valueChange: [{ type: Output }],
    filterChange: [{ type: Output }],
    selectionChange: [{ type: Output }],
    open: [{ type: Output }],
    close: [{ type: Output }],
    onFocus: [{ type: Output, args: ['focus',] }],
    onBlur: [{ type: Output, args: ['blur',] }],
    itemTemplate: [{ type: ContentChild, args: [ItemTemplateDirective,] }],
    groupTemplate: [{ type: ContentChild, args: [GroupTemplateDirective,] }],
    fixedGroupTemplate: [{ type: ContentChild, args: [FixedGroupTemplateDirective,] }],
    valueTemplate: [{ type: ContentChild, args: [ValueTemplateDirective,] }],
    headerTemplate: [{ type: ContentChild, args: [HeaderTemplateDirective,] }],
    footerTemplate: [{ type: ContentChild, args: [FooterTemplateDirective,] }],
    noDataTemplate: [{ type: ContentChild, args: [NoDataTemplateDirective,] }],
    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] }],
    popupTemplate: [{ type: ViewChild, args: ['popupTemplate',] }],
    wrapper: [{ type: ViewChild, args: ['wrapper',] }],
    optionsList: [{ type: ViewChild, args: ['optionsList',] }],
    widgetClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-dropdown',] }, { type: HostBinding, args: ['class.k-header',] }],
    dir: [{ type: HostBinding, args: ['attr.dir',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DropDownListComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoDropDownList',
                providers: [
                    DROPDOWNLIST_VALUE_ACCESSOR,
                    DataService,
                    SelectionService,
                    NavigationService,
                    DisabledItemsService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.dropdownlist'
                    },
                    {
                        provide: FilterableDropDownComponentBase, useExisting: forwardRef(() => DropDownListComponent)
                    },
                    {
                        provide: KendoInput, useExisting: forwardRef(() => DropDownListComponent)
                    }
                ],
                selector: 'kendo-dropdownlist',
                template: `
        <ng-container kendoDropDownListLocalizedMessages
            i18n-noDataText="kendo.dropdownlist.noDataText|The text displayed in the popup when there are no items"
            noDataText="NO DATA FOUND"
        >
        </ng-container>
        <span #wrapper unselectable="on"
          role="listbox"
          [id]="focusableId"
          [ngClass]="{
            'k-dropdown-wrap': true,
            'k-state-default': !this.disabled,
            'k-state-disabled': this.disabled,
            'k-state-focused': this.isFocused
          }"
          [attr.dir]="direction"
          [attr.readonly]="readonly"
          [attr.tabindex]="widgetTabIndex"
          [attr.aria-disabled]="disabled"
          [attr.aria-readonly]="readonly"
          aria-haspopup="listbox"
          [attr.aria-expanded]="ariaExpanded"
          [attr.aria-owns]="ariaOwns"
          [attr.aria-activedescendant]="ariaActivedescendant"
          [attr.aria-describedby]="valueLabelId"
          [attr.aria-label]="noDataLabel"
          (focus)="focusComponent()"
          (blur)="blurComponent()"
          (keydown)="keydown($event)"
          (keypress)="keypress($event)"
          (click)="click()"
        >
            <span class="k-input" unselectable="on" [id]="valueLabelId">
               <ng-template *ngIf="valueTemplate"
                   [templateContext]="{
                       templateRef: valueTemplate.templateRef,
                       $implicit: dataItem
                   }">
               </ng-template>
               <ng-template [ngIf]="!valueTemplate">{{ getText() }}</ng-template>
           </span>
           <span class="k-select" unselectable="on">
               <span
                    class="k-icon"
                    unselectable="on"
                    [ngClass]="buttonClasses"
                >
                </span>
           </span>
           <ng-template #popupTemplate>
               <!--filterable-->

               <ng-template [ngIf]="filterable">
                   <span class="k-list-filter" (click)="$event.stopImmediatePropagation()">
                       <input
                           [attr.aria-owns]="ariaOwns"
                           [attr.aria-activedescendant]="ariaActivedescendant"
                           [attr.aria-label]="noDataLabel"
                           tabindex="-1"
                           [filterInput]="isFocused && !touchEnabled"
                           [dir]="direction"
                           [(ngModel)]="filterText"
                           class="k-textbox"
                           (keydown)="keydown($event)"
                           (input)="handleFilter($event)"
                           (focus)="onFilterFocus()"
                           (blur)="blurFilterInput()" />
                       <span class="k-icon k-i-search" unselectable="on"></span>
                   </span>
               </ng-template>
               <!--default item-->
               <ng-template [ngIf]="defaultItem && !itemTemplate">
                   <div class="k-list-optionlabel" [ngClass]="{ 'k-state-disabled': isDisabledDefaultItem }" kendoDropDownsSelectable [index]="-1">
                       {{ getDefaultItemText() }}
                   </div>
               </ng-template>
               <ng-template [ngIf]="defaultItem && itemTemplate">
                   <div class="k-list-optionlabel" [ngClass]="{ 'k-state-disabled': isDisabledDefaultItem }" kendoDropDownsSelectable [index]="-1">
                       <ng-template
                           [templateContext]="{
                               templateRef: itemTemplate.templateRef,
                               $implicit: defaultItem
                           }">
                       </ng-template>
                   </div>
               </ng-template>
               <!--header template-->
               <ng-template *ngIf="headerTemplate"
                   [templateContext]="{
                       templateRef: headerTemplate.templateRef
                   }">
               </ng-template>
               <!--list-->
               <kendo-list
                   #optionsList
                   [id]="listBoxId"
                   [optionPrefix]="optionPrefix"
                   [data]="data"
                   [textField]="textField"
                   [valueField]="valueField"
                   [template]="itemTemplate"
                   [groupTemplate]="groupTemplate"
                   [fixedGroupTemplate]="fixedGroupTemplate"
                   [height]="listHeight"
                   [show]="isOpen"
                   [virtual]="virtual"
                   (pageChange)="pageChange($event)"
                   >
               </kendo-list>
               <!--no-data template-->
               <div class="k-nodata" *ngIf="data.length === 0">
                   <ng-template [ngIf]="noDataTemplate"
                       [templateContext]="{
                           templateRef: noDataTemplate ? noDataTemplate.templateRef : undefined
                       }">
                   </ng-template>
                   <ng-template [ngIf]="!noDataTemplate">
                       <div>{{ noDataText }}</div>
                   </ng-template>
               </div>
               <!--footer template-->
               <ng-template *ngIf="footerTemplate"
                   [templateContext]="{
                       templateRef: footerTemplate.templateRef
                   }">
               </ng-template>
            </ng-template>
        </span>
        <ng-template [ngIf]="isOpen">
            <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>
        </ng-template>
        <ng-container #container></ng-container>
  `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ɵngcc3.PopupService }, { type: SelectionService }, { type: NavigationService }, { type: DisabledItemsService }, { type: DataService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [TOUCH_ENABLED]
            }] }]; }, { focusableId: [{
            type: Input
        }], listHeight: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], filterable: [{
            type: Input
        }], ignoreCase: [{
            type: Input
        }], delay: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], filterChange: [{
            type: Output
        }], selectionChange: [{
            type: Output
        }], open: [{
            type: Output
        }], close: [{
            type: Output
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], widgetClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-dropdown']
        }, {
            type: HostBinding,
            args: ['class.k-header']
        }], data: [{
            type: Input
        }], value: [{
            type: Input
        }], popupSettings: [{
            type: Input
        }], itemDisabled: [{
            type: Input
        }], virtual: [{
            type: Input
        }], tabIndex: [{
            type: Input,
            args: ["tabIndex"]
        }], dir: [{
            type: HostBinding,
            args: ['attr.dir']
        }], valuePrimitive: [{
            type: Input
        }], iconClass: [{
            type: Input
        }], loading: [{
            type: Input
        }], textField: [{
            type: Input
        }], valueField: [{
            type: Input
        }], defaultItem: [{
            type: Input
        }], itemTemplate: [{
            type: ContentChild,
            args: [ItemTemplateDirective]
        }], groupTemplate: [{
            type: ContentChild,
            args: [GroupTemplateDirective]
        }], fixedGroupTemplate: [{
            type: ContentChild,
            args: [FixedGroupTemplateDirective]
        }], valueTemplate: [{
            type: ContentChild,
            args: [ValueTemplateDirective]
        }], headerTemplate: [{
            type: ContentChild,
            args: [HeaderTemplateDirective]
        }], footerTemplate: [{
            type: ContentChild,
            args: [FooterTemplateDirective]
        }], noDataTemplate: [{
            type: ContentChild,
            args: [NoDataTemplateDirective]
        }], container: [{
            type: ViewChild,
            args: ['container', { read: ViewContainerRef }]
        }], popupTemplate: [{
            type: ViewChild,
            args: ['popupTemplate']
        }], wrapper: [{
            type: ViewChild,
            args: ['wrapper']
        }], optionsList: [{
            type: ViewChild,
            args: ['optionsList']
        }] }); })();

/* tslint:disable:max-line-length */
/**
 * Renders the content of the custom list item in the MultiSelect
 * ([see example]({% slug templates_multiselect %}#toc-customizing-the-item-content)).
 * The template context is set to the current component.
 * To get a reference to the current text that is typed by the
 * user, use the `let-customItem` directive.
 *
 * > The `CustomItemTemplate` directive can only be used with the MultiSelect component.
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-multiselect [data]="listItems" [allowCustom]="true">
 *    <ng-template kendoMultiSelectCustomItemTemplate let-customItem>
 *      <span>New Item: {{customItem}}</span>
 *    </ng-template>
 *  </kendo-multiselect>
 * `
 * })
 * class AppComponent {
 *   public listItems: Array<string> = ["Item 1", "Item 2", "Item 3", "Item 4"];
 * }
 * ```
 *
 */
class CustomItemTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
CustomItemTemplateDirective.ɵfac = function CustomItemTemplateDirective_Factory(t) { return new (t || CustomItemTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
CustomItemTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CustomItemTemplateDirective, selectors: [["", "kendoMultiSelectCustomItemTemplate", ""]] });
/** @nocollapse */
CustomItemTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CustomItemTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoMultiSelectCustomItemTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();

/* tslint:disable:max-line-length */
/**
 * Renders the selected tag value of the MultiSelect
 * ([see example]({% slug templates_multiselect %}#toc-tag-template)).
 * The template context is set to the current component.
 * To get a reference to the current data item, use the `let-dataItem` directive.
 *
 * > The `TagTemplate` directive can only be used with the MultiSelect component.
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-multiselect [data]="items">
 *    <ng-template kendoMultiSelectTagTemplate let-dataItem>
 *      <span>{{dataItem}} option</span>
 *    </ng-template>
 *  </kendo-multiselect>
 * `
 * })
 * class AppComponent {
 *   public items: Array<string> = ["Item 1", "Item 2", "Item 3", "Item 4"];
 * }
 * ```
 */
class TagTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
TagTemplateDirective.ɵfac = function TagTemplateDirective_Factory(t) { return new (t || TagTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
TagTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TagTemplateDirective, selectors: [["", "kendoMultiSelectTagTemplate", ""]] });
/** @nocollapse */
TagTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TagTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoMultiSelectTagTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();

/* tslint:disable:max-line-length */
/**
 * Renders the grouped tag values in the MultiSelect
 * ([see example]({% slug summarytagmode_multiselect %})).
 * The template context is set to the current component.
 * To get a reference to the current grouped
 * data items collection, use the `let-dataItems` directive.
 *
 * > The `GroupTagTemplate` directive can only be used with the MultiSelect component.
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-multiselect kendoMultiSelectSummaryTag [data]="items">
 *    <ng-template kendoMultiSelectGroupTagTemplate let-dataItems>
 *      <span>{{dataItems.length}} item(s) selected</span>
 *    </ng-template>
 *  </kendo-multiselect>
 * `
 * })
 * class AppComponent {
 *   public items: Array<string> = ["Item 1", "Item 2", "Item 3", "Item 4"];
 * }
 * ```
 */
class GroupTagTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
GroupTagTemplateDirective.ɵfac = function GroupTagTemplateDirective_Factory(t) { return new (t || GroupTagTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
GroupTagTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: GroupTagTemplateDirective, selectors: [["", "kendoMultiSelectGroupTagTemplate", ""]] });
/** @nocollapse */
GroupTagTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GroupTagTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoMultiSelectGroupTagTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();

/**
 * Arguments for the `removeTag` event. The `removeTag` event fires when a tag is about
 * to the removed. If you cancel the event, the removal is prevented.
 */
class RemoveTagEvent extends PreventableEvent {
    /**
     * Constructs the event arguments for the `remove` event.
     * @param dataItem - The data item or an array of data items that will be removed.
     */
    constructor(dataItem) {
        super();
        this.dataItem = dataItem;
    }
}

/* tslint:disable:max-line-length */
const MULTISELECT_VALUE_ACCESSOR = {
    multi: true,
    provide: NG_VALUE_ACCESSOR,
    // tslint:disable-next-line:no-use-before-declare
    useExisting: forwardRef(() => MultiSelectComponent)
};
/**
 * Represents the [Kendo UI MultiSelect component for Angular]({% slug overview_multiselect %}).
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-multiselect [data]="listItems">
 *  </kendo-multiselect>
 * `
 * })
 * class AppComponent {
 *   public listItems: Array<string> = ["Item 1", "Item 2", "Item 3", "Item 4"];
 * }
 * ```
 */
class MultiSelectComponent {
    constructor(localization, popupService, dataService, selectionService, navigationService, disabledItemsService, cdr, differs, renderer, hostElement, _zone, touchEnabled) {
        this.localization = localization;
        this.popupService = popupService;
        this.dataService = dataService;
        this.selectionService = selectionService;
        this.navigationService = navigationService;
        this.disabledItemsService = disabledItemsService;
        this.cdr = cdr;
        this.differs = differs;
        this.renderer = renderer;
        this.hostElement = hostElement;
        this._zone = _zone;
        this.touchEnabled = touchEnabled;
        this.listBoxId = guid();
        this.tagListId = guid();
        this.tagPrefix = "tag-" + guid();
        this.optionPrefix = "option-" + guid();
        this.focusedTagIndex = undefined;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Determines whether to close the options list of the MultiSelect after the item selection is finished
         * ([see example]({% slug openstate_multiselect %}#toc-keeping-the-options-list-open-while-on-focus)).
         * @default true
         */
        this.autoClose = true;
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Sets the disabled state of the component.
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the component.
         */
        this.readonly = false;
        /**
         * Enables the [filtering]({% slug filtering_multiselect %}) functionality of the MultiSelect.
         */
        this.filterable = false;
        /**
         * Sets the height of the suggestions list. By default, `listHeight` is 200px.
         *
         * > The `listHeight` property affects only the list of suggestions and not the whole popup container.
         * > To set the height of the popup container, use `popupSettings.height`.
         */
        this.listHeight = 200;
        /**
         * If set to `true`, renders a button on hovering over the component.
         * Clicking this button resets the value of the component to an empty array and triggers the `change` event.
         */
        this.clearButton = true;
        /**
         * A user-defined callback function which receives an array of selected data items and maps them to an array of tags.
         *
         * @param { Any[] } dataItems - The selected data items from the list.
         * @returns { Any[] } - The tags that will be rendered by the component.
         */
        this.tagMapper = (tags) => tags || [];
        /**
         * Specifies whether the MultiSelect allows user-defined values that are not present in the dataset
         * ([more information and examples]({% slug custom_values_multiselect %})).
         * Defaults to `false`.
         */
        this.allowCustom = false;
        /**
         * A user-defined callback function which returns normalized custom values.
         * Typically used when the data items are different from type `string`.
         *
         * @param { Any } value - The custom value that is defined by the user.
         * @returns { Any }
         *
         * @example
         * ```ts
         * import { map } from 'rxjs/operators';
         *
         * _@Component({
         * selector: 'my-app',
         * template: `
         *   <kendo-multiselect
         *       [allowCustom]="true"
         *       [data]="listItems"
         *       [textField]="'text'"
         *       [valueField]="'value'"
         *       [valueNormalizer]="valueNormalizer"
         *       (valueChange)="onValueChange($event)"
         *   >
         *   </kendo-multiselect>
         * `
         * })
         *
         * class AppComponent {
         *   public listItems: Array<{ text: string, value: number }> = [
         *       { text: "Small", value: 1 },
         *       { text: "Medium", value: 2 },
         *       { text: "Large", value: 3 }
         *   ];
         *
         *   public onValueChange(value) {
         *       console.log("valueChange : ", value);
         *   }
         *
         *   public valueNormalizer = (text$: Observable<string>) => text$.pipe(map((text: string) => {
         *      return {
         *         value: Math.floor(Math.random() * (1000 - 100) + 1000), //generate unique valueField
         *         text: text };
         *   }));
         *
         * }
         * ```
         */
        this.valueNormalizer = (text) => text.pipe(map((userInput) => {
            const comparer = (item) => typeof item === 'string' && userInput.toLowerCase() === item.toLowerCase();
            const matchingValue = this.value.find(comparer);
            if (matchingValue) {
                return matchingValue;
            }
            const matchingItem = this.dataService.find(comparer);
            return matchingItem ? matchingItem : userInput;
        }));
        /**
         * Fires each time the user types in the input field.
         * You can filter the source based on the passed filtration value.
         */
        this.filterChange = new EventEmitter();
        /**
         * Fires each time the value is changed&mdash;
         * when the component is blurred or the value is cleared through the **Clear** button
         * ([see example]({% slug overview_multiselect %}#toc-events)).
         * When the value of the component is programmatically changed to `ngModel` or `formControl`
         * through its API or form binding, the `valueChange` event is not triggered because it
         * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the popup is about to open
         * ([see example]({% slug openstate_multiselect %}#toc-preventing-opening-and-closing)).
         * This event is preventable. If you cancel it, the popup will remain closed.
         */
        this.open = new EventEmitter();
        /**
         * Fires each time the popup is about to close
         * ([see example]({% slug openstate_multiselect %}#toc-preventing-opening-and-closing)).
         * This event is preventable. If you cancel it, the popup will remain open.
         */
        this.close = new EventEmitter();
        /**
         * Fires each time the user focuses the MultiSelect.
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the MultiSelect gets blurred.
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time a tag is about to be removed.
         * This event is preventable. If you cancel it, the tag will not be removed.
         */
        this.removeTag = new EventEmitter();
        this.widgetClasses = true;
        this.onChangeCallback = (_) => { };
        this.onTouchedCallback = (_) => { };
        this._placeholder = '';
        this._open = false;
        this._value = [];
        this._popupSettings = { animate: true };
        this.isFocused = false;
        this.selectedDataItems = [];
        this.customValueSubject = new Subject();
        this.observableSubscriptions = new Subscription();
        this.hostElement = hostElement.nativeElement;
        this.popupMouseDownHandler = this.onMouseDown.bind(this);
        this.data = [];
        this.direction = this.localization.rtl ? 'rtl' : 'ltr';
        this.subscribeEvents();
    }
    /**
     * Focuses the MultiSelect.
     */
    focus() {
        if (!this.disabled) {
            this.searchbar.focus();
        }
    }
    /**
     * @hidden
     */
    onSearchBarFocus() {
        if (!this.isFocused) {
            this.isFocused = true;
            this.onFocus.emit();
        }
    }
    /**
     * Blurs the MultiSelect.
     */
    blur() {
        if (!this.disabled) {
            this.searchbar.blur();
        }
    }
    /**
     * @hidden
     */
    onSearchBarBlur() {
        if (this.isFocused) {
            this.closePopup();
            this.isFocused = false;
            if (!this.allowCustom) {
                this.clearFilter();
            }
            this.onBlur.emit();
            this.onTouchedCallback();
        }
    }
    /**
     * @hidden
     */
    wrapperMousedown(event) {
        const inputElement = this.searchbar.input.nativeElement;
        if (event.button === 0) {
            if (this.isFocused && this.isOpen && event.target === inputElement) {
                return;
            }
            if (!this.touchEnabled || (this.touchEnabled && event.target.tagName !== 'SPAN')) {
                this.searchbar.focus();
            }
            this.togglePopup(!this.isOpen);
            event.preventDefault();
        }
    }
    /**
     * @hidden
     */
    onMouseDown(event) {
        event.preventDefault();
    }
    /**
     * @hidden
     */
    onResize() {
        if (this._open) {
            const popupWrapper = this.popupRef.popupElement;
            const { min, max } = this.width;
            popupWrapper.style.minWidth = min;
            popupWrapper.style.width = max;
        }
    }
    get appendTo() {
        const { appendTo } = this.popupSettings;
        if (!appendTo || appendTo === 'root') {
            return undefined;
        }
        return appendTo === 'component' ? this.container : appendTo;
    }
    /**
     * Sets the data of the MultiSelect.
     *
     * > The data has to be provided in an array-like list of items.
     */
    set data(data) {
        this.dataService.data = data || [];
        if (this.virtual) {
            this.virtual.skip = 0;
        }
        this.setState(this.value);
    }
    get data() {
        const virtual = this.virtual;
        if (virtual) {
            const start = virtual.skip || 0;
            const end = start + virtual.pageSize;
            //Use length instead of itemsCount because of grouping
            virtual.total = this.dataService.data.length;
            return this.dataService.data.slice(start, end);
        }
        return this.dataService.data;
    }
    /**
     * Sets the value of the MultiSelect. It can be either of the primitive (string, numbers) or of the complex (objects) type.
     * To define the type, use the `valuePrimitive` option.
     *
     * > All selected values which are not present in the source are ignored.
     */
    set value(values) {
        this._value = values ? values : [];
        if (!this.differ && this.value) {
            this.differ = this.differs.find(this.value).create();
        }
    }
    get value() {
        return this._value;
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    /**
     * The hint which is displayed when the component is empty.
     * When the values are selected, it disappears.
     */
    set placeholder(text) {
        this._placeholder = text || '';
    }
    get placeholder() {
        return this.selectedDataItems.length ? '' : this._placeholder;
    }
    /**
     * Defines a Boolean function that is executed for each data item in the component
     * ([see examples]({% slug disableditems_multiselect %})). Determines whether the item will be disabled.
     */
    set itemDisabled(fn) {
        if (typeof fn !== 'function') {
            throw new Error(`itemDisabled must be a function, but received ${JSON.stringify(fn)}.`);
        }
        this.disabledItemsService.itemDisabled = fn;
    }
    /**
     * Enables the [virtualization]({% slug virtualization_multiselect %}) functionality.
     */
    set virtual(settings) {
        this._virtualSettings = normalizeVirtualizationSettings(settings);
    }
    get virtual() {
        return this._virtualSettings;
    }
    /**
     * Configures the popup of the MultiSelect.
     *
     * The available options are:
     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
     * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.
     * - `height: Number`&mdash;Sets the height of the popup container.
     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
     * - `appendTo: "root" | "component" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.
     */
    set popupSettings(settings) {
        this._popupSettings = Object.assign({ animate: true }, settings);
    }
    get popupSettings() {
        return this._popupSettings;
    }
    get dir() {
        return this.direction;
    }
    get focusedClass() {
        return this.isFocused;
    }
    get disabledClass() {
        return this.disabled;
    }
    get listContainerClasses() {
        const containerClasses = ['k-list-container', 'k-reset'];
        if (this.popupSettings.popupClass) {
            containerClasses.push(this.popupSettings.popupClass);
        }
        return containerClasses;
    }
    get width() {
        let wrapperOffsetWidth = 0;
        if (isDocumentAvailable()) {
            wrapperOffsetWidth = this.wrapper.nativeElement.offsetWidth;
        }
        const width = this.popupSettings.width || wrapperOffsetWidth;
        const minWidth = isNaN(wrapperOffsetWidth) ? wrapperOffsetWidth : `${wrapperOffsetWidth}px`;
        const maxWidth = isNaN(width) ? width : `${width}px`;
        return { min: minWidth, max: maxWidth };
    }
    get height() {
        const popupHeight = this.popupSettings.height;
        return isPresent(popupHeight) ? `${popupHeight}px` : 'auto';
    }
    get activeDescendant() {
        const focusedTagIndex = this.focusedTagIndex;
        const focusedListIndex = this.selectionService.focused;
        let prefix;
        let item;
        if (isPresent(focusedTagIndex) && !this.isOpen) {
            item = this.tags[focusedTagIndex];
            prefix = this.tagPrefix;
        }
        else if (isPresent(focusedListIndex) && focusedListIndex !== -1 && this.isOpen) {
            item = this.dataService.itemAt(focusedListIndex);
            prefix = this.optionPrefix;
        }
        else {
            return null;
        }
        return prefix + "-" + this.prop(this.valueField, this.valuePrimitive)(item);
    }
    get noDataLabel() {
        if (this.dataService.itemsCount === 0) {
            return this.noDataText;
        }
    }
    get clearTitle() {
        return this.localization.get('clearTitle');
    }
    /**
     * @hidden
     */
    verifySettings() {
        const valueOrText = !isPresent(this.valueField) !== !isPresent(this.textField);
        if (!isDevMode() || this.value.length === 0) {
            return;
        }
        if (!isArray(this.value)) {
            throw new Error(MultiselectMessages.array);
        }
        if (this.valuePrimitive === true && isObjectArray(this.value)) {
            throw new Error(MultiselectMessages.primitive);
        }
        if (this.valuePrimitive === false && !isObjectArray(this.value)) {
            throw new Error(MultiselectMessages.object);
        }
        if (valueOrText) {
            throw new Error(MultiselectMessages.textAndValue);
        }
    }
    /**
     * @hidden
     */
    change(event) {
        const isCustomItem = (isPresent(event.added) || isPresent(event.removed)) && (event.added === -1 || event.removed === -1);
        if (isCustomItem) {
            this.addCustomValue(this.text);
            return; // The change is emited asynchronosly.
        }
        // Existing items.
        if (isPresent(event.added)) {
            const dataItem = this.dataService.itemAt(event.added);
            const newItem = (this.valuePrimitive && isPresent(dataItem) && isPresent(dataItem[this.valueField])) ? dataItem[this.valueField] : dataItem;
            this.value = [...this.value, newItem];
            this.cdr.markForCheck();
        }
        if (isPresent(event.removed)) {
            const dataItem = this.dataService.itemAt(event.removed);
            const prop = this.prop(this.valueField, this.valuePrimitive);
            const filter$$1 = (item) => prop(item) !== prop(dataItem);
            this.value = this.value.filter(filter$$1);
            this.selectedDataItems = this.selectedDataItems.filter(filter$$1);
            this.tags = this.tagMapper(this.selectedDataItems.slice());
            this.cdr.detectChanges();
        }
        this.emitValueChange();
    }
    /**
     * @hidden
     */
    setState(value) {
        const objectArray = isObjectArray(value);
        let data = this.dataService.data;
        if (this.dataService.grouped) {
            data = data.filter(item => !item.header).map(item => item.value);
        }
        const selection = selectedIndices(this.value, data, this.valueField);
        this.selectionService.resetSelection(selection);
        if (this.isOpen && this.selectionService.focused === undefined) {
            this.selectionService.focused = this.dataService.itemsCount ? this.firstFocusableIndex(0) : this.allowCustom ? -1 : undefined;
        }
        if (!this.text) {
            if (!(isPresent(value) && value.length)) {
                this.selectedDataItems = [];
            }
            if (this.valuePrimitive && !this.valueField) {
                this.selectedDataItems = value.slice();
            }
            if (objectArray || this.valuePrimitive && this.valueField) {
                this.selectedDataItems = resolveAllValues(value, data, this.valueField);
            }
            if (this.selectedDataItems.length < value.length) {
                const prop = this.prop(this.valueField, this.valuePrimitive);
                const dataItems = value
                    .map(current => {
                    const dataItem = this.selectedDataItems.find(item => prop(item) === prop(current));
                    return isPresent(dataItem) ? dataItem : this.resolveDataItemFromTags(current);
                })
                    .filter(dataItem => isPresent(dataItem));
                this.selectedDataItems = dataItems;
            }
        }
        this.tags = this.tagMapper(this.selectedDataItems.slice(0));
        this.cdr.markForCheck();
    }
    /**
     * @hidden
     */
    handleFilter(text) {
        this.text = text;
        if (text && !this.isOpen) {
            this.openPopup();
        }
        if (this.filterable) {
            this.filterChange.emit(text);
        }
        else {
            this.searchTextAndFocus(text);
        }
        this.searchbar.setInputSize();
    }
    /**
     * @hidden
     */
    pageChange(event) {
        const virtual = this.virtual;
        virtual.skip = event.skip;
    }
    /**
     * @hidden
     */
    clearFilter() {
        if (this.filterable && this.text) {
            this.filterChange.emit("");
        }
        this.text = "";
        /* Clearing the value from the input as the setInputSize calculation will be incorrect otherwise.
         Calling cdr.detectChanges to clear the input value as a result of property binding
         causes JAWS to read outdated tag values in IE upon tag selection for some reason. */
        this.searchbar.input.nativeElement.value = "";
        this.searchbar.setInputSize();
    }
    /**
     * @hidden
     */
    handleNavigate(event) {
        const navigateInput = this.text && event.keyCode !== Keys.down && event.keyCode !== Keys.up;
        const selectValue = this.text && event.keyCode === Keys.enter || event.keyCode === Keys.esc;
        const deleteTag = !this.text && event.keyCode === Keys.backspace && this.tags.length > 0;
        if (deleteTag) {
            this.handleBackspace();
            return;
        }
        if (this.disabled || navigateInput && !selectValue) {
            return;
        }
        const eventData = event;
        const focused = isNaN(this.selectionService.focused) ? -1 : this.selectionService.focused;
        const action = this.navigationService.process({
            current: focused,
            max: this.dataService.itemsCount - 1,
            min: this.allowCustom && this.text ? -1 : 0,
            open: this.isOpen,
            originalEvent: eventData
        });
        if (action !== NavigationAction.Undefined &&
            ((action === NavigationAction.Enter && this.isOpen) || action !== NavigationAction.Enter)) {
            event.preventDefault();
        }
    }
    /**
     * @hidden
     */
    handleRemoveTag(tagData) {
        const eventArgs = new RemoveTagEvent(tagData);
        if (this.disabled || this.readonly) {
            return;
        }
        this.focus();
        this.removeTag.emit(eventArgs);
        if (eventArgs.isDefaultPrevented()) {
            return;
        }
        if (tagData instanceof Array) {
            this.removeGroupTag(tagData);
        }
        else {
            this.removeSingleTag(tagData);
        }
        this.cdr.detectChanges();
    }
    /**
     * @hidden
     */
    clearAll(event) {
        event.stopImmediatePropagation();
        this.clearFilter();
        this.reset();
        this.emitValueChange();
    }
    /**
     * @hidden
     */
    addCustomValue(text) {
        this.customValueSubject.next(text);
    }
    ngAfterContentChecked() {
        this.verifySettings();
    }
    ngDoCheck() {
        if (this.differ) {
            const valueChanges = this.differ.diff(this.value);
            if (valueChanges && !this.valueChangeDetected) {
                this.selectedDataItems = this.getSelectedDataItems(valueChanges);
                this.tags = this.tagMapper(this.selectedDataItems.slice(0));
                if (!(this.tags && this.dataService.data)) {
                    return;
                }
                const isValueCustom = (value) => this.dataService.indexOf(value) === -1;
                const isValueSelected = (value) => this.selectionService.isSelected(this.dataService.indexOf(value));
                const reselectionRequired = this.selectedDataItems.some(value => !(isValueCustom(value) || isValueSelected(value)));
                if (reselectionRequired) {
                    this.setState(this.value);
                }
            }
        }
        this.valueChangeDetected = false;
    }
    ngOnInit() {
        this.renderer.removeAttribute(this.hostElement, "tabindex");
        this.createCustomValueStream();
        this.localizationChangeSubscription = this.localization
            .changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
            this.setMessages();
        });
        this.setMessages();
    }
    ngOnChanges(changes) {
        const virtual = this.virtual;
        const requestInitialData = virtual && changes.data && changes.data.isFirstChange();
        if (requestInitialData) {
            this.pageChange({ skip: 0, take: virtual.pageSize });
        }
        if (this.valuePrimitive === undefined) {
            this.valuePrimitive = !this.valueField;
        }
        if (isChanged("valueNormalizer", changes)) {
            this.createCustomValueStream();
        }
        const STATE_PROPS = /(data|textField|valueField|valuePrimitive|value)/g;
        if (changes.hasOwnProperty("value")) {
            this.valueChangeDetected = true;
        }
        if (STATE_PROPS.test(Object.keys(changes).join())) {
            this.setState(this.value);
        }
    }
    ngAfterViewInit() {
        this.searchbar.setInputSize();
    }
    ngOnDestroy() {
        this._toggle(false);
        this.unsubscribeEvents();
        clearTimeout(this.messagesTimeout);
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
    }
    /**
     * Toggles the visibility of the popup
     * ([see example]({% slug openstate_multiselect %}#toc-setting-the-initially-opened-component)).
     * If you use the `toggle` method to open or close the popup, the respective `open` and `close` events will not be fired.
     *
     * @param open - The state of the popup.
     */
    toggle(open) {
        // The Promise is required for opening the popup on load.
        // Otherwise, the "Expression has changed..." type error will be thrown.
        Promise.resolve(null).then(() => {
            this._toggle((open === undefined) ? !this._open : open);
            this.cdr.markForCheck();
        });
    }
    /**
     * Returns the current open state of the popup.
     */
    get isOpen() {
        return this._open;
    }
    /**
     * Resets the value of the MultiSelect.
     * If you use the `reset` method to clear the value of the component,
     * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.
     */
    reset() {
        this.text = "";
        this.value = [];
        this.selectedDataItems = [];
        this.setState([]);
        this.cdr.markForCheck();
    }
    // NG MODEL BINDINGS
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value || [];
        this.setState(this.value);
        this.verifySettings();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    onTagMapperChange() {
        this.tags = this.tagMapper(this.selectedDataItems.slice(0));
        this.cdr.markForCheck();
    }
    prop(field, usePrimitive) {
        return (dataItem) => {
            if (isPresent(dataItem)) {
                if (usePrimitive) {
                    return field && isObject(dataItem) ? dataItem[field] : dataItem;
                }
                else {
                    return dataItem[field];
                }
            }
            return null;
        };
    }
    subscribeEvents() {
        if (!isDocumentAvailable()) {
            return;
        }
        const isOpen = () => this.isOpen;
        const isClosed = () => !this.isOpen;
        const isTagFocused = () => !this.isOpen && this.focusedTagIndex !== undefined;
        [
            this.selectionService.onChange.subscribe(this.handleItemChange.bind(this)),
            this.navigationService.esc.subscribe(this.closePopup.bind(this)),
            this.navigationService.enter.pipe(filter(isOpen)).subscribe(this.handleEnter.bind(this)),
            this.navigationService.open.subscribe(this.openPopup.bind(this)),
            this.navigationService.close.subscribe(this.handleClose.bind(this)),
            this.navigationService.up.pipe(filter(isOpen)).subscribe((event) => this.handleUp(event.index)),
            this.navigationService.home.pipe(filter(() => isClosed)).subscribe(this.handleHome.bind(this)),
            this.navigationService.end.pipe(filter(() => isClosed)).subscribe(this.handleEnd.bind(this)),
            this.navigationService.backspace.pipe(filter(isTagFocused)).subscribe(this.handleBackspace.bind(this)),
            this.navigationService.delete.pipe(filter(isTagFocused)).subscribe(this.handleDelete.bind(this)),
            this.navigationService.left.subscribe(this.handleLeftKey.bind(this)),
            this.navigationService.right.subscribe(this.handleRightKey.bind(this)),
            this.navigationService.down.subscribe((event) => this.handleDownKey(event.index))
        ].forEach(s => this.observableSubscriptions.add(s));
    }
    unsubscribeEvents() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.observableSubscriptions.unsubscribe();
        if (this.customValueSubscription) {
            this.customValueSubscription.unsubscribe();
        }
    }
    removeGroupTag(dataItems) {
        const prop = this.prop(this.valueField, this.valuePrimitive);
        let data = this.dataService.data;
        if (this.dataService.grouped) {
            data = data.filter(item => !item.header).map(item => item.value);
        }
        const dataItemValues = new Set(dataItems.map(item => prop(item)));
        this.value = this.value.filter(value => !dataItemValues.has(prop(value)));
        this.selectedDataItems = this.selectedDataItems.filter(value => !dataItemValues.has(prop(value)));
        const selection = selectedIndices(this.value, data, this.valueField);
        this.selectionService.resetSelection(selection);
        this.tags = this.tagMapper(this.selectedDataItems.slice(0));
        this.cdr.markForCheck();
        this.emitValueChange();
    }
    removeSingleTag(dataItem) {
        const prop = this.prop(this.valueField, this.valuePrimitive);
        let data = this.dataService.data;
        if (this.dataService.grouped) {
            data = data.filter(item => !item.header).map(item => item.value);
        }
        const index = selectedIndices([dataItem], data, this.valueField)[0];
        if (isNumber(index)) {
            this.selectionService.unselect(index);
            this.togglePopup(false);
        }
        else { // the deleted item is not present in the source
            const filter$$1 = item => prop(item) !== prop(dataItem);
            this.value = this.value.filter(filter$$1);
            this.selectedDataItems = this.selectedDataItems.filter(filter$$1);
            this.tags = this.tagMapper(this.selectedDataItems.slice(0));
            this.cdr.markForCheck();
            this.emitValueChange();
        }
    }
    createCustomValueStream() {
        if (this.customValueSubscription) {
            this.customValueSubscription.unsubscribe();
        }
        this.customValueSubscription = this.customValueSubject.pipe(tap(() => {
            this.loading = true;
            this.disabled = true;
            this.cdr.detectChanges();
        }), this.valueNormalizer, catchError(() => {
            this.loading = false;
            this.disabled = false;
            this.clearFilter();
            if (this.autoClose) {
                this.togglePopup(false);
                this.nextTick(() => {
                    this.searchbar.focus();
                });
            }
            this.createCustomValueStream();
            return of(null);
        }))
            .subscribe((normalizedValue) => {
            this.loading = false;
            this.disabled = false;
            this.clearFilter();
            if (isPresent(normalizedValue)) { //if valueNormalizer returns `null` or `undefined` custom value is discarded
                const newValue = this.valuePrimitive ? getter(normalizedValue, this.valueField) : normalizedValue;
                const itemIndex = this.dataService.indexOf(newValue);
                const customItem = itemIndex === -1;
                if (this.value.indexOf(newValue) === -1) {
                    if (!customItem) {
                        this.selectionService.add(itemIndex);
                    }
                    else {
                        this.value = [...this.value, newValue];
                    }
                    this.selectedDataItems = [...this.selectedDataItems, normalizedValue];
                }
                else {
                    if (!customItem && this.selectionService.isSelected(itemIndex)) {
                        this.selectionService.unselect(itemIndex);
                    }
                    else {
                        this.value.splice(this.value.indexOf(newValue), 1);
                        this.selectedDataItems = this.selectedDataItems.filter(item => getter(item, this.valueField) !== newValue);
                    }
                }
                this.tags = this.tagMapper(this.selectedDataItems.slice(0));
                this.emitValueChange();
            }
            if (this.autoClose) {
                this.togglePopup(false);
                this.nextTick(() => {
                    this.searchbar.focus();
                });
            }
        });
    }
    handleItemChange(event) {
        this.change(event);
        if (this.autoClose) {
            this.togglePopup(false);
        }
        if (isPresent(event.added) && event.added !== -1) {
            this.clearFilter();
        }
    }
    handleEnter(event) {
        const service = this.selectionService;
        const focusedIndex = this.selectionService.focused;
        if (this.isOpen) {
            event.originalEvent.preventDefault();
        }
        if (focusedIndex === -1) {
            if (this.allowCustom && this.text) {
                this.addCustomValue(this.text);
            }
            return; // Clear filter & close are done at customValueSubscription due to race conditions.
        }
        if (service.isSelected(focusedIndex)) {
            service.unselect(focusedIndex);
        }
        else {
            service.add(focusedIndex);
        }
        this.clearFilter();
        if (this.autoClose) {
            this.togglePopup(false);
        }
    }
    handleClose() {
        this.closePopup();
        this.searchbar.focus();
    }
    handleEnd() {
        this.focusedTagIndex = this.tags.length - 1;
    }
    handleHome() {
        this.focusedTagIndex = 0;
    }
    handleUp(index) {
        this.selectionService.focused = index;
    }
    handleBackspace() {
        if (this.focusedTagIndex !== undefined) {
            this.handleDelete();
        }
        else {
            this.handleRemoveTag(this.tags[this.tags.length - 1]);
            this.searchbar.focus();
        }
    }
    handleDelete() {
        this.handleRemoveTag(this.tags[this.focusedTagIndex]);
        if (this.focusedTagIndex === this.tags.length) {
            this.focusedTagIndex = undefined;
        }
    }
    handleLeftKey() {
        if (this.direction === 'rtl') {
            if (this.focusedTagIndex === 0) {
                this.focusedTagIndex = undefined;
            }
            if (this.focusedTagIndex === undefined) {
                return;
            }
        }
        if (this.focusedTagIndex === undefined || this.focusedTagIndex < 0) {
            this.focusedTagIndex = this.tags.length - 1;
        }
        else if (this.focusedTagIndex !== 0) {
            this.focusedTagIndex--;
        }
    }
    handleDownKey(index) {
        if (this.isOpen) {
            this.selectionService.focused = index || this.firstFocusableIndex(0);
        }
        else {
            this.openPopup();
        }
    }
    handleRightKey() {
        const last = this.tags.length - 1;
        if (this.direction === 'rtl') {
            if (this.focusedTagIndex === undefined) {
                this.focusedTagIndex = 0;
                return;
            }
            if (this.focusedTagIndex === last) {
                return;
            }
        }
        if (this.focusedTagIndex === last) {
            this.focusedTagIndex = undefined;
        }
        else if (this.focusedTagIndex < last) {
            this.focusedTagIndex++;
        }
    }
    findIndex(text, startsFrom = 0) {
        let itemText;
        text = text.toLowerCase();
        let index = this.dataService.findIndex(item => {
            if (this.dataService.grouped) {
                itemText = this.prop(this.textField, this.valuePrimitive)(item.value);
            }
            else {
                itemText = this.prop(this.textField, this.valuePrimitive)(item);
            }
            itemText = !isPresent(itemText) ? "" : itemText.toString().toLowerCase();
            return text && itemText.startsWith(text);
        }, startsFrom);
        if (this.disabledItemsService.isIndexDisabled(index)) {
            return (index + 1 > this.dataService.itemsCount) ? -1 : this.findIndex(text, index + 1);
        }
        else {
            return index;
        }
    }
    searchTextAndFocus(text) {
        const index = this.findIndex(text);
        this.selectionService.focused = index;
    }
    closePopup() {
        this.togglePopup(false);
        this.focusedTagIndex = undefined;
    }
    openPopup() {
        this.togglePopup(true);
        this.focusedTagIndex = undefined;
    }
    togglePopup(open) {
        const isDisabled = this.disabled || this.readonly;
        const sameState = this.isOpen === open;
        if (isDisabled || sameState) {
            return;
        }
        const isDefaultPrevented = this.triggerPopupEvents(open);
        if (!isDefaultPrevented) {
            this._toggle(open);
        }
    }
    triggerPopupEvents(open) {
        const eventArgs = new PreventableEvent();
        if (open) {
            this.open.emit(eventArgs);
        }
        else {
            this.close.emit(eventArgs);
        }
        return eventArgs.isDefaultPrevented();
    }
    _toggle(open) {
        this._open = (open === undefined) ? !this._open : open;
        this.destroyPopup();
        if (this._open) {
            this.createPopup();
        }
    }
    destroyPopup() {
        if (this.popupRef) {
            this.popupRef.popupElement
                .removeEventListener('mousedown', this.popupMouseDownHandler);
            this.popupRef.close();
            this.popupRef = null;
        }
    }
    createPopup() {
        if (this.virtual) {
            this.virtual.skip = 0;
        }
        const horizontalAlign = this.direction === "rtl" ? "right" : "left";
        const anchorPosition = { horizontal: horizontalAlign, vertical: "bottom" };
        const popupPosition = { horizontal: horizontalAlign, vertical: "top" };
        this.popupRef = this.popupService.open({
            anchor: this.wrapper,
            anchorAlign: anchorPosition,
            animate: this.popupSettings.animate,
            appendTo: this.appendTo,
            content: this.popupTemplate,
            popupAlign: popupPosition,
            popupClass: this.listContainerClasses,
            positionMode: 'absolute'
        });
        const popupWrapper = this.popupRef.popupElement;
        const { min, max } = this.width;
        popupWrapper.addEventListener('mousedown', this.popupMouseDownHandler);
        popupWrapper.style.minWidth = min;
        popupWrapper.style.width = max;
        popupWrapper.style.height = this.height;
        popupWrapper.setAttribute("dir", this.direction);
        this.popupRef.popupOpen.subscribe(() => {
            this.cdr.detectChanges();
            this.optionsList.scrollToItem(this.selectionService.focused);
        });
        this.popupRef.popupAnchorViewportLeave.subscribe(() => {
            this.togglePopup(false);
        });
    }
    emitValueChange() {
        this.onChangeCallback(this.value);
        this.valueChange.emit(this.value);
    }
    getSelectedDataItems(valueChanges) {
        const isBoundToComplexData = isObjectArray(this.data);
        const prop = this.prop(this.valueField, this.valuePrimitive);
        let currentValue;
        let index;
        let selectedDataItems = [];
        valueChanges.forEachItem((value) => {
            currentValue = value.currentValue;
            if (this.dataService.grouped) {
                index = this.dataService.findIndex((item) => {
                    return prop(item.value) === prop(currentValue);
                });
            }
            else {
                index = this.dataService.findIndex((item) => {
                    return prop(item) === prop(currentValue);
                });
            }
            if (index !== -1) {
                selectedDataItems.push(this.dataService.itemAt(index));
            }
            else if (isPresent(value) && !(isBoundToComplexData && this.valuePrimitive)) { //value is not present in the data
                selectedDataItems.push(currentValue);
            }
            else { // value is primitive, dataItem is an object, dataItem is not present in the current data set
                const item = this.resolveDataItemFromTags(currentValue);
                if (isPresent(item)) {
                    selectedDataItems.push(item);
                }
            }
        });
        return selectedDataItems;
    }
    resolveDataItemFromTags(value) {
        if (!(this.tags && this.tags.length && isPresent(value))) {
            return undefined;
        }
        // Flattening the tags array in case of a summary tag occurrence.
        const tags = this.tags.reduce((acc, tag) => {
            const items = isArray(tag) ? tag : [tag];
            acc.push(...items);
            return acc;
        }, []);
        const prop = this.prop(this.valueField, this.valuePrimitive);
        return tags.find(tag => prop(tag) === prop(value));
    }
    firstFocusableIndex(index) {
        const maxIndex = this.dataService.itemsCount;
        if (this.disabledItemsService.isIndexDisabled(index)) {
            const nextIndex = index + 1;
            return (nextIndex < maxIndex) ? this.firstFocusableIndex(nextIndex) : undefined;
        }
        else {
            return index;
        }
    }
    nextTick(f) {
        this._zone.runOutsideAngular(() => {
            // Use `setTimeout` instead of a resolved promise
            // because the latter does not wait long enough.
            setTimeout(() => this._zone.run(f));
        });
    }
    setMessages() {
        this._zone.runOutsideAngular(() => {
            clearTimeout(this.messagesTimeout);
            this.messagesTimeout = setTimeout(() => {
                this.noDataText = this.localization.get('noDataText');
                this.cdr.detectChanges();
            });
        });
    }
}
MultiSelectComponent.ɵfac = function MultiSelectComponent_Factory(t) { return new (t || MultiSelectComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.PopupService), ɵngcc0.ɵɵdirectiveInject(DataService), ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(DisabledItemsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.KeyValueDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(TOUCH_ENABLED, 8)); };
MultiSelectComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MultiSelectComponent, selectors: [["kendo-multiselect"]], contentQueries: function MultiSelectComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ItemTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, CustomItemTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, GroupTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, FixedGroupTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, TagTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, GroupTagTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.customItemTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.fixedGroupTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tagTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupTagTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);
    } }, viewQuery: function MultiSelectComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c9, true, ViewContainerRef);
        ɵngcc0.ɵɵviewQuery(SearchBarComponent, true);
        ɵngcc0.ɵɵviewQuery(_c10, true);
        ɵngcc0.ɵɵviewQuery(_c24, true);
        ɵngcc0.ɵɵviewQuery(_c11, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.searchbar = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.wrapper = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.optionsList = _t.first);
    } }, hostVars: 11, hostBindings: function MultiSelectComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.dir);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.widgetClasses)("k-multiselect", ctx.widgetClasses)("k-header", ctx.widgetClasses)("k-state-focused", ctx.focusedClass)("k-state-disabled", ctx.disabledClass);
    } }, inputs: { focusableId: "focusableId", autoClose: "autoClose", tabindex: "tabindex", disabled: "disabled", readonly: "readonly", filterable: "filterable", listHeight: "listHeight", clearButton: "clearButton", tagMapper: "tagMapper", allowCustom: "allowCustom", valueNormalizer: "valueNormalizer", data: "data", value: "value", tabIndex: "tabIndex", placeholder: "placeholder", itemDisabled: "itemDisabled", virtual: "virtual", popupSettings: "popupSettings", valuePrimitive: "valuePrimitive", loading: "loading", valueField: "valueField", textField: "textField" }, outputs: { filterChange: "filterChange", valueChange: "valueChange", open: "open", close: "close", onFocus: "focus", onBlur: "blur", removeTag: "removeTag" }, exportAs: ["kendoMultiSelect"], features: [ɵngcc0.ɵɵProvidersFeature([
            MULTISELECT_VALUE_ACCESSOR,
            DataService,
            SelectionService,
            NavigationService,
            DisabledItemsService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.multiselect'
            },
            {
                provide: FilterableDropDownComponentBase, useExisting: forwardRef(() => MultiSelectComponent)
            },
            {
                provide: KendoInput, useExisting: forwardRef(() => MultiSelectComponent)
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature()], decls: 14, vars: 23, consts: [["kendoMultiSelectLocalizedMessages", "", 6, "noDataText", "clearTitle"], [1, "k-multiselect-wrap", "k-floatwrap", 3, "mousedown"], ["wrapper", ""], [3, "id", "tags", "textField", "valueField", "focused", "disabled", "template", "groupTemplate", "tagPrefix", "removeTag"], [3, "id", "role", "tagListId", "activeDescendant", "noDataLabel", "userInput", "disabled", "readonly", "tabIndex", "popupOpen", "placeholder", "onNavigate", "valueChange", "onBlur", "onFocus"], ["searchbar", ""], ["class", "k-icon k-clear-value k-i-close", "role", "button", "tabindex", "-1", 3, "mousedown", 4, "ngIf"], ["class", "k-icon k-i-loading", 4, "ngIf"], ["popupTemplate", ""], [3, "ngIf"], ["container", ""], ["role", "button", "tabindex", "-1", 1, "k-icon", "k-clear-value", "k-i-close", 3, "mousedown"], [1, "k-icon", "k-i-loading"], [4, "ngIf"], ["class", "k-list", 4, "ngIf"], [3, "id", "optionPrefix", "data", "textField", "valueField", "height", "template", "groupTemplate", "fixedGroupTemplate", "show", "multipleSelection", "virtual", "pageChange"], ["optionsList", ""], ["class", "k-nodata", 4, "ngIf"], [3, "templateContext"], [1, "k-list"], ["kendoDropDownsSelectable", "", 1, "k-item", "k-custom-item", 3, "multipleSelection", "index"], [4, "ngIf", "ngIfElse"], ["default_custom_item_template", ""], [1, "k-icon", "k-i-plus", 2, "float", "right"], [1, "k-nodata"], [3, "ngIf", "templateContext"], [3, "resize"]], template: function MultiSelectComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵi18nAttributes(1, _c34);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 1, 2);
        ɵngcc0.ɵɵlistener("mousedown", function MultiSelectComponent_Template_div_mousedown_2_listener($event) { return ctx.wrapperMousedown($event); });
        ɵngcc0.ɵɵelementStart(4, "kendo-taglist", 3);
        ɵngcc0.ɵɵlistener("removeTag", function MultiSelectComponent_Template_kendo_taglist_removeTag_4_listener($event) { return ctx.handleRemoveTag($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "kendo-searchbar", 4, 5);
        ɵngcc0.ɵɵlistener("onNavigate", function MultiSelectComponent_Template_kendo_searchbar_onNavigate_5_listener($event) { return ctx.handleNavigate($event); })("valueChange", function MultiSelectComponent_Template_kendo_searchbar_valueChange_5_listener($event) { return ctx.handleFilter($event); })("onBlur", function MultiSelectComponent_Template_kendo_searchbar_onBlur_5_listener() { return ctx.onSearchBarBlur(); })("onFocus", function MultiSelectComponent_Template_kendo_searchbar_onFocus_5_listener() { return ctx.onSearchBarFocus(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, MultiSelectComponent_span_7_Template, 1, 1, "span", 6);
        ɵngcc0.ɵɵtemplate(8, MultiSelectComponent_span_8_Template, 1, 0, "span", 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(9, MultiSelectComponent_ng_template_9_Template, 6, 16, "ng-template", null, 8, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(11, MultiSelectComponent_ng_template_11_Template, 1, 0, "ng-template", 9);
        ɵngcc0.ɵɵelementContainer(12, null, 10);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("id", ctx.tagListId)("tags", ctx.tags)("textField", ctx.textField)("valueField", ctx.valueField)("focused", ctx.focusedTagIndex)("disabled", ctx.disabled)("template", ctx.tagTemplate)("groupTemplate", ctx.groupTagTemplate)("tagPrefix", ctx.tagPrefix);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("id", ctx.focusableId)("role", "listbox")("tagListId", ctx.tagListId)("activeDescendant", ctx.activeDescendant)("noDataLabel", ctx.noDataLabel)("userInput", ctx.text)("disabled", ctx.disabled)("readonly", ctx.readonly)("tabIndex", ctx.tabIndex)("popupOpen", ctx.isOpen)("placeholder", ctx.placeholder);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.loading && !ctx.readonly && ctx.clearButton && ((ctx.tags == null ? null : ctx.tags.length) || (ctx.text == null ? null : ctx.text.length)));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.loading);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isOpen);
    } }, directives: function () { return [LocalizedMessagesDirective,
        TagListComponent,
        SearchBarComponent, ɵngcc2.NgIf, ListComponent,
        TemplateContextDirective,
        SelectableDirective, ɵngcc4.ResizeSensorComponent]; }, encapsulation: 2 });
/** @nocollapse */
MultiSelectComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: PopupService },
    { type: DataService },
    { type: SelectionService },
    { type: NavigationService },
    { type: DisabledItemsService },
    { type: ChangeDetectorRef },
    { type: KeyValueDiffers },
    { type: Renderer2 },
    { type: ElementRef },
    { type: NgZone },
    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [TOUCH_ENABLED,] }] }
];
MultiSelectComponent.propDecorators = {
    focusableId: [{ type: Input }],
    autoClose: [{ type: Input }],
    loading: [{ type: Input }],
    data: [{ type: Input }],
    value: [{ type: Input }],
    valueField: [{ type: Input }],
    textField: [{ type: Input }],
    tabindex: [{ type: Input }],
    tabIndex: [{ type: Input, args: ["tabIndex",] }],
    placeholder: [{ type: Input }],
    disabled: [{ type: Input }],
    itemDisabled: [{ type: Input }],
    readonly: [{ type: Input }],
    filterable: [{ type: Input }],
    virtual: [{ type: Input }],
    popupSettings: [{ type: Input }],
    listHeight: [{ type: Input }],
    valuePrimitive: [{ type: Input }],
    clearButton: [{ type: Input }],
    tagMapper: [{ type: Input }],
    allowCustom: [{ type: Input }],
    valueNormalizer: [{ type: Input }],
    filterChange: [{ type: Output }],
    valueChange: [{ type: Output }],
    open: [{ type: Output }],
    close: [{ type: Output }],
    onFocus: [{ type: Output, args: ['focus',] }],
    onBlur: [{ type: Output, args: ['blur',] }],
    removeTag: [{ type: Output }],
    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] }],
    searchbar: [{ type: ViewChild, args: [SearchBarComponent,] }],
    popupTemplate: [{ type: ViewChild, args: ['popupTemplate',] }],
    wrapper: [{ type: ViewChild, args: ['wrapper',] }],
    optionsList: [{ type: ViewChild, args: ['optionsList',] }],
    template: [{ type: ContentChild, args: [ItemTemplateDirective,] }],
    customItemTemplate: [{ type: ContentChild, args: [CustomItemTemplateDirective,] }],
    groupTemplate: [{ type: ContentChild, args: [GroupTemplateDirective,] }],
    fixedGroupTemplate: [{ type: ContentChild, args: [FixedGroupTemplateDirective,] }],
    headerTemplate: [{ type: ContentChild, args: [HeaderTemplateDirective,] }],
    footerTemplate: [{ type: ContentChild, args: [FooterTemplateDirective,] }],
    tagTemplate: [{ type: ContentChild, args: [TagTemplateDirective,] }],
    groupTagTemplate: [{ type: ContentChild, args: [GroupTagTemplateDirective,] }],
    noDataTemplate: [{ type: ContentChild, args: [NoDataTemplateDirective,] }],
    widgetClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-multiselect',] }, { type: HostBinding, args: ['class.k-header',] }],
    dir: [{ type: HostBinding, args: ['attr.dir',] }],
    focusedClass: [{ type: HostBinding, args: ['class.k-state-focused',] }],
    disabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MultiSelectComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoMultiSelect',
                providers: [
                    MULTISELECT_VALUE_ACCESSOR,
                    DataService,
                    SelectionService,
                    NavigationService,
                    DisabledItemsService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.multiselect'
                    },
                    {
                        provide: FilterableDropDownComponentBase, useExisting: forwardRef(() => MultiSelectComponent)
                    },
                    {
                        provide: KendoInput, useExisting: forwardRef(() => MultiSelectComponent)
                    }
                ],
                selector: 'kendo-multiselect',
                template: `
        <ng-container kendoMultiSelectLocalizedMessages
            i18n-noDataText="kendo.multiselect.noDataText|The text displayed in the popup when there are no items"
            noDataText="NO DATA FOUND"

            i18n-clearTitle="kendo.combobox.clearTitle|The title of the clear button"
            clearTitle="clear"
        >
        </ng-container>
        <div class="k-multiselect-wrap k-floatwrap"
            #wrapper
            (mousedown)="wrapperMousedown($event)"
        >
            <kendo-taglist
                [id]="tagListId"
                [tags]="tags"
                [textField]="textField"
                [valueField]="valueField"
                [focused]="focusedTagIndex"
                [disabled]="disabled"
                [template]="tagTemplate"
                [groupTemplate]="groupTagTemplate"
                [tagPrefix]="tagPrefix"
                (removeTag)="handleRemoveTag($event)"
            >
            </kendo-taglist>
            <kendo-searchbar
                #searchbar
                [id]="focusableId"
                [role]="'listbox'"
                [tagListId]="tagListId"
                [activeDescendant]="activeDescendant"
                [noDataLabel]="noDataLabel"
                [userInput]="text"
                [disabled]="disabled"
                [readonly]="readonly"
                [tabIndex]="tabIndex"
                [popupOpen]="isOpen"
                [placeholder]="placeholder"
                (onNavigate)="handleNavigate($event)"
                (valueChange)="handleFilter($event)"
                (onBlur)="onSearchBarBlur()"
                (onFocus)="onSearchBarFocus()"
            >
            </kendo-searchbar>
            <span *ngIf="!loading && !readonly && clearButton && (tags?.length || text?.length)" class="k-icon k-clear-value k-i-close" [attr.title]="clearTitle" role="button" tabindex="-1" (mousedown)="clearAll($event)"></span>
            <span *ngIf="loading" class="k-icon k-i-loading"></span>
        </div>
        <ng-template #popupTemplate>
            <!--header template-->
            <ng-template *ngIf="headerTemplate"
                [templateContext]="{
                    templateRef: headerTemplate.templateRef
                }">
            </ng-template>
            <!--custom item template-->
            <div class="k-list" *ngIf="allowCustom && text">
                <div class="k-item k-custom-item" kendoDropDownsSelectable [multipleSelection]="true" [index]="-1">
                    <ng-template *ngIf="customItemTemplate;else default_custom_item_template"
                        [templateContext]="{
                            templateRef: customItemTemplate.templateRef,
                            $implicit: text
                        }">
                    </ng-template>
                    <ng-template #default_custom_item_template>{{ text }}</ng-template>
                    <span class="k-icon k-i-plus" style="float: right"></span>
                </div>
            </div>
            <!--list-->
            <kendo-list
                #optionsList
                [id]="listBoxId"
                [optionPrefix]="optionPrefix"
                [data]="data"
                [textField]="textField"
                [valueField]="valueField"
                [height]="listHeight"
                [template]="template"
                [groupTemplate]="groupTemplate"
                [fixedGroupTemplate]="fixedGroupTemplate"
                [show]="isOpen"
                [multipleSelection]="true"
                [virtual]="virtual"
                (pageChange)="pageChange($event)"
                >
            </kendo-list>
            <!--no data template-->
            <div class="k-nodata" *ngIf="data.length === 0">
                <ng-template [ngIf]="noDataTemplate"
                    [templateContext]="{
                        templateRef: noDataTemplate ? noDataTemplate.templateRef : undefined
                    }">
                </ng-template>
                <ng-template [ngIf]="!noDataTemplate">
                    <div>{{ noDataText }}</div>
                </ng-template>
            </div>
            <!--footer template-->
            <ng-template *ngIf="footerTemplate"
                [templateContext]="{
                    templateRef: footerTemplate.templateRef
                }">
            </ng-template>
        </ng-template>
        <ng-template [ngIf]="isOpen">
            <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>
        </ng-template>
        <ng-container #container></ng-container>
  `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ɵngcc3.PopupService }, { type: DataService }, { type: SelectionService }, { type: NavigationService }, { type: DisabledItemsService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.KeyValueDiffers }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [TOUCH_ENABLED]
            }] }]; }, { focusableId: [{
            type: Input
        }], autoClose: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], filterable: [{
            type: Input
        }], listHeight: [{
            type: Input
        }], clearButton: [{
            type: Input
        }], tagMapper: [{
            type: Input
        }], allowCustom: [{
            type: Input
        }], valueNormalizer: [{
            type: Input
        }], filterChange: [{
            type: Output
        }], valueChange: [{
            type: Output
        }], open: [{
            type: Output
        }], close: [{
            type: Output
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], removeTag: [{
            type: Output
        }], widgetClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-multiselect']
        }, {
            type: HostBinding,
            args: ['class.k-header']
        }], data: [{
            type: Input
        }], value: [{
            type: Input
        }], tabIndex: [{
            type: Input,
            args: ["tabIndex"]
        }], placeholder: [{
            type: Input
        }], itemDisabled: [{
            type: Input
        }], virtual: [{
            type: Input
        }], popupSettings: [{
            type: Input
        }], dir: [{
            type: HostBinding,
            args: ['attr.dir']
        }], focusedClass: [{
            type: HostBinding,
            args: ['class.k-state-focused']
        }], disabledClass: [{
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], valuePrimitive: [{
            type: Input
        }], loading: [{
            type: Input
        }], valueField: [{
            type: Input
        }], textField: [{
            type: Input
        }], container: [{
            type: ViewChild,
            args: ['container', { read: ViewContainerRef }]
        }], searchbar: [{
            type: ViewChild,
            args: [SearchBarComponent]
        }], popupTemplate: [{
            type: ViewChild,
            args: ['popupTemplate']
        }], wrapper: [{
            type: ViewChild,
            args: ['wrapper']
        }], optionsList: [{
            type: ViewChild,
            args: ['optionsList']
        }], template: [{
            type: ContentChild,
            args: [ItemTemplateDirective]
        }], customItemTemplate: [{
            type: ContentChild,
            args: [CustomItemTemplateDirective]
        }], groupTemplate: [{
            type: ContentChild,
            args: [GroupTemplateDirective]
        }], fixedGroupTemplate: [{
            type: ContentChild,
            args: [FixedGroupTemplateDirective]
        }], headerTemplate: [{
            type: ContentChild,
            args: [HeaderTemplateDirective]
        }], footerTemplate: [{
            type: ContentChild,
            args: [FooterTemplateDirective]
        }], tagTemplate: [{
            type: ContentChild,
            args: [TagTemplateDirective]
        }], groupTagTemplate: [{
            type: ContentChild,
            args: [GroupTagTemplateDirective]
        }], noDataTemplate: [{
            type: ContentChild,
            args: [NoDataTemplateDirective]
        }] }); })();

/* tslint:disable:max-line-length */
/**
 * @hidden
 */
class TagListComponent {
    constructor() {
        this.removeTag = new EventEmitter();
    }
    tagProp(tag, prop) {
        return prop && isObject(tag) ? tag[prop] : tag;
    }
    deleteTag(event, tag) {
        event.preventDefault();
        event.stopImmediatePropagation();
        if (!this.disabled && event.which === 1) {
            this.removeTag.emit(tag);
        }
    }
    itemId(tag) {
        if (tag) { //because of custom values
            return this.tagPrefix + "-" + this.tagProp(tag, this.valueField);
        }
    }
    isGroupTag(tag) {
        return tag instanceof Array;
    }
}
TagListComponent.ɵfac = function TagListComponent_Factory(t) { return new (t || TagListComponent)(); };
TagListComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TagListComponent, selectors: [["kendo-taglist"]], inputs: { tags: "tags", textField: "textField", valueField: "valueField", focused: "focused", template: "template", groupTemplate: "groupTemplate", disabled: "disabled", tagPrefix: "tagPrefix", id: "id" }, outputs: { removeTag: "removeTag" }, decls: 2, vars: 2, consts: [[1, "k-reset"], ["role", "option", "aria-selected", "true", "class", "k-button", 3, "ngClass", 4, "ngFor", "ngForOf"], ["role", "option", "aria-selected", "true", 1, "k-button", 3, "ngClass"], [4, "ngIf", "ngIfThen", "ngIfElse"], ["groupTag", ""], ["singleTag", ""], ["aria-label", "delete", 1, "k-select"], [1, "k-icon", "k-i-close", 3, "mousedown"], [4, "ngIf"], [3, "ngIf"], [3, "templateContext"]], template: function TagListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ul", 0);
        ɵngcc0.ɵɵtemplate(1, TagListComponent_li_1_Template, 8, 9, "li", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.tags);
    } }, directives: function () { return [ɵngcc2.NgForOf, ListItemDirective, ɵngcc2.NgClass, ɵngcc2.NgIf, TemplateContextDirective]; }, encapsulation: 2 });
TagListComponent.propDecorators = {
    tags: [{ type: Input }],
    textField: [{ type: Input }],
    valueField: [{ type: Input }],
    focused: [{ type: Input }],
    template: [{ type: Input }],
    groupTemplate: [{ type: Input }],
    disabled: [{ type: Input }],
    tagPrefix: [{ type: Input }],
    id: [{ type: Input }],
    removeTag: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TagListComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-taglist',
                template: `
        <ul [attr.id]="id" class="k-reset">
            <li role="option" *ngFor="let tag of tags; let i = index;" aria-selected="true" [attr.aria-setsize]="tags?.length"
                class="k-button" [ngClass]="{ 'k-state-focused': i === focused }" [attr.id]="itemId(tag)"
            >
                <ng-template *ngIf="isGroupTag(tag); then groupTag else singleTag"></ng-template>
                    <ng-template #groupTag>
                        <span>
                            <ng-template *ngIf="groupTemplate"
                                [templateContext]="{
                                templateRef: groupTemplate.templateRef,
                                $implicit: tag
                            }">
                            </ng-template>
                            <ng-template [ngIf]="!groupTemplate">{{ tag.length }} {{ tag.length === 1 ? 'item' : 'items' }} selected</ng-template>
                        </span>
                    </ng-template>
                    <ng-template #singleTag>
                        <span>
                        <ng-template *ngIf="template"
                                [templateContext]="{
                                templateRef: template.templateRef,
                                $implicit: tag
                            }">
                            </ng-template>
                            <ng-template [ngIf]="!template">{{ tagProp(tag, textField) }}</ng-template>
                        </span>
                    </ng-template>

                <span aria-label="delete" [attr.aria-hidden]="i !== focused" class="k-select">
                    <span class="k-icon k-i-close" (mousedown)="deleteTag($event, tag)">
                    </span>
                </span>
            </li>
        </ul>
  `
            }]
    }], function () { return []; }, { removeTag: [{
            type: Output
        }], tags: [{
            type: Input
        }], textField: [{
            type: Input
        }], valueField: [{
            type: Input
        }], focused: [{
            type: Input
        }], template: [{
            type: Input
        }], groupTemplate: [{
            type: Input
        }], disabled: [{
            type: Input
        }], tagPrefix: [{
            type: Input
        }], id: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class TemplateContextDirective {
    constructor(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
    }
    set templateContext(context) {
        if (this.insertedViewRef) {
            this.viewContainerRef.remove(this.viewContainerRef.indexOf(this.insertedViewRef));
            this.insertedViewRef = undefined;
        }
        if (context.templateRef) {
            this.insertedViewRef = this.viewContainerRef.createEmbeddedView(context.templateRef, context);
        }
    }
}
TemplateContextDirective.ɵfac = function TemplateContextDirective_Factory(t) { return new (t || TemplateContextDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
TemplateContextDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TemplateContextDirective, selectors: [["", "templateContext", ""]], inputs: { templateContext: "templateContext" } });
/** @nocollapse */
TemplateContextDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];
TemplateContextDirective.propDecorators = {
    templateContext: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TemplateContextDirective, [{
        type: Directive,
        args: [{
                selector: '[templateContext]' // tslint:disable-line
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }]; }, { templateContext: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class SelectableDirective {
    constructor(selectionService) {
        // @HostBinding('attr.offset-index')
        // @Input() public offsetIndex: number;
        this.multipleSelection = false;
        this.selectionService = selectionService;
    }
    get focusedClassName() {
        return this.selectionService.isFocused(this.index);
    }
    get selectedClassName() {
        return this.selectionService.isSelected(this.index);
    }
    onClick(event) {
        event.stopPropagation();
        if (this.multipleSelection) {
            if (this.selectionService.isSelected(this.index)) {
                this.selectionService.unselect(this.index);
            }
            else {
                this.selectionService.add(this.index);
            }
        }
        else {
            this.selectionService.change(this.index);
        }
    }
}
SelectableDirective.ɵfac = function SelectableDirective_Factory(t) { return new (t || SelectableDirective)(ɵngcc0.ɵɵdirectiveInject(SelectionService)); };
SelectableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SelectableDirective, selectors: [["", "kendoDropDownsSelectable", ""]], hostVars: 9, hostBindings: function SelectableDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function SelectableDirective_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("index", ctx.index);
        ɵngcc0.ɵɵstyleProp("height", ctx.height, "px")("min-height", ctx.height, "px");
        ɵngcc0.ɵɵclassProp("k-state-focused", ctx.focusedClassName)("k-state-selected", ctx.selectedClassName);
    } }, inputs: { multipleSelection: "multipleSelection", index: "index", height: "height" } });
/** @nocollapse */
SelectableDirective.ctorParameters = () => [
    { type: SelectionService }
];
SelectableDirective.propDecorators = {
    index: [{ type: HostBinding, args: ['attr.index',] }, { type: Input }],
    height: [{ type: HostBinding, args: ['style.height.px',] }, { type: HostBinding, args: ['style.minHeight.px',] }, { type: Input }],
    multipleSelection: [{ type: Input }],
    focusedClassName: [{ type: HostBinding, args: ['class.k-state-focused',] }],
    selectedClassName: [{ type: HostBinding, args: ['class.k-state-selected',] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SelectableDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDropDownsSelectable]'
            }]
    }], function () { return [{ type: SelectionService }]; }, { multipleSelection: [{
            type: Input
        }], focusedClassName: [{
            type: HostBinding,
            args: ['class.k-state-focused']
        }], selectedClassName: [{
            type: HostBinding,
            args: ['class.k-state-selected']
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], index: [{
            type: HostBinding,
            args: ['attr.index']
        }, {
            type: Input
        }], height: [{
            type: HostBinding,
            args: ['style.height.px']
        }, {
            type: HostBinding,
            args: ['style.minHeight.px']
        }, {
            type: Input
        }] }); })();

/**
 * A directive which configures the MultiSelect to show one single summary tag for all selected data items.
 * When a number is provided, the summary tag is displayed after the given amount of data items are selected
 * ([more information and examples]({% slug summarytagmode_multiselect %})).
 *
 * @example
 * ```ts-no-run
 * <kendo-multiselect kendoMultiSelectSummaryTag [data]="data"></kendo-multiselect>
 * ```
 *
 * @example
 * ```ts-no-run
 * <kendo-multiselect [kendoMultiSelectSummaryTag]="2" [data]="data"></kendo-multiselect>
 * ```
 */
class SummaryTagDirective {
    constructor(multiSelectComponent) {
        this.multiSelectComponent = multiSelectComponent;
        /**
         * A numeric value that indicates the number of selected data items after which the summary tag will appear.
         */
        this.showAfter = 0; // tslint:disable-line:no-input-rename
        this.createTagMapper();
    }
    ngOnChanges(changes) {
        if (isPresent(changes.showAfter)) {
            this.createTagMapper();
            this.multiSelectComponent.onTagMapperChange();
        }
    }
    createTagMapper() {
        this.multiSelectComponent.tagMapper = (tags) => {
            if (tags.length > this.showAfter) {
                let result;
                result = tags.slice(0, this.showAfter);
                result.push(tags.slice(this.showAfter, tags.length));
                return result;
            }
            else {
                return tags;
            }
        };
    }
}
SummaryTagDirective.ɵfac = function SummaryTagDirective_Factory(t) { return new (t || SummaryTagDirective)(ɵngcc0.ɵɵdirectiveInject(MultiSelectComponent)); };
SummaryTagDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SummaryTagDirective, selectors: [["", "kendoMultiSelectSummaryTag", ""]], inputs: { showAfter: ["kendoMultiSelectSummaryTag", "showAfter"] }, features: [ɵngcc0.ɵɵNgOnChangesFeature()] });
/** @nocollapse */
SummaryTagDirective.ctorParameters = () => [
    { type: MultiSelectComponent }
];
SummaryTagDirective.propDecorators = {
    showAfter: [{ type: Input, args: ['kendoMultiSelectSummaryTag',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SummaryTagDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoMultiSelectSummaryTag]'
            }]
    }], function () { return [{ type: MultiSelectComponent }]; }, { showAfter: [{
            type: Input,
            args: ['kendoMultiSelectSummaryTag']
        }] }); })();

const DEFAULT_FILTER_SETTINGS = {
    caseSensitive: false,
    operator: 'startsWith'
};
/**
 * Implements an event handler for the `filterChange` event of a DropDowns component
 * which performs simple data filtering.
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-autocomplete
 *      [data]="data"
 *      kendoDropDownFilter
 *      placeholder="e.g. Andorra">
 *  </kendo-autocomplete>
 * `
 * })
 * class AppComponent {
 *     public data: Array<string> = ["Albania", "Andorra", "Armenia", "Austria", "Azerbaijan"];
 * }
 * ```
 */
class FilterDirective {
    constructor(component) {
        this.component = component;
        /**
         * @hidden
         *
         * Sets whether the filtering functionality is enabled on component init.
         */
        this.filterable = true;
        this._data = [];
        this._filterSettings = DEFAULT_FILTER_SETTINGS;
    }
    /**
     * The initial data that will be used as a source array for the filtering operations.
     */
    set data(data) {
        this._data = data || [];
    }
    get data() {
        return this._data;
    }
    /**
     * The configuration object which sets the behavior of the `kendoDropDownFilter` directive.
     */
    set filterSettings(settings) {
        this._filterSettings = Object.assign({}, DEFAULT_FILTER_SETTINGS, settings);
    }
    get filterSettings() {
        return this._filterSettings;
    }
    ngOnInit() {
        this.component.filterable = this.filterable;
        this.filterChangeSubscription = this.component.filterChange
            .subscribe(query => this.component.data = this.getFilteredData(query));
    }
    ngOnDestroy() {
        this.filterChangeSubscription.unsubscribe();
    }
    getFilteredData(query) {
        const field = this.component.textField || this.component.valueField;
        return this.data.filter(item => this.checkItem(getter(item, field), query));
    }
    checkItem(target, query) {
        target = this.normalizeValue(target);
        query = this.normalizeValue(query);
        return this.filterSettings.operator === 'contains' ? target.indexOf(query) !== -1 : target.indexOf(query) === 0;
    }
    normalizeValue(value) {
        const normalizedValue = isPresent(value) ? value.toString() : '';
        return this.filterSettings.caseSensitive ? normalizedValue : normalizedValue.toLowerCase();
    }
}
FilterDirective.ɵfac = function FilterDirective_Factory(t) { return new (t || FilterDirective)(ɵngcc0.ɵɵdirectiveInject(FilterableDropDownComponentBase)); };
FilterDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FilterDirective, selectors: [["", "kendoDropDownFilter", ""]], inputs: { filterable: "filterable", data: "data", filterSettings: ["kendoDropDownFilter", "filterSettings"] } });
/** @nocollapse */
FilterDirective.ctorParameters = () => [
    { type: FilterableDropDownComponentBase }
];
FilterDirective.propDecorators = {
    data: [{ type: Input }],
    filterSettings: [{ type: Input, args: ['kendoDropDownFilter',] }],
    filterable: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FilterDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDropDownFilter]'
            }]
    }], function () { return [{ type: FilterableDropDownComponentBase }]; }, { filterable: [{
            type: Input
        }], data: [{
            type: Input
        }], filterSettings: [{
            type: Input,
            args: ['kendoDropDownFilter']
        }] }); })();

/**
 * @hidden
 */
class Messages extends ComponentMessages {
}
Messages.ɵfac = function Messages_Factory(t) { return ɵMessages_BaseFactory(t || Messages); };
Messages.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: Messages, inputs: { noDataText: "noDataText", clearTitle: "clearTitle" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
Messages.propDecorators = {
    noDataText: [{ type: Input }],
    clearTitle: [{ type: Input }]
};
const ɵMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(Messages);

/**
 * @hidden
 */
class LocalizedMessagesDirective extends Messages {
    constructor(service) {
        super();
        this.service = service;
    }
}
LocalizedMessagesDirective.ɵfac = function LocalizedMessagesDirective_Factory(t) { return new (t || LocalizedMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
LocalizedMessagesDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LocalizedMessagesDirective, selectors: [["", "kendoDropDownListLocalizedMessages", ""], ["", "kendoComboBoxLocalizedMessages", ""], ["", "kendoAutoCompleteLocalizedMessages", ""], ["", "kendoMultiSelectLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: Messages,
                useExisting: forwardRef(() => LocalizedMessagesDirective) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
LocalizedMessagesDirective.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LocalizedMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: Messages,
                        useExisting: forwardRef(() => LocalizedMessagesDirective) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: `
    [kendoDropDownListLocalizedMessages],
    [kendoComboBoxLocalizedMessages],
    [kendoAutoCompleteLocalizedMessages],
    [kendoMultiSelectLocalizedMessages]
  `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();

/**
 * Custom component messages override default component messages
 * ([see example]({% slug globalization_grid %}#toc-localization)).
 */
class CustomMessagesComponent extends Messages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
}
CustomMessagesComponent.ɵfac = function CustomMessagesComponent_Factory(t) { return new (t || CustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
CustomMessagesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CustomMessagesComponent, selectors: [["kendo-dropdownlist-messages"], ["kendo-combobox-messages"], ["kendo-autocomplete-messages"], ["kendo-multiselect-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: Messages,
                useExisting: forwardRef(() => CustomMessagesComponent) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function CustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
CustomMessagesComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: Messages,
                        useExisting: forwardRef(() => CustomMessagesComponent) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-dropdownlist-messages, kendo-combobox-messages, kendo-autocomplete-messages, kendo-multiselect-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();

const SHARED_DIRECTIVES = [
    HeaderTemplateDirective,
    FooterTemplateDirective,
    ItemTemplateDirective,
    GroupTemplateDirective,
    FixedGroupTemplateDirective,
    NoDataTemplateDirective,
    LocalizedMessagesDirective,
    CustomMessagesComponent,
    FilterDirective
];
/**
 * @hidden
 *
 * The exported package module.
 *
 * The package exports:
 * - `ItemTemplateDirective`&mdash;The item template directive.
 * - `HeaderTemplateDirective`&mdash;The header template directive.
 * - `FooterTemplateDirective`&mdash;The footer template directive.
 * - `NoDataTemplateDirective`&mdash;The noData template directive.
 */
class SharedDirectivesModule {
}
SharedDirectivesModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: SharedDirectivesModule });
SharedDirectivesModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function SharedDirectivesModule_Factory(t) { return new (t || SharedDirectivesModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SharedDirectivesModule, { declarations: [HeaderTemplateDirective,
        FooterTemplateDirective,
        ItemTemplateDirective,
        GroupTemplateDirective,
        FixedGroupTemplateDirective,
        NoDataTemplateDirective,
        LocalizedMessagesDirective,
        CustomMessagesComponent,
        FilterDirective], exports: [HeaderTemplateDirective,
        FooterTemplateDirective,
        ItemTemplateDirective,
        GroupTemplateDirective,
        FixedGroupTemplateDirective,
        NoDataTemplateDirective,
        LocalizedMessagesDirective,
        CustomMessagesComponent,
        FilterDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SharedDirectivesModule, [{
        type: NgModule,
        args: [{
                declarations: [SHARED_DIRECTIVES],
                exports: [SHARED_DIRECTIVES]
            }]
    }], null, null); })();

const INTERNAL_DIRECTIVES = [
    ListComponent,
    ListItemDirective,
    SelectableDirective,
    SearchBarComponent,
    TemplateContextDirective
];
/**
 * @hidden
 */
class SharedModule {
}
SharedModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: SharedModule });
SharedModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function SharedModule_Factory(t) { return new (t || SharedModule)(); }, imports: [[CommonModule, FormsModule, PopupModule, ResizeSensorModule, SharedDirectivesModule],
        CommonModule, FormsModule, PopupModule, ResizeSensorModule,
        SharedDirectivesModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SharedModule, { declarations: function () { return [ListComponent,
        ListItemDirective,
        SelectableDirective,
        SearchBarComponent,
        TemplateContextDirective]; }, imports: function () { return [CommonModule, FormsModule, PopupModule, ResizeSensorModule,
        SharedDirectivesModule]; }, exports: function () { return [ListComponent,
        ListItemDirective,
        SelectableDirective,
        SearchBarComponent,
        TemplateContextDirective,
        CommonModule, FormsModule, PopupModule, ResizeSensorModule,
        SharedDirectivesModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SharedModule, [{
        type: NgModule,
        args: [{
                declarations: [INTERNAL_DIRECTIVES],
                exports: [INTERNAL_DIRECTIVES, CommonModule, FormsModule, PopupModule, ResizeSensorModule, SharedDirectivesModule],
                imports: [CommonModule, FormsModule, PopupModule, ResizeSensorModule, SharedDirectivesModule]
            }]
    }], null, null); })();

const AUTOCOMPLETE_DIRECTIVES = [
    AutoCompleteComponent
];
/**
 * @hidden
 *
 * The exported package module.
 *
 * The package exports:
 * - `AutoCompleteComponent`&mdash;The AutoComplete component class.
 * - `ItemTemplateDirective`&mdash;The item template directive.
 * - `HeaderTemplateDirective`&mdash;The header template directive.
 * - `FooterTemplateDirective`&mdash;The footer template directive.
 */
class AutoCompleteModule {
}
AutoCompleteModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AutoCompleteModule });
AutoCompleteModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function AutoCompleteModule_Factory(t) { return new (t || AutoCompleteModule)(); }, imports: [[SharedModule],
        SharedDirectivesModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AutoCompleteModule, { declarations: [AutoCompleteComponent], imports: [SharedModule], exports: [AutoCompleteComponent,
        SharedDirectivesModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AutoCompleteModule, [{
        type: NgModule,
        args: [{
                declarations: [AUTOCOMPLETE_DIRECTIVES],
                exports: [AUTOCOMPLETE_DIRECTIVES, SharedDirectivesModule],
                imports: [SharedModule]
            }]
    }], null, null); })();

/* tslint:disable:object-literal-sort-keys */
const agentRxs = {
    wp: /(Windows Phone(?: OS)?)\s(\d+)\.(\d+(\.\d+)?)/,
    fire: /(Silk)\/(\d+)\.(\d+(\.\d+)?)/,
    android: /(Android|Android.*(?:Opera|Firefox).*?\/)\s*(\d+)\.(\d+(\.\d+)?)/,
    iphone: /(iPhone|iPod).*OS\s+(\d+)[\._]([\d\._]+)/,
    ipad: /(iPad).*OS\s+(\d+)[\._]([\d_]+)/,
    meego: /(MeeGo).+NokiaBrowser\/(\d+)\.([\d\._]+)/,
    webos: /(webOS)\/(\d+)\.(\d+(\.\d+)?)/,
    blackberry: /(BlackBerry|BB10).*?Version\/(\d+)\.(\d+(\.\d+)?)/,
    playbook: /(PlayBook).*?Tablet\s*OS\s*(\d+)\.(\d+(\.\d+)?)/,
    windows: /(MSIE)\s+(\d+)\.(\d+(\.\d+)?)/,
    tizen: /(tizen).*?Version\/(\d+)\.(\d+(\.\d+)?)/i,
    sailfish: /(sailfish).*rv:(\d+)\.(\d+(\.\d+)?).*firefox/i,
    ffos: /(Mobile).*rv:(\d+)\.(\d+(\.\d+)?).*Firefox/
};
const osRxs = {
    ios: /^i(phone|pad|pod)$/i,
    android: /^android|fire$/i,
    blackberry: /^blackberry|playbook/i,
    windows: /windows/,
    wp: /wp/,
    flat: /sailfish|ffos|tizen/i,
    meego: /meego/
};
const desktopBrowserRxs = {
    edge: /(edge)[ \/]([\w.]+)/i,
    webkit: /(chrome)[ \/]([\w.]+)/i,
    safari: /(webkit)[ \/]([\w.]+)/i,
    opera: /(opera)(?:.*version|)[ \/]([\w.]+)/i,
    msie: /(msie\s|trident.*? rv:)([\w.]+)/i,
    mozilla: /(mozilla)(?:.*? rv:([\w.]+)|)/i
};
const mobileBrowserRxs = {
    omini: /Opera\sMini/i,
    omobile: /Opera\sMobi/i,
    firefox: /Firefox|Fennec/i,
    mobilesafari: /version\/.*safari/i,
    ie: /MSIE|Windows\sPhone/i,
    chrome: /chrome|crios/i,
    webkit: /webkit/i
};
const testRx = (agent, rxs, dflt) => {
    for (let rx in rxs) {
        if (rxs.hasOwnProperty(rx) && rxs[rx].test(agent)) {
            return rx;
        }
    }
    return dflt !== undefined ? dflt : agent;
};
/**
 * @hidden
 */
const detectMobileOS = (ua) => {
    let minorVersion;
    let match = [];
    for (let agent in agentRxs) {
        if (agentRxs.hasOwnProperty(agent)) {
            match = ua.match(agentRxs[agent]);
            if (!match) {
                continue;
            }
            if (agent === 'windows' && 'plugins' in window.navigator) {
                return null;
            } // Break if not Metro/Mobile Windows
            const os = {};
            os.device = agent;
            os.browser = testRx(ua, mobileBrowserRxs, 'default');
            os.name = testRx(agent, osRxs);
            os[os.name] = true;
            os.majorVersion = match[2];
            os.minorVersion = match[3].replace('_', '.');
            minorVersion = os.minorVersion.replace('.', '').substr(0, 2);
            os.flatVersion = os.majorVersion + minorVersion +
                (new Array(3 - (minorVersion.length < 3 ? minorVersion.length : 2)).join('0'));
            os.cordova = typeof window.PhoneGap !== undefined
                || typeof window.cordova !== undefined; // Use file protocol to detect appModes.
            os.appMode = window.navigator.standalone
                || (/file|local|wmapp/).test(window.location.protocol)
                || os.cordova; // Use file protocol to detect appModes.
            return os;
        }
    }
    return null;
};
/**
 * @hidden
 */
const detectDesktopBrowser = (ua) => {
    let browserInfo = null;
    let match = [];
    for (let agent in desktopBrowserRxs) {
        if (desktopBrowserRxs.hasOwnProperty(agent)) {
            match = ua.match(desktopBrowserRxs[agent]);
            if (match) {
                browserInfo = {};
                browserInfo[agent] = true;
                browserInfo[match[1].toLowerCase().split(' ')[0].split('/')[0]] = true;
                browserInfo.version = parseInt(document.documentMode || match[2], 10);
                break;
            }
        }
    }
    return browserInfo;
};
const userAgent = isWindowAvailable() && window.navigator ? window.navigator.userAgent : null;
/**
 * @hidden
 */
const browser = userAgent ? detectDesktopBrowser(userAgent) : null;
/**
 * @hidden
 */
const mobileOS = userAgent ? detectMobileOS(userAgent) : null;
/**
 * @hidden
 */
const touch = isWindowAvailable() && 'ontouchstart' in window;
/**
 * @hidden
 */
const msPointers = browser && !browser.chrome && window.MSPointerEvent;
/**
 * @hidden
 */
const pointers = browser && !browser.chrome && window.PointerEvent;
/**
 * @hidden
 */
const touchEnabled = mobileOS && (touch || msPointers || pointers);

const COMBOBOX_DIRECTIVES = [
    ComboBoxComponent
];
const ɵ0$1 = touchEnabled;
/**
 * @hidden
 *
 * The exported package module.
 *
 * The package exports:
 * - `ComboBoxComponent`&mdash;The ComboBox component class.
 * - `ItemTemplateDirective`&mdash;The item template directive.
 * - `HeaderTemplateDirective`&mdash;The header template directive.
 * - `FooterTemplateDirective`&mdash;The footer template directive.
 */
class ComboBoxModule {
}
ComboBoxModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ComboBoxModule });
ComboBoxModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ComboBoxModule_Factory(t) { return new (t || ComboBoxModule)(); }, providers: [{ provide: TOUCH_ENABLED, useValue: ɵ0$1 }], imports: [[SharedModule],
        SharedDirectivesModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ComboBoxModule, { declarations: [ComboBoxComponent], imports: [SharedModule], exports: [ComboBoxComponent,
        SharedDirectivesModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ComboBoxModule, [{
        type: NgModule,
        args: [{
                declarations: [COMBOBOX_DIRECTIVES],
                exports: [COMBOBOX_DIRECTIVES, SharedDirectivesModule],
                imports: [SharedModule],
                providers: [{ provide: TOUCH_ENABLED, useValue: ɵ0$1 }]
            }]
    }], null, null); })();

/**
 * @hidden
 */
class FilterInputDirective {
    constructor(element, zone) {
        this.element = element;
        this.zone = zone;
    }
    ngOnChanges() {
        if (this.focused) {
            this.nextTick(() => this.element.nativeElement.focus());
        }
    }
    nextTick(fn) {
        this.zone.runOutsideAngular(() => setTimeout(fn));
    }
}
FilterInputDirective.ɵfac = function FilterInputDirective_Factory(t) { return new (t || FilterInputDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
FilterInputDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FilterInputDirective, selectors: [["", "filterInput", ""]], inputs: { focused: ["filterInput", "focused"] }, features: [ɵngcc0.ɵɵNgOnChangesFeature()] });
/** @nocollapse */
FilterInputDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
FilterInputDirective.propDecorators = {
    focused: [{ type: Input, args: ['filterInput',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FilterInputDirective, [{
        type: Directive,
        args: [{
                selector: '[filterInput]' // tslint:disable-line
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { focused: [{
            type: Input,
            args: ['filterInput']
        }] }); })();

const DROPDOWNLIST_DIRECTIVES = [
    DropDownListComponent,
    ValueTemplateDirective,
    FilterInputDirective
];
/**
 * @hidden
 *
 * The exported package module.
 *
 * The package exports:
 * - `DropDownListComponent`&mdash;The DropDownList component class.
 * - `ItemTemplateDirective`&mdash;The item template directive.
 * - `ValueTemplateDirective`&mdash;The value template directive.
 * - `HeaderTemplateDirective`&mdash;The header template directive.
 * - `FooterTemplateDirective`&mdash;The footer template directive.
 */
class DropDownListModule {
}
DropDownListModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: DropDownListModule });
DropDownListModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function DropDownListModule_Factory(t) { return new (t || DropDownListModule)(); }, imports: [[SharedModule],
        SharedDirectivesModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DropDownListModule, { declarations: [DropDownListComponent,
        ValueTemplateDirective,
        FilterInputDirective], imports: [SharedModule], exports: [DropDownListComponent,
        ValueTemplateDirective,
        FilterInputDirective,
        SharedDirectivesModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DropDownListModule, [{
        type: NgModule,
        args: [{
                declarations: [DROPDOWNLIST_DIRECTIVES],
                exports: [DROPDOWNLIST_DIRECTIVES, SharedDirectivesModule],
                imports: [SharedModule]
            }]
    }], null, null); })();

const MULTISELECT_DIRECTIVES = [
    MultiSelectComponent,
    TagListComponent,
    TagTemplateDirective,
    GroupTagTemplateDirective,
    SummaryTagDirective,
    CustomItemTemplateDirective
];
const ɵ0$2 = touchEnabled;
/**
 * @hidden
 *
 * The exported package module.
 *
 * The package exports:
 * - `MultiSelectComponent`&mdash;The MultiSelect component class.
 * - `SummaryTagDirective`&mdash;The MultiSelect summary tag directive.
 * - `ItemTemplateDirective`&mdash;The item template directive.
 * - `CustomItemTemplateDirective`&mdash;The custom item template directive.
 * - `TagTemplateDirective`&mdash;The tag template directive.
 * - `SummaryTagTemplateDirective`&mdash;The summary tag template directive.
 * - `HeaderTemplateDirective`&mdash;The header template directive.
 * - `FooterTemplateDirective`&mdash;The footer template directive.
 * - `NoDataTemplateDirective`&mdash;The no-data template directive.
 */
class MultiSelectModule {
}
MultiSelectModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MultiSelectModule });
MultiSelectModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MultiSelectModule_Factory(t) { return new (t || MultiSelectModule)(); }, providers: [{ provide: TOUCH_ENABLED, useValue: ɵ0$2 }], imports: [[SharedModule],
        SharedDirectivesModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MultiSelectModule, { declarations: [MultiSelectComponent,
        TagListComponent,
        TagTemplateDirective,
        GroupTagTemplateDirective,
        SummaryTagDirective,
        CustomItemTemplateDirective], imports: [SharedModule], exports: [MultiSelectComponent,
        TagListComponent,
        TagTemplateDirective,
        GroupTagTemplateDirective,
        SummaryTagDirective,
        CustomItemTemplateDirective,
        SharedDirectivesModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MultiSelectModule, [{
        type: NgModule,
        args: [{
                declarations: [MULTISELECT_DIRECTIVES],
                exports: [MULTISELECT_DIRECTIVES, SharedDirectivesModule],
                imports: [SharedModule],
                providers: [{ provide: TOUCH_ENABLED, useValue: ɵ0$2 }]
            }]
    }], null, null); })();

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Dropdowns components.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Dropdowns module
 * import { DropDownsModule } from '@progress/kendo-angular-dropdowns';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare the app component
 *     imports:      [BrowserModule, DropDownsModule], // import the Dropdowns module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class DropDownsModule {
}
DropDownsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: DropDownsModule });
DropDownsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function DropDownsModule_Factory(t) { return new (t || DropDownsModule)(); }, imports: [AutoCompleteModule,
        ComboBoxModule,
        DropDownListModule,
        MultiSelectModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DropDownsModule, { exports: [AutoCompleteModule,
        ComboBoxModule,
        DropDownListModule,
        MultiSelectModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DropDownsModule, [{
        type: NgModule,
        args: [{
                exports: [AutoCompleteModule, ComboBoxModule, DropDownListModule, MultiSelectModule]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { AUTOCOMPLETE_VALUE_ACCESSOR, COMBOBOX_VALUE_ACCESSOR, DataService, DisabledItemsService, DROPDOWNLIST_VALUE_ACCESSOR, FilterInputDirective, FilterableDropDownComponentBase, ListItemDirective, CustomMessagesComponent, LocalizedMessagesDirective, Messages, NavigationService, SearchBarComponent, SelectionService, browser, detectDesktopBrowser, detectMobileOS, mobileOS, msPointers, pointers, touch, touchEnabled, NoDataTemplateDirective, TagTemplateDirective, TOUCH_ENABLED, isWindowAvailable, AutoCompleteComponent, ComboBoxComponent, DropDownListComponent, MultiSelectComponent, TagListComponent, ItemTemplateDirective, GroupTemplateDirective, FixedGroupTemplateDirective, CustomItemTemplateDirective, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, TemplateContextDirective, GroupTagTemplateDirective, SelectableDirective, SummaryTagDirective, FilterDirective, DropDownsModule, MultiSelectModule, SharedModule, AutoCompleteModule, ComboBoxModule, DropDownListModule, SharedDirectivesModule, ListComponent, PreventableEvent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBV0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E0VUMsNEJBOEJDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQTJCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0NELDBRQUtDOzs7Ozs7Ozs7OzRFQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWlDRCxzUkFLQzs7Ozs7Ozs7Ozs0RUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQ0Qsc1JBS0M7Ozs7Ozs7Ozs7NEVBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXdDRCxnUkFLQzs7Ozs7Ozs7Ozs0RUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBd0NELDhTQUtDOzs7Ozs7Ozs7OzRFQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F3RkQ7OztnREFHQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBdVBEOzs7Z0RBR0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQ0QsMkhBR0M7Ozs7Ozs7cUVBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnSUQsa0hBR0M7Ozs7Ozs7OzBHQUtBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWlDRCxzUkFLQzs7Ozs7Ozs7Ozs0RUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMkNELDhJQUtDOzs7Ozs7Ozs7OzJFQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNk5ELG9EQW9HQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBK0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTJ1QkQsdUZBcUdDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFxREE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXVsQ0QsdUZBK0dDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkEwREE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQ0QsaUpBS0M7Ozs7Ozs7Ozs7NEVBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTA2QkQsNExBNkpDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBd0RBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQ0QsK0pBS0M7Ozs7Ozs7Ozs7NEVBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQ0QsMElBS0M7Ozs7Ozs7Ozs7NEVBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUNELHlKQUtDOzs7Ozs7Ozs7OzRFQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQThwQ0Qsa0ZBcUlDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBZ0VBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTRCRCw0SkF5Q0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQVlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCRCxzTEFLQzs7Ozs7Ozs7Ozs7Ozs7O29CQU9BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBZ0NELGdHQUtDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBWUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNkNELHNQQUtDOzs7Ozs7Ozs7Ozs7Ozs7O29CQU9BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQThFRCx1T0FLQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFTQTs7Ozs7Ozs7NEtBTUQ7Ozs7O3FFQUlDOzs7Ozs7Ozs7Ozs7Ozs7OztDQVVELGlEQWdCQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29GQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FjRCx3SkFZQzs7Ozs7Ozs7Ozs7Ozs7Ozs7b0ZBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXlCRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQU1DOzs7Ozs7Ozs7Ozs7Ozs7OztDQWFEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFPQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkQ7Ozs7Ozs7Ozs7MEJBT0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcUpEOzs7Ozs7Ozs7OzswQkFRQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkQsc05BS0M7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQVFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CRDs7Ozs7Ozs7Ozs7Ozs7MEJBT0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E0QkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFRQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0NEOzs7Ozs7Ozs7OzBCQUtDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogQ29weXJpZ2h0IMKpIDIwMjAgUHJvZ3Jlc3MgU29mdHdhcmUgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qIExpY2Vuc2VkIHVuZGVyIGNvbW1lcmNpYWwgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbW9yZSBpbmZvcm1hdGlvblxuKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBDb21wb25lbnQsIFJlbmRlcmVyMiwgSW5wdXQsIE91dHB1dCwgVmlld0NoaWxkLCBIb3N0QmluZGluZywgRGlyZWN0aXZlLCBUZW1wbGF0ZVJlZiwgSW5qZWN0YWJsZSwgRWxlbWVudFJlZiwgQ2hhbmdlRGV0ZWN0b3JSZWYsIE5nWm9uZSwgVmlld0NoaWxkcmVuLCBmb3J3YXJkUmVmLCBpc0Rldk1vZGUsIENvbnRlbnRDaGlsZCwgVmlld0NvbnRhaW5lclJlZiwgSW5qZWN0aW9uVG9rZW4sIE9wdGlvbmFsLCBJbmplY3QsIEtleVZhbHVlRGlmZmVycywgSG9zdExpc3RlbmVyLCBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgaXNEb2N1bWVudEF2YWlsYWJsZSwgaXNDaGFuZ2VkLCBLZW5kb0lucHV0LCBSZXNpemVTZW5zb3JNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1jb21tb24nO1xuaW1wb3J0IHsgTkdfVkFMVUVfQUNDRVNTT1IsIEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgTG9jYWxpemF0aW9uU2VydmljZSwgTDEwTl9QUkVGSVgsIENvbXBvbmVudE1lc3NhZ2VzIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItbDEwbic7XG5pbXBvcnQgeyBtZXJnZSwgZnJvbUV2ZW50LCBTdWJqZWN0LCBTdWJzY3JpcHRpb24sIG9mLCBpbnRlcnZhbCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwLCBhdWRpdFRpbWUsIHRhcCwgZmlsdGVyLCBwYXJ0aXRpb24sIHRocm90dGxlVGltZSwgY2F0Y2hFcnJvciwgZGlzdGluY3RVbnRpbENoYW5nZWQsIHNraXBXaGlsZSwgY29uY2F0TWFwLCB0YWtlLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBQb3B1cFNlcnZpY2UsIFBvcHVwTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItcG9wdXAnO1xuZXhwb3J0IHsgUG9wdXBDb21wb25lbnQgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1wb3B1cCc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xudmFyIEtleXM7XG4oZnVuY3Rpb24gKEtleXMpIHtcbiAgICBLZXlzW0tleXNbXCJiYWNrc3BhY2VcIl0gPSA4XSA9IFwiYmFja3NwYWNlXCI7XG4gICAgS2V5c1tLZXlzW1widGFiXCJdID0gOV0gPSBcInRhYlwiO1xuICAgIEtleXNbS2V5c1tcImVudGVyXCJdID0gMTNdID0gXCJlbnRlclwiO1xuICAgIEtleXNbS2V5c1tcInNoaWZ0XCJdID0gMTZdID0gXCJzaGlmdFwiO1xuICAgIEtleXNbS2V5c1tcImN0cmxcIl0gPSAxN10gPSBcImN0cmxcIjtcbiAgICBLZXlzW0tleXNbXCJhbHRcIl0gPSAxOF0gPSBcImFsdFwiO1xuICAgIEtleXNbS2V5c1tcInBhdXNlL2JyZWFrXCJdID0gMTldID0gXCJwYXVzZS9icmVha1wiO1xuICAgIEtleXNbS2V5c1tcImNhcHMgbG9ja1wiXSA9IDIwXSA9IFwiY2FwcyBsb2NrXCI7XG4gICAgS2V5c1tLZXlzW1wiZXNjXCJdID0gMjddID0gXCJlc2NcIjtcbiAgICBLZXlzW0tleXNbXCJzcGFjZVwiXSA9IDMyXSA9IFwic3BhY2VcIjtcbiAgICBLZXlzW0tleXNbXCJwYWdlIHVwXCJdID0gMzNdID0gXCJwYWdlIHVwXCI7XG4gICAgS2V5c1tLZXlzW1wicGFnZSBkb3duXCJdID0gMzRdID0gXCJwYWdlIGRvd25cIjtcbiAgICBLZXlzW0tleXNbXCJlbmRcIl0gPSAzNV0gPSBcImVuZFwiO1xuICAgIEtleXNbS2V5c1tcImhvbWVcIl0gPSAzNl0gPSBcImhvbWVcIjtcbiAgICBLZXlzW0tleXNbXCJsZWZ0XCJdID0gMzddID0gXCJsZWZ0XCI7XG4gICAgS2V5c1tLZXlzW1widXBcIl0gPSAzOF0gPSBcInVwXCI7XG4gICAgS2V5c1tLZXlzW1wicmlnaHRcIl0gPSAzOV0gPSBcInJpZ2h0XCI7XG4gICAgS2V5c1tLZXlzW1wiZG93blwiXSA9IDQwXSA9IFwiZG93blwiO1xuICAgIEtleXNbS2V5c1tcImluc2VydFwiXSA9IDQ1XSA9IFwiaW5zZXJ0XCI7XG4gICAgS2V5c1tLZXlzW1wiZGVsZXRlXCJdID0gNDZdID0gXCJkZWxldGVcIjtcbiAgICBLZXlzW0tleXNbXCJjb21tYW5kXCJdID0gOTFdID0gXCJjb21tYW5kXCI7XG4gICAgS2V5c1tLZXlzW1wibGVmdCBjb21tYW5kXCJdID0gOTFdID0gXCJsZWZ0IGNvbW1hbmRcIjtcbiAgICBLZXlzW0tleXNbXCJyaWdodCBjb21tYW5kXCJdID0gOTNdID0gXCJyaWdodCBjb21tYW5kXCI7XG4gICAgS2V5c1tLZXlzW1wibnVtcGFkICpcIl0gPSAxMDZdID0gXCJudW1wYWQgKlwiO1xuICAgIEtleXNbS2V5c1tcIm51bXBhZCArXCJdID0gMTA3XSA9IFwibnVtcGFkICtcIjtcbiAgICBLZXlzW0tleXNbXCJudW1wYWQgLVwiXSA9IDEwOV0gPSBcIm51bXBhZCAtXCI7XG4gICAgS2V5c1tLZXlzW1wibnVtcGFkIC5cIl0gPSAxMTBdID0gXCJudW1wYWQgLlwiO1xuICAgIEtleXNbS2V5c1tcIm51bXBhZCAvXCJdID0gMTExXSA9IFwibnVtcGFkIC9cIjtcbiAgICBLZXlzW0tleXNbXCJudW0gbG9ja1wiXSA9IDE0NF0gPSBcIm51bSBsb2NrXCI7XG4gICAgS2V5c1tLZXlzW1wic2Nyb2xsIGxvY2tcIl0gPSAxNDVdID0gXCJzY3JvbGwgbG9ja1wiO1xuICAgIEtleXNbS2V5c1tcIm15IGNvbXB1dGVyXCJdID0gMTgyXSA9IFwibXkgY29tcHV0ZXJcIjtcbiAgICBLZXlzW0tleXNbXCJteSBjYWxjdWxhdG9yXCJdID0gMTgzXSA9IFwibXkgY2FsY3VsYXRvclwiO1xuICAgIEtleXNbS2V5c1tcIjtcIl0gPSAxODZdID0gXCI7XCI7XG4gICAgS2V5c1tLZXlzW1wiPVwiXSA9IDE4N10gPSBcIj1cIjtcbiAgICBLZXlzW0tleXNbXCIsXCJdID0gMTg4XSA9IFwiLFwiO1xuICAgIEtleXNbS2V5c1tcIi1cIl0gPSAxODldID0gXCItXCI7XG4gICAgS2V5c1tLZXlzW1wiLlwiXSA9IDE5MF0gPSBcIi5cIjtcbiAgICBLZXlzW0tleXNbXCIvXCJdID0gMTkxXSA9IFwiL1wiO1xuICAgIEtleXNbS2V5c1tcImBcIl0gPSAxOTJdID0gXCJgXCI7XG4gICAgS2V5c1tLZXlzW1wiW1wiXSA9IDIxOV0gPSBcIltcIjtcbiAgICBLZXlzW0tleXNbXCJcXFxcXCJdID0gMjIwXSA9IFwiXFxcXFwiO1xuICAgIEtleXNbS2V5c1tcIl1cIl0gPSAyMjFdID0gXCJdXCI7XG4gICAgS2V5c1tLZXlzW1wiJ1wiXSA9IDIyMl0gPSBcIidcIjtcbn0pKEtleXMgfHwgKEtleXMgPSB7fSkpO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby1udWxsLWtleXdvcmQgKi9cbi8qIHRzbGludDpkaXNhYmxlOm5vLWJpdHdpc2UgKi9cbi8qIHRzbGludDpkaXNhYmxlOmFsaWduICovXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNQcmVzZW50ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzTnVtYmVyID0gKHZhbHVlKSA9PiAhaXNOYU4odmFsdWUpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGd1aWQgPSAoKSA9PiB7XG4gICAgbGV0IGlkID0gXCJcIjtcbiAgICBsZXQgaTtcbiAgICBsZXQgcmFuZG9tO1xuICAgIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICAgIHJhbmRvbSA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7XG4gICAgICAgIGlmIChpID09PSA4IHx8IGkgPT09IDEyIHx8IGkgPT09IDE2IHx8IGkgPT09IDIwKSB7XG4gICAgICAgICAgICBpZCArPSBcIi1cIjtcbiAgICAgICAgfVxuICAgICAgICBpZCArPSAoaSA9PT0gMTIgPyA0IDogKGkgPT09IDE2ID8gKHJhbmRvbSAmIDMgfCA4KSA6IHJhbmRvbSkpLnRvU3RyaW5nKDE2KTtcbiAgICB9XG4gICAgcmV0dXJuIGlkO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjb21iaW5lU3RyID0gKGJlZ2luLCBlbmQpID0+IHtcbiAgICByZXR1cm4gYmVnaW4uY29uY2F0KGVuZC5zdWJzdHIoZW5kLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihiZWdpbi50b0xvd2VyQ2FzZSgpKSArIGJlZ2luLmxlbmd0aCkpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc1dpbmRvd0F2YWlsYWJsZSA9ICgpID0+IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzQXJyYXkgPSAodmFsdWUpID0+IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzT2JqZWN0ID0gKHZhbHVlKSA9PiBpc1ByZXNlbnQodmFsdWUpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNFbXB0eVN0cmluZyA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5sZW5ndGggPT09IDA7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgcmVzb2x2ZVZhbHVlc0luQXJyYXkgPSAodmFsdWVzLCBkYXRhID0gW10sIHZhbHVlRmllbGQpID0+IHZhbHVlc1xuICAgIC5tYXAodmFsdWUgPT4ge1xuICAgIHJldHVybiBkYXRhLmZpbmQoaXRlbSA9PiBpdGVtW3ZhbHVlRmllbGRdID09PSB2YWx1ZSk7XG59KVxuICAgIC5maWx0ZXIodmFsdWUgPT4gdmFsdWUgIT09IHVuZGVmaW5lZCk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgdmFsaWRhdGVDb21wbGV4VmFsdWVzID0gKHZhbHVlcywgdmFsdWVGaWVsZCkgPT4gaXNBcnJheSh2YWx1ZXMpICYmIHZhbHVlcy5maWx0ZXIoaXRlbSA9PiB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0ZW0pICYmIGl0ZW1bdmFsdWVGaWVsZF07XG59KTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCByZXNvbHZlQWxsVmFsdWVzID0gKHZhbHVlLCBkYXRhLCB2YWx1ZUZpZWxkKSA9PiB7XG4gICAgY29uc3QgY3VzdG9tVmFsdWVzID0gdmFsaWRhdGVDb21wbGV4VmFsdWVzKHZhbHVlLCB2YWx1ZUZpZWxkKSB8fCBbXTtcbiAgICBjb25zdCByZXNvbHZlZFZhbHVlcyA9IHJlc29sdmVWYWx1ZXNJbkFycmF5KHZhbHVlLCBkYXRhLCB2YWx1ZUZpZWxkKSB8fCBbXTtcbiAgICByZXR1cm4gcmVzb2x2ZWRWYWx1ZXMuY29uY2F0KGN1c3RvbVZhbHVlcyk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzT2JqZWN0QXJyYXkgPSAodmFsdWVzKSA9PiB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWVzKSAmJiB2YWx1ZXMuZXZlcnkoaXRlbSA9PiBpc09iamVjdChpdGVtKSk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHNlbGVjdGVkSW5kaWNlcyA9ICh2YWx1ZXMsIGRhdGEsIHZhbHVlRmllbGQpID0+IHtcbiAgICBjb25zdCBleHRyYWN0ZWRWYWx1ZXMgPSBkYXRhLm1hcChpdGVtID0+IHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudChpdGVtKSAmJiBpc1ByZXNlbnQoaXRlbVt2YWx1ZUZpZWxkXSkgPyBpdGVtW3ZhbHVlRmllbGRdIDogaXRlbTtcbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWVzLnJlZHVjZSgoYXJyLCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXNQcmVzZW50KGl0ZW0pICYmIGlzUHJlc2VudChpdGVtW3ZhbHVlRmllbGRdKSA/IGl0ZW1bdmFsdWVGaWVsZF0gOiBpdGVtO1xuICAgICAgICBjb25zdCBpbmRleCA9IGV4dHJhY3RlZFZhbHVlcy5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgYXJyLnB1c2goaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSwgW10pO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBnZXR0ZXIgPSAoZGF0YUl0ZW0sIGZpZWxkLCB1c2VQcmltaXRpdmUgPSBmYWxzZSkgPT4ge1xuICAgIGlmIChpc1ByZXNlbnQoZGF0YUl0ZW0pKSB7XG4gICAgICAgIGlmICh1c2VQcmltaXRpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZCAmJiBpc1ByZXNlbnQoZGF0YUl0ZW1bZmllbGRdKSA/IGRhdGFJdGVtW2ZpZWxkXSA6IGRhdGFJdGVtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkID8gZGF0YUl0ZW1bZmllbGRdIDogZGF0YUl0ZW07XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHNhbWVDaGFyc09ubHkgPSAod29yZCwgY2hhcmFjdGVyKSA9PiB7XG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgd29yZC5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGlmICh3b3JkLmNoYXJBdChpZHgpICE9PSBjaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgc2h1ZmZsZURhdGEgPSAoZGF0YSwgc3BsaXRJbmRleCwgZGVmYXVsdEl0ZW0pID0+IHtcbiAgICBsZXQgcmVzdWx0ID0gZGF0YTtcbiAgICBpZiAoZGVmYXVsdEl0ZW0pIHtcbiAgICAgICAgcmVzdWx0ID0gW2RlZmF1bHRJdGVtXS5jb25jYXQocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5zbGljZShzcGxpdEluZGV4KS5jb25jYXQocmVzdWx0LnNsaWNlKDAsIHNwbGl0SW5kZXgpKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbWF0Y2hUZXh0ID0gKHRleHQsIHdvcmQsIGlnbm9yZUNhc2UpID0+IHtcbiAgICBpZiAoIWlzUHJlc2VudCh0ZXh0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCB0ZW1wID0gU3RyaW5nKHRleHQpO1xuICAgIGlmIChpZ25vcmVDYXNlKSB7XG4gICAgICAgIHRlbXAgPSB0ZW1wLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiB0ZW1wLmluZGV4T2Yod29yZCkgPT09IDA7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHBhc3NlZCBvYmplY3QgaGFzIGFsbCBvZiB0aGUgbGlzdGVkIHByb3BlcnRpZXMuXG4gKi9cbmNvbnN0IGhhc1Byb3BzID0gKG9iaiwgcHJvcHMpID0+IHtcbiAgICBpZiAoIWlzUHJlc2VudChvYmopKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BzLmV2ZXJ5KHByb3AgPT4gb2JqLmhhc093blByb3BlcnR5KHByb3ApKTtcbn07XG5cbi8qIHRzbGludDpkaXNhYmxlOm1lbWJlci1vcmRlcmluZyAqL1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNlYXJjaEJhckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uLCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbkJsdXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25Gb2N1cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbkNsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uTmF2aWdhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuc2VhcmNoQmFyQ2xhc3MgPSB0cnVlO1xuICAgICAgICB0aGlzLl91c2VySW5wdXQgPSBcIlwiO1xuICAgICAgICB0aGlzLl9wcmV2aW91c1ZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXIgPSBcIlwiO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IGxvY2FsaXphdGlvbi5ydGwgPyAncnRsJyA6ICdsdHInO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgfVxuICAgIGdldCB1c2VySW5wdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91c2VySW5wdXQ7XG4gICAgfVxuICAgIHNldCB1c2VySW5wdXQodXNlcklucHV0KSB7XG4gICAgICAgIHRoaXMuX3VzZXJJbnB1dCA9IHVzZXJJbnB1dCB8fCBcIlwiO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0Lm5hdGl2ZUVsZW1lbnQudmFsdWU7XG4gICAgfVxuICAgIHNldCBwbGFjZWhvbGRlcih0ZXh0KSB7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyID0gdGV4dCB8fCAnJztcbiAgICAgICAgdGhpcy5zZXRJbnB1dFNpemUoKTtcbiAgICB9XG4gICAgZ2V0IHBsYWNlaG9sZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGxhY2Vob2xkZXI7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbkNoYW5nZVN1YnNjcmlwdGlvbiA9IHRoaXMubG9jYWxpemF0aW9uXG4gICAgICAgICAgICAuY2hhbmdlcy5zdWJzY3JpYmUoKHsgcnRsIH0pID0+IHRoaXMuZGlyZWN0aW9uID0gcnRsID8gJ3J0bCcgOiAnbHRyJyk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgbGV0IHByZXZpb3VzVXNlcklucHV0O1xuICAgICAgICBpZiAodGhpcy5pbnB1dCAmJiAoY2hhbmdlcy51c2VySW5wdXQgfHwgY2hhbmdlcy5zdWdnZXN0ZWRUZXh0KSkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMudXNlcklucHV0ICYmIGNoYW5nZXMudXNlcklucHV0LnByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcHJldmlvdXNWYWx1ZSA9PT0gY2hhbmdlcy51c2VySW5wdXQucHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1VzZXJJbnB1dCA9IHRoaXMuX3ByZXZpb3VzVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1VzZXJJbnB1dCA9IGNoYW5nZXMudXNlcklucHV0LmN1cnJlbnRWYWx1ZSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzVXNlcklucHV0ID0gdGhpcy5fcHJldmlvdXNWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhcmV0SW5kZXggPSB0aGlzLmlucHV0Lm5hdGl2ZUVsZW1lbnQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgICBjb25zdCBjYXJldEF0RW5kID0gcHJldmlvdXNVc2VySW5wdXQubGVuZ3RoID09PSBjYXJldEluZGV4O1xuICAgICAgICAgICAgdGhpcy53cml0ZUlucHV0VmFsdWUodGhpcy5zdWdnZXN0ZWRUZXh0ID8gY29tYmluZVN0cih0aGlzLnVzZXJJbnB1dCwgdGhpcy5zdWdnZXN0ZWRUZXh0KSA6IHRoaXMudXNlcklucHV0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1Z2dlc3RlZFRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldElucHV0U2VsZWN0aW9uKHRoaXMudXNlcklucHV0Lmxlbmd0aCwgdGhpcy5zdWdnZXN0ZWRUZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjYXJldEF0RW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbnB1dFNlbGVjdGlvbih0aGlzLnVzZXJJbnB1dC5sZW5ndGgsIHRoaXMudXNlcklucHV0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldElucHV0U2VsZWN0aW9uKGNhcmV0SW5kZXgsIGNhcmV0SW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNWYWx1ZSA9IHRoaXMudXNlcklucHV0O1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5sb2NhbGl6YXRpb25DaGFuZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxpemF0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVJbnB1dFZhbHVlKHRleHQpIHtcbiAgICAgICAgaWYgKGlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLmlucHV0Lm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIHRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldElucHV0U2VsZWN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKGlzRG9jdW1lbnRBdmFpbGFibGUoKSAmJiB0aGlzLmlucHV0Lm5hdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5uYXRpdmVFbGVtZW50LnNldFNlbGVjdGlvblJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvL01ha2Ugc3VyZSB0aGF0IHRoZSBlbGVtZW50IGlzIGluIHRoZSBET00gYmVmb3JlIHlvdSBpbnZva2UgaXRzIG1ldGhvZHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVJbnB1dChldmVudCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLnVzZXJJbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVGb2N1cyhldmVudCkge1xuICAgICAgICB0aGlzLm9uRm9jdXMuZW1pdChldmVudCk7XG4gICAgfVxuICAgIGhhbmRsZUJsdXIoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5vbkJsdXIuZW1pdChldmVudCk7XG4gICAgfVxuICAgIGhhbmRsZUtleWRvd24oZXZlbnQpIHtcbiAgICAgICAgY29uc3Qga2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbS2V5cy51cCwgS2V5cy5kb3duLCBLZXlzLmxlZnQsIEtleXMucmlnaHQsIEtleXMuZW50ZXIsXG4gICAgICAgICAgICBLZXlzLmVzYywgS2V5cy5kZWxldGUsIEtleXMuYmFja3NwYWNlLCBLZXlzLmhvbWUsIEtleXMuZW5kXTtcbiAgICAgICAgaWYgKGtleXMuaW5kZXhPZihrZXlDb2RlKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLm9uTmF2aWdhdGUuZW1pdChldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9jdXMoKSB7XG4gICAgICAgIGlmIChpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJsdXIoKSB7XG4gICAgICAgIGlmIChpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQubmF0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0SW5wdXRTaXplKCkge1xuICAgICAgICBjb25zdCBsZW5ndGhPZiA9IHggPT4geCA/IHgubGVuZ3RoIDogMDtcbiAgICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLmlucHV0Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyTGVuZ3RoID0gbGVuZ3RoT2YodGhpcy5wbGFjZWhvbGRlcik7XG4gICAgICAgIGNvbnN0IHRleHRMZW5ndGggPSBsZW5ndGhPZih0aGlzLnZhbHVlKTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgubWF4KHBsYWNlaG9sZGVyTGVuZ3RoLCB0ZXh0TGVuZ3RoLCAxKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUoaW5wdXQsICdzaXplJywgc2l6ZS50b1N0cmluZygpKTtcbiAgICB9XG59XG5TZWFyY2hCYXJDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXNlYXJjaGJhcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGlucHV0ICNpbnB1dFxuICAgICAgICAgICAgYXV0b2NvbXBsZXRlPVwib2ZmXCJcbiAgICAgICAgICAgIFtpZF09XCJpZFwiXG4gICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgW3JlYWRvbmx5XT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgIFtwbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiXG4gICAgICAgICAgICBbY2xhc3NdPVwiJ2staW5wdXQnXCJcbiAgICAgICAgICAgIChpbnB1dCk9XCJoYW5kbGVJbnB1dCgkZXZlbnQpXCJcbiAgICAgICAgICAgIChmb2N1cyk9XCJoYW5kbGVGb2N1cygkZXZlbnQpXCJcbiAgICAgICAgICAgIChibHVyKT1cImhhbmRsZUJsdXIoJGV2ZW50KVwiXG4gICAgICAgICAgICAoa2V5ZG93bik9XCJoYW5kbGVLZXlkb3duKCRldmVudClcIlxuICAgICAgICAgICAgW2F0dHIudGFiSW5kZXhdPVwidGFiSW5kZXhcIlxuICAgICAgICAgICAgW2F0dHIuZGlyXT1cImRpcmVjdGlvblwiXG4gICAgICAgICAgICBbYXR0ci5yb2xlXT1cInJvbGVcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1kaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLXJlYWRvbmx5XT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgIGFyaWEtaGFzcG9wdXA9XCJsaXN0Ym94XCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtZXhwYW5kZWRdPVwicG9wdXBPcGVuXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtb3duc109XCJsaXN0SWRcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1kZXNjcmliZWRieV09XCJ0YWdMaXN0SWRcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1hY3RpdmVkZXNjZW5kYW50XT1cImFjdGl2ZURlc2NlbmRhbnRcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJub0RhdGFMYWJlbFwiXG4gICAgICAgIC8+XG4gICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblNlYXJjaEJhckNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9XG5dO1xuU2VhcmNoQmFyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGlkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBsaXN0SWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRhZ0xpc3RJZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYWN0aXZlRGVzY2VuZGFudDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbm9EYXRhTGFiZWw6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRpc2FibGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICByZWFkb25seTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGFiSW5kZXg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBvcHVwT3BlbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcm9sZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdXNlcklucHV0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzdWdnZXN0ZWRUZXh0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB2YWx1ZUNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIG9uQmx1cjogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIG9uRm9jdXM6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBvbkNsaWNrOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgb25OYXZpZ2F0ZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGlucHV0OiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFtcImlucHV0XCIsIHsgc3RhdGljOiB0cnVlIH0sXSB9XSxcbiAgICBzZWFyY2hCYXJDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1zZWFyY2hiYXInLF0gfV0sXG4gICAgcGxhY2Vob2xkZXI6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUmVuZGVycyB0aGUgbGlzdCBpdGVtIGNvbnRlbnQuIFRvIGRlZmluZSB0aGUgaXRlbSB0ZW1wbGF0ZSwgbmVzdCBhbiBgPG5nLXRlbXBsYXRlPmAgdGFnXG4gKiB3aXRoIHRoZSBga2VuZG88Q29tcG9uZW50TmFtZT5JdGVtVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgdGhlIGNvbXBvbmVudCB0YWcuIFRoZSB0ZW1wbGF0ZSBjb250ZXh0IGlzXG4gKiBzZXQgdG8gdGhlIGN1cnJlbnQgY29tcG9uZW50LiBUbyBnZXQgYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZGF0YSBpdGVtLCB1c2UgdGhlIGBsZXQtZGF0YUl0ZW1gIGRpcmVjdGl2ZS5cbiAqXG4gKiAtIFtVc2luZyBgSXRlbVRlbXBsYXRlYCB3aXRoIHRoZSBBdXRvQ29tcGxldGVdKHslIHNsdWcgdGVtcGxhdGVzX2F1dG9jb21wbGV0ZSAlfSN0b2MtaXRlbS10ZW1wbGF0ZSlcbiAqIC0gW1VzaW5nIGBJdGVtVGVtcGxhdGVgIHdpdGggdGhlIENvbWJvQm94XSh7JSBzbHVnIHRlbXBsYXRlc19jb21ib2JveCAlfSN0b2MtaXRlbS10ZW1wbGF0ZSlcbiAqIC0gW1VzaW5nIGBJdGVtVGVtcGxhdGVgIHdpdGggdGhlIERyb3BEb3duTGlzdF0oeyUgc2x1ZyB0ZW1wbGF0ZXNfZGRsICV9I3RvYy1pdGVtLXRlbXBsYXRlKVxuICogLSBbVXNpbmcgYEl0ZW1UZW1wbGF0ZWAgd2l0aCB0aGUgTXVsdGlTZWxlY3RdKHslIHNsdWcgdGVtcGxhdGVzX211bHRpc2VsZWN0ICV9I3RvYy1pdGVtLXRlbXBsYXRlKVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogX0BDb21wb25lbnQoe1xuICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICogdGVtcGxhdGU6IGBcbiAqICA8a2VuZG8tY29tYm9ib3ggW2RhdGFdPVwibGlzdEl0ZW1zXCI+XG4gKiAgICA8bmctdGVtcGxhdGUga2VuZG9Db21ib0JveEl0ZW1UZW1wbGF0ZSBsZXQtZGF0YUl0ZW0+XG4gKiAgICAgIDxzcGFuPnt7ZGF0YUl0ZW19fSBvcHRpb248L3NwYW4+XG4gKiAgICA8L25nLXRlbXBsYXRlPlxuICogIDwva2VuZG8tY29tYm9ib3g+XG4gKiBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgcHVibGljIGxpc3RJdGVtczogQXJyYXk8c3RyaW5nPiA9IFtcIkl0ZW0gMVwiLCBcIkl0ZW0gMlwiLCBcIkl0ZW0gM1wiLCBcIkl0ZW0gNFwiXTtcbiAqIH1cbiAqIGBgYFxuICovXG5jbGFzcyBJdGVtVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59XG5JdGVtVGVtcGxhdGVEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0Ryb3BEb3duTGlzdEl0ZW1UZW1wbGF0ZV0sW2tlbmRvQ29tYm9Cb3hJdGVtVGVtcGxhdGVdLFtrZW5kb0F1dG9Db21wbGV0ZUl0ZW1UZW1wbGF0ZV0sW2tlbmRvTXVsdGlTZWxlY3RJdGVtVGVtcGxhdGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5JdGVtVGVtcGxhdGVEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiB9XG5dO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUmVuZGVycyB0aGUgaGVhZGVyIGNvbnRlbnQgb2YgdGhlIGxpc3QuIFRvIGRlZmluZSB0aGUgaGVhZGVyIHRlbXBsYXRlLCBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YCB0YWdcbiAqIHdpdGggdGhlIGBrZW5kbzxDb21wb25lbnROYW1lPkhlYWRlclRlbXBsYXRlYCBkaXJlY3RpdmUgaW5zaWRlIHRoZSBjb21wb25lbnQgdGFnLlxuICpcbiAqIC0gW1VzaW5nIGBIZWFkZXJUZW1wbGF0ZWAgd2l0aCB0aGUgQXV0b0NvbXBsZXRlXSh7JSBzbHVnIHRlbXBsYXRlc19hdXRvY29tcGxldGUgJX0jdG9jLWhlYWRlci10ZW1wbGF0ZSlcbiAqIC0gW1VzaW5nIGBIZWFkZXJUZW1wbGF0ZWAgd2l0aCB0aGUgQ29tYm9Cb3hdKHslIHNsdWcgdGVtcGxhdGVzX2NvbWJvYm94ICV9I3RvYy1oZWFkZXItdGVtcGxhdGUpXG4gKiAtIFtVc2luZyBgSGVhZGVyVGVtcGxhdGVgIHdpdGggdGhlIERyb3BEb3duTGlzdF0oeyUgc2x1ZyB0ZW1wbGF0ZXNfZGRsICV9I3RvYy1oZWFkZXItdGVtcGxhdGUpXG4gKiAtIFtVc2luZyBgSGVhZGVyVGVtcGxhdGVgIHdpdGggdGhlIE11bHRpU2VsZWN0XSh7JSBzbHVnIHRlbXBsYXRlc19tdWx0aXNlbGVjdCAlfSN0b2MtaGVhZGVyLXRlbXBsYXRlKVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogX0BDb21wb25lbnQoe1xuICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICogdGVtcGxhdGU6IGBcbiAqICA8a2VuZG8tY29tYm9ib3ggW2RhdGFdPVwibGlzdEl0ZW1zXCI+XG4gKiAgICA8bmctdGVtcGxhdGUga2VuZG9Db21ib0JveEhlYWRlclRlbXBsYXRlPlxuICogICAgICA8aDQ+SGVhZGVyIHRlbXBsYXRlPC9oND5cbiAqICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgPC9rZW5kby1jb21ib2JveD5cbiAqIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICBwdWJsaWMgbGlzdEl0ZW1zOiBBcnJheTxzdHJpbmc+ID0gW1wiSXRlbSAxXCIsIFwiSXRlbSAyXCIsIFwiSXRlbSAzXCIsIFwiSXRlbSA0XCJdO1xuICogfVxuICogYGBgXG4gKi9cbmNsYXNzIEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufVxuSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0Ryb3BEb3duTGlzdEhlYWRlclRlbXBsYXRlXSxba2VuZG9Db21ib0JveEhlYWRlclRlbXBsYXRlXSxba2VuZG9BdXRvQ29tcGxldGVIZWFkZXJUZW1wbGF0ZV0sW2tlbmRvTXVsdGlTZWxlY3RIZWFkZXJUZW1wbGF0ZV0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkhlYWRlclRlbXBsYXRlRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogVGVtcGxhdGVSZWYgfVxuXTtcblxuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFJlbmRlcnMgdGhlIGZvb3RlciBjb250ZW50IG9mIHRoZSBsaXN0LiBUbyBkZWZpbmUgdGhlIGZvb3RlciB0ZW1wbGF0ZSwgbmVzdCBhbiBgPG5nLXRlbXBsYXRlPmAgdGFnXG4gKiB3aXRoIHRoZSBga2VuZG88Q29tcG9uZW50TmFtZT5Gb290ZXJUZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZSB0aGUgY29tcG9uZW50IHRhZy5cbiAqXG4gKiAtIFtVc2luZyBgRm9vdGVyVGVtcGxhdGVgIHdpdGggdGhlIEF1dG9Db21wbGV0ZV0oeyUgc2x1ZyB0ZW1wbGF0ZXNfYXV0b2NvbXBsZXRlICV9I3RvYy1mb290ZXItdGVtcGxhdGUpXG4gKiAtIFtVc2luZyBgRm9vdGVyVGVtcGxhdGVgIHdpdGggdGhlIENvbWJvQm94XSh7JSBzbHVnIHRlbXBsYXRlc19jb21ib2JveCAlfSN0b2MtZm9vdGVyLXRlbXBsYXRlKVxuICogLSBbVXNpbmcgYEZvb3RlclRlbXBsYXRlYCB3aXRoIHRoZSBEcm9wRG93bkxpc3RdKHslIHNsdWcgdGVtcGxhdGVzX2RkbCAlfSN0b2MtZm9vdGVyLXRlbXBsYXRlKVxuICogLSBbVXNpbmcgYEZvb3RlclRlbXBsYXRlYCB3aXRoIHRoZSBNdWx0aVNlbGVjdF0oeyUgc2x1ZyB0ZW1wbGF0ZXNfbXVsdGlzZWxlY3QgJX0jdG9jLWZvb3Rlci10ZW1wbGF0ZSlcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIF9AQ29tcG9uZW50KHtcbiAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqIHRlbXBsYXRlOiBgXG4gKiAgPGtlbmRvLWNvbWJvYm94IFtkYXRhXT1cImxpc3RJdGVtc1wiPlxuICogICAgPG5nLXRlbXBsYXRlIGtlbmRvQ29tYm9Cb3hGb290ZXJUZW1wbGF0ZT5cbiAqICAgICAgPGg0PkZvb3RlciB0ZW1wbGF0ZTwvaDQ+XG4gKiAgICA8L25nLXRlbXBsYXRlPlxuICogIDwva2VuZG8tY29tYm9ib3g+XG4gKiBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgcHVibGljIGxpc3RJdGVtczogQXJyYXk8c3RyaW5nPiA9IFtcIkl0ZW0gMVwiLCBcIkl0ZW0gMlwiLCBcIkl0ZW0gM1wiLCBcIkl0ZW0gNFwiXTtcbiAqIH1cbiAqIGBgYFxuICovXG5jbGFzcyBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn1cbkZvb3RlclRlbXBsYXRlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9Ecm9wRG93bkxpc3RGb290ZXJUZW1wbGF0ZV0sW2tlbmRvQ29tYm9Cb3hGb290ZXJUZW1wbGF0ZV0sW2tlbmRvQXV0b0NvbXBsZXRlRm9vdGVyVGVtcGxhdGVdLFtrZW5kb011bHRpU2VsZWN0Rm9vdGVyVGVtcGxhdGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Gb290ZXJUZW1wbGF0ZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmIH1cbl07XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBSZW5kZXJzIHRoZSBncm91cCBoZWFkZXIgY29udGVudC4gVG8gZGVmaW5lIHRoZSBncm91cCB0ZW1wbGF0ZSwgbmVzdCBhbiBgPG5nLXRlbXBsYXRlPmAgdGFnXG4gKiB3aXRoIHRoZSBga2VuZG88Q29tcG9uZW50TmFtZT5Hcm91cFRlbXBsYXRlYCBkaXJlY3RpdmUgaW5zaWRlIHRoZSBjb21wb25lbnQgdGFnLiBUaGUgdGVtcGxhdGUgY29udGV4dCBpc1xuICogc2V0IHRvIHRoZSBjdXJyZW50IGNvbXBvbmVudC4gVG8gZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGRhdGEgaXRlbSwgdXNlIHRoZSBgbGV0LWdyb3VwTmFtZWAgZGlyZWN0aXZlLlxuICpcbiAqIC0gW1VzaW5nIGBHcm91cFRlbXBsYXRlYCB3aXRoIHRoZSBBdXRvQ29tcGxldGVdKHslIHNsdWcgdGVtcGxhdGVzX2F1dG9jb21wbGV0ZSAlfSN0b2MtZ3JvdXAtdGVtcGxhdGUpXG4gKiAtIFtVc2luZyBgR3JvdXBUZW1wbGF0ZWAgd2l0aCB0aGUgQ29tYm9Cb3hdKHslIHNsdWcgdGVtcGxhdGVzX2NvbWJvYm94ICV9I3RvYy1ncm91cC10ZW1wbGF0ZSlcbiAqIC0gW1VzaW5nIGBHcm91cFRlbXBsYXRlYCB3aXRoIHRoZSBEcm9wRG93bkxpc3RdKHslIHNsdWcgdGVtcGxhdGVzX2RkbCAlfSN0b2MtZ3JvdXAtdGVtcGxhdGUpXG4gKiAtIFtVc2luZyBgR3JvdXBUZW1wbGF0ZWAgd2l0aCB0aGUgTXVsdGlTZWxlY3RdKHslIHNsdWcgdGVtcGxhdGVzX211bHRpc2VsZWN0ICV9I3RvYy1ncm91cC10ZW1wbGF0ZSlcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGdyb3VwQnkgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tZGF0YS1xdWVyeSc7XG4gKiBfQENvbXBvbmVudCh7XG4gKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiB0ZW1wbGF0ZTogYFxuICogIDxrZW5kby1jb21ib2JveCBbZGF0YV09XCJncm91cGVkRGF0YVwiIFt0ZXh0RmllbGRdPVwiJ25hbWUnXCIgW3ZhbHVlRmllbGRdPVwiJ25hbWUnXCI+XG4gKiAgICA8bmctdGVtcGxhdGUga2VuZG9Db21ib0JveEdyb3VwVGVtcGxhdGUgbGV0LWdyb3VwTmFtZT5cbiAqICAgICAgPHNwYW4+Rm9vZCB0eXBlOiB7e2dyb3VwTmFtZX19IG9wdGlvbjwvc3Bhbj5cbiAqICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgPC9rZW5kby1jb21ib2JveD5cbiAqIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICBwdWJsaWMgZGF0YSA9IFtcbiAqICAgICAgIHsgbmFtZTogXCJQb3JrXCIsIGNhdGVnb3J5OiBcIkZvb2RcIiwgc3ViY2F0ZWdvcnk6IFwiTWVhdFwiIH0sXG4gKiAgICAgICB7IG5hbWU6IFwiUGVwcGVyXCIsIGNhdGVnb3J5OiBcIkZvb2RcIiwgc3ViY2F0ZWdvcnk6IFwiVmVnZXRhYmxlc1wiIH0sXG4gKiAgICAgICB7IG5hbWU6IFwiQmVlZlwiLCBjYXRlZ29yeTogXCJGb29kXCIsIHN1YmNhdGVnb3J5OiBcIk1lYXRcIiB9XG4gKiAgIF07XG4gKiAgIHB1YmxpYyBncm91cGVkRGF0YSA9IGdyb3VwQnkodGhpcy5kYXRhLCBbe2ZpZWxkOiBcInN1YmNhdGVnb3J5XCJ9XSk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuY2xhc3MgR3JvdXBUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn1cbkdyb3VwVGVtcGxhdGVEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0Ryb3BEb3duTGlzdEdyb3VwVGVtcGxhdGVdLFtrZW5kb0NvbWJvQm94R3JvdXBUZW1wbGF0ZV0sW2tlbmRvQXV0b0NvbXBsZXRlR3JvdXBUZW1wbGF0ZV0sW2tlbmRvTXVsdGlTZWxlY3RHcm91cFRlbXBsYXRlXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuR3JvdXBUZW1wbGF0ZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmIH1cbl07XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBSZW5kZXJzIHRoZSBmaXhlZCBncm91cCBoZWFkZXIgY29udGVudC4gVG8gZGVmaW5lIHRoZSBmaXhlZCBncm91cCB0ZW1wbGF0ZSwgbmVzdCBhbiBgPG5nLXRlbXBsYXRlPmAgdGFnXG4gKiB3aXRoIHRoZSBga2VuZG88Q29tcG9uZW50TmFtZT5GaXhlZEdyb3VwVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgdGhlIGNvbXBvbmVudCB0YWcuIFRoZSB0ZW1wbGF0ZSBjb250ZXh0IGlzXG4gKiBzZXQgdG8gdGhlIGN1cnJlbnQgY29tcG9uZW50LiBUbyBnZXQgYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZGF0YSBpdGVtLCB1c2UgdGhlIGBsZXQtZ3JvdXBOYW1lYCBkaXJlY3RpdmUuXG4gKlxuICogLSBbVXNpbmcgYEZpeGVkR3JvdXBUZW1wbGF0ZWAgd2l0aCB0aGUgQXV0b0NvbXBsZXRlXSh7JSBzbHVnIHRlbXBsYXRlc19hdXRvY29tcGxldGUgJX0jdG9jLWZpeGVkLWdyb3VwLXRlbXBsYXRlKVxuICogLSBbVXNpbmcgYEZpeGVkR3JvdXBUZW1wbGF0ZWAgd2l0aCB0aGUgQ29tYm9Cb3hdKHslIHNsdWcgdGVtcGxhdGVzX2NvbWJvYm94ICV9I3RvYy1maXhlZC1ncm91cC10ZW1wbGF0ZSlcbiAqIC0gW1VzaW5nIGBGaXhlZEdyb3VwVGVtcGxhdGVgIHdpdGggdGhlIERyb3BEb3duTGlzdF0oeyUgc2x1ZyB0ZW1wbGF0ZXNfZGRsICV9I3RvYy1maXhlZC1ncm91cC10ZW1wbGF0ZSlcbiAqIC0gW1VzaW5nIGBGaXhlZEdyb3VwVGVtcGxhdGVgIHdpdGggdGhlIE11bHRpU2VsZWN0XSh7JSBzbHVnIHRlbXBsYXRlc19tdWx0aXNlbGVjdCAlfSN0b2MtZml4ZWQtZ3JvdXAtdGVtcGxhdGUpXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBncm91cEJ5IH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWRhdGEtcXVlcnknO1xuICogX0BDb21wb25lbnQoe1xuICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICogdGVtcGxhdGU6IGBcbiAqICA8a2VuZG8tY29tYm9ib3ggW2RhdGFdPVwiZ3JvdXBlZERhdGFcIiBbdGV4dEZpZWxkXT1cIiduYW1lJ1wiIFt2YWx1ZUZpZWxkXT1cIiduYW1lJ1wiPlxuICogICAgPG5nLXRlbXBsYXRlIGtlbmRvQ29tYm9Cb3hGaXhlZEdyb3VwVGVtcGxhdGUgbGV0LWdyb3VwTmFtZT5cbiAqICAgICAgPHNwYW4+Rm9vZCB0eXBlOiB7e2dyb3VwTmFtZX19IG9wdGlvbjwvc3Bhbj5cbiAqICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgPC9rZW5kby1jb21ib2JveD5cbiAqIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICBwdWJsaWMgZGF0YSA9IFtcbiAqICAgICAgIHsgbmFtZTogXCJQb3JrXCIsIGNhdGVnb3J5OiBcIkZvb2RcIiwgc3ViY2F0ZWdvcnk6IFwiTWVhdFwiIH0sXG4gKiAgICAgICB7IG5hbWU6IFwiUGVwcGVyXCIsIGNhdGVnb3J5OiBcIkZvb2RcIiwgc3ViY2F0ZWdvcnk6IFwiVmVnZXRhYmxlc1wiIH0sXG4gKiAgICAgICB7IG5hbWU6IFwiQmVlZlwiLCBjYXRlZ29yeTogXCJGb29kXCIsIHN1YmNhdGVnb3J5OiBcIk1lYXRcIiB9XG4gKiAgIF07XG4gKiAgIHB1YmxpYyBncm91cGVkRGF0YSA9IGdyb3VwQnkodGhpcy5kYXRhLCBbe2ZpZWxkOiBcInN1YmNhdGVnb3J5XCJ9XSk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuY2xhc3MgRml4ZWRHcm91cFRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufVxuRml4ZWRHcm91cFRlbXBsYXRlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9Ecm9wRG93bkxpc3RGaXhlZEdyb3VwVGVtcGxhdGVdLFtrZW5kb0NvbWJvQm94Rml4ZWRHcm91cFRlbXBsYXRlXSxba2VuZG9BdXRvQ29tcGxldGVGaXhlZEdyb3VwVGVtcGxhdGVdLFtrZW5kb011bHRpU2VsZWN0Rml4ZWRHcm91cFRlbXBsYXRlXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRml4ZWRHcm91cFRlbXBsYXRlRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogVGVtcGxhdGVSZWYgfVxuXTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNlbGVjdGlvblNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm9uU2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uRm9jdXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMudG90YWwgPSAwO1xuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNlcyA9IFtdO1xuICAgIH1cbiAgICBnZXRUb3RhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG90YWw7XG4gICAgfVxuICAgIGlzU2VsZWN0ZWQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLnNlbGVjdGVkSW5kaWNlcy5maW5kKGN1cnJlbnQgPT4gY3VycmVudCA9PT0gaW5kZXgpKTtcbiAgICB9XG4gICAgaXNGb2N1c2VkKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpbmRleCA9PT0gdGhpcy5mb2N1c2VkO1xuICAgIH1cbiAgICBmb2N1cyhpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5pc0ZvY3VzZWQoaW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb2N1c2VkID0gaW5kZXg7XG4gICAgICAgIHRoaXMub25Gb2N1cy5lbWl0KGluZGV4KTtcbiAgICB9XG4gICAgc2VsZWN0KGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQoaW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3RlZEluZGljZXMgPSBbaW5kZXhdO1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSBpbmRleDtcbiAgICAgICAgdGhpcy5vblNlbGVjdC5lbWl0KHtcbiAgICAgICAgICAgIGluZGljZXM6IFtpbmRleF0sXG4gICAgICAgICAgICBuZXdTZWxlY3Rpb246IGlzUHJlc2VudChpbmRleClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZChpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGVkKGluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRpY2VzLnB1c2goaW5kZXgpO1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSBpbmRleDtcbiAgICAgICAgdGhpcy5vbkNoYW5nZS5lbWl0KHtcbiAgICAgICAgICAgIGFkZGVkOiBpbmRleCxcbiAgICAgICAgICAgIGluZGljZXM6IHRoaXMuc2VsZWN0ZWRJbmRpY2VzLnNsaWNlKClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVuc2VsZWN0KGluZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1NlbGVjdGVkKGluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5zZWxlY3RlZEluZGljZXMuaW5kZXhPZihpbmRleCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRpY2VzLnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgICAgIHRoaXMuZm9jdXNlZCA9IGluZGV4O1xuICAgICAgICB0aGlzLm9uQ2hhbmdlLmVtaXQoe1xuICAgICAgICAgICAgaW5kaWNlczogdGhpcy5zZWxlY3RlZEluZGljZXMuc2xpY2UoKSxcbiAgICAgICAgICAgIHJlbW92ZWQ6IGluZGV4XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjaGFuZ2UoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gaXNQcmVzZW50KGluZGV4KSAmJiAhdGhpcy5pc1NlbGVjdGVkKGluZGV4KTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEluZGljZXMgPSBbaW5kZXhdO1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSBpbmRleDtcbiAgICAgICAgdGhpcy5vbkNoYW5nZS5lbWl0KHtcbiAgICAgICAgICAgIGluZGljZXM6IFtpbmRleF0sXG4gICAgICAgICAgICBuZXdTZWxlY3Rpb246IG5ld1NlbGVjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzZXRTZWxlY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEluZGljZXMgPSBpbmRleCBpbnN0YW5jZW9mIEFycmF5ID8gaW5kZXggOiBbaW5kZXhdO1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSB0aGlzLnNlbGVjdGVkSW5kaWNlc1t0aGlzLnNlbGVjdGVkSW5kaWNlcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZEluZGljZXMuc2xpY2UoKTtcbiAgICB9XG4gICAgZ2V0IGZvY3VzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvY3VzZWRJbmRleDtcbiAgICB9XG4gICAgc2V0IGZvY3VzZWQoaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9jdXNlZEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c2VkSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIHRoaXMub25Gb2N1cy5lbWl0KGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblNlbGVjdGlvblNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG52YXIgTmF2aWdhdGlvbkFjdGlvbjtcbihmdW5jdGlvbiAoTmF2aWdhdGlvbkFjdGlvbikge1xuICAgIE5hdmlnYXRpb25BY3Rpb25bTmF2aWdhdGlvbkFjdGlvbltcIlVuZGVmaW5lZFwiXSA9IDBdID0gXCJVbmRlZmluZWRcIjtcbiAgICBOYXZpZ2F0aW9uQWN0aW9uW05hdmlnYXRpb25BY3Rpb25bXCJPcGVuXCJdID0gMV0gPSBcIk9wZW5cIjtcbiAgICBOYXZpZ2F0aW9uQWN0aW9uW05hdmlnYXRpb25BY3Rpb25bXCJDbG9zZVwiXSA9IDJdID0gXCJDbG9zZVwiO1xuICAgIE5hdmlnYXRpb25BY3Rpb25bTmF2aWdhdGlvbkFjdGlvbltcIkVudGVyXCJdID0gM10gPSBcIkVudGVyXCI7XG4gICAgTmF2aWdhdGlvbkFjdGlvbltOYXZpZ2F0aW9uQWN0aW9uW1wiVGFiXCJdID0gNF0gPSBcIlRhYlwiO1xuICAgIE5hdmlnYXRpb25BY3Rpb25bTmF2aWdhdGlvbkFjdGlvbltcIkVzY1wiXSA9IDVdID0gXCJFc2NcIjtcbiAgICBOYXZpZ2F0aW9uQWN0aW9uW05hdmlnYXRpb25BY3Rpb25bXCJEZWxldGVcIl0gPSA2XSA9IFwiRGVsZXRlXCI7XG4gICAgTmF2aWdhdGlvbkFjdGlvbltOYXZpZ2F0aW9uQWN0aW9uW1wiQmFja3NwYWNlXCJdID0gN10gPSBcIkJhY2tzcGFjZVwiO1xuICAgIE5hdmlnYXRpb25BY3Rpb25bTmF2aWdhdGlvbkFjdGlvbltcIkhvbWVcIl0gPSA4XSA9IFwiSG9tZVwiO1xuICAgIE5hdmlnYXRpb25BY3Rpb25bTmF2aWdhdGlvbkFjdGlvbltcIkVuZFwiXSA9IDldID0gXCJFbmRcIjtcbiAgICBOYXZpZ2F0aW9uQWN0aW9uW05hdmlnYXRpb25BY3Rpb25bXCJVcFwiXSA9IDEwXSA9IFwiVXBcIjtcbiAgICBOYXZpZ2F0aW9uQWN0aW9uW05hdmlnYXRpb25BY3Rpb25bXCJEb3duXCJdID0gMTFdID0gXCJEb3duXCI7XG4gICAgTmF2aWdhdGlvbkFjdGlvbltOYXZpZ2F0aW9uQWN0aW9uW1wiTGVmdFwiXSA9IDEyXSA9IFwiTGVmdFwiO1xuICAgIE5hdmlnYXRpb25BY3Rpb25bTmF2aWdhdGlvbkFjdGlvbltcIlJpZ2h0XCJdID0gMTNdID0gXCJSaWdodFwiO1xufSkoTmF2aWdhdGlvbkFjdGlvbiB8fCAoTmF2aWdhdGlvbkFjdGlvbiA9IHt9KSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBEYXRhU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmdyb3VwSW5kaWNlcyA9IFtdO1xuICAgIH1cbiAgICBzZXQgZGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmdyb3VwZWQgPSB0aGlzLmlzR3JvdXBlZChkYXRhKTtcbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBlZCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cEluZGljZXMgPSB0aGlzLmdldEdyb3VwSW5kaWNlcyhkYXRhKTtcbiAgICAgICAgICAgIHRoaXMuX2ZsYXREYXRhID0gdGhpcy5mbGF0dGVuKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkYXRhKCkge1xuICAgICAgICBpZiAodGhpcy5ncm91cGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmxhdERhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBVc2VkIHRvIGdldCB0aGUgYWN0dWFsIGl0ZW1zIGNvdW50LCBpLmUuIGV4Y2x1ZGluZyB0aGUgaGVhZGVyIGl0ZW1zIGluIGNhc2Ugb2YgZ3JvdXBpbmcuXG4gICAgICovXG4gICAgZ2V0IGl0ZW1zQ291bnQoKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMuZGF0YSkgfHwgdGhpcy5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLmdyb3VwZWQgPyB0aGlzLl9mbGF0RGF0YS5maWx0ZXIoaXRlbSA9PiAhaXRlbS5oZWFkZXIpIDogdGhpcy5kYXRhO1xuICAgICAgICByZXR1cm4gaXRlbXMubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogVXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGNvbXBvbmVudCByZWNlaXZlZCBncm91cGVkIGRhdGEuXG4gICAgICovXG4gICAgaXNHcm91cGVkKGRhdGEpIHtcbiAgICAgICAgLy8gR3JvdXBSZXN1bHQgeyBhZ2dyZWdhdGVzOiBBZ2dyZWdhdGVSZXN1bHQsIGZpZWxkOiBzdHJpbmcsIGl0ZW1zOiBvYmplY3RbXSwgdmFsdWU6IGFueSB9XG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9kYXRhcXVlcnkvYXBpL0dyb3VwUmVzdWx0L1xuICAgICAgICByZXR1cm4gKGlzUHJlc2VudChkYXRhKSAmJiBkYXRhLmxlbmd0aCAhPT0gMCkgJiYgaXNQcmVzZW50KGRhdGFbMF0pICYmIGhhc1Byb3BzKGRhdGFbMF0sIFsnYWdncmVnYXRlcycsICdmaWVsZCcsICdpdGVtcycsICd2YWx1ZSddKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFVzZWQgdG8gY2FsY3VsYXRlIHRoZSBsYXN0IGl0ZW0gaW5kZXggb2YgZWFjaCBncm91cC5cbiAgICAgKi9cbiAgICBnZXRHcm91cEluZGljZXMoZGF0YSkge1xuICAgICAgICBsZXQgZ3JvdXBJbmRpY2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGRhdGEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBncm91cEluZGljZXNbaV0gPSAoZ3JvdXBJbmRpY2VzW2kgLSAxXSB8fCAwKSArIGRhdGFbaV0uaXRlbXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncm91cEluZGljZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBVc2VkIHRvIGdldCBhIGZsYXQgYXJyYXkgY29udGFpbmluZyBhbGwgaXRlbXMgbWF0Y2hpbmcgY2VydGFpbiBjcml0ZXJpYS5cbiAgICAgKi9cbiAgICBmaWx0ZXIocHJlZGljYXRlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuaXNHcm91cGVkKHRoaXMuZGF0YSkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHRoaXMuZ3JvdXBJbmRpY2VzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLmRhdGFbaV0uaXRlbXMuZmlsdGVyKHByZWRpY2F0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChtYXRjaGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmRhdGEuZmlsdGVyKHByZWRpY2F0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFVzZWQgdG8gZ2V0IHRoZSBpbmRleCBvZiBhIGdpdmVuIGRhdGEgaXRlbS5cbiAgICAgKi9cbiAgICBpbmRleE9mKGl0ZW0sIHN0YXJ0RnJvbSA9IDApIHtcbiAgICAgICAgbGV0IHByZWRpY2F0ZSA9IChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudCA9PT0gaXRlbTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBlZCkge1xuICAgICAgICAgICAgcHJlZGljYXRlID0gKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC52YWx1ZSA9PT0gaXRlbTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZEluZGV4KHByZWRpY2F0ZSwgc3RhcnRGcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFVzZWQgdG8gZ2V0IHRoZSBpbmRleCBvZiBhIGRhdGEgaXRlbSBiYXNlZCBvbiBhbiBleHByZXNzaW9uLlxuICAgICAqL1xuICAgIGZpbmRJbmRleChwcmVkaWNhdGUsIHN0YXJ0RnJvbSA9IDApIHtcbiAgICAgICAgbGV0IGluZGV4ID0gLTE7XG4gICAgICAgIGlmICh0aGlzLmdyb3VwZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9mbGF0RGF0YS5maWx0ZXIoaXRlbSA9PiAhaXRlbS5oZWFkZXIgJiYgaXRlbS5vZmZzZXRJbmRleCA+PSBzdGFydEZyb20pO1xuICAgICAgICAgICAgaW5kZXggPSBkYXRhLmZpbmRJbmRleChwcmVkaWNhdGUpO1xuICAgICAgICAgICAgaW5kZXggPSBkYXRhW2luZGV4XSA/IGRhdGFbaW5kZXhdLm9mZnNldEluZGV4IDogLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhLnNsaWNlKHN0YXJ0RnJvbSk7XG4gICAgICAgICAgICBjb25zdCBpdGVtSW5kZXggPSBkYXRhLmZpbmRJbmRleChwcmVkaWNhdGUpO1xuICAgICAgICAgICAgaW5kZXggPSBpdGVtSW5kZXggIT09IC0xID8gaXRlbUluZGV4ICsgc3RhcnRGcm9tIDogLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogVXNlZCB0byBnZXQgdGhlIGNsb3Nlc3QgZ3JvdXAgaGVhZGVyIHByaW9yIHRvIGFuIGl0ZW0gaW5kZXguXG4gICAgICovXG4gICAgY2xvc2VzdEdyb3VwKGluZGV4KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBpbmRleDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9mbGF0RGF0YVtpXS5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmxhdERhdGFbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFVzZWQgdG8gZ2V0IHRoZSBmaXJzdCBpdGVtIG1hdGNoaW5nIHRoZSBjcml0ZXJpYS5cbiAgICAgKi9cbiAgICBmaW5kKHByZWRpY2F0ZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZmluZEluZGV4KHByZWRpY2F0ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1BdChpbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBVc2VkIHRvIGdldCB0aGUgdHJ1ZSBpbmRleCBpbiBhIGZsYXR0ZW5lZCBkYXRhIGFycmF5LlxuICAgICAqL1xuICAgIGZsYXRJbmRleChpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5pdGVtc0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBlZCkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLl9mbGF0RGF0YS5maW5kKChpdGVtKSA9PiAhaXRlbS5oZWFkZXIgJiYgaXRlbS5vZmZzZXRJbmRleCA9PT0gaW5kZXgpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFVzZWQgdG8gZ2V0IHRoZSBpdGVtIGF0IHRoZSBwcm92aWRlZCBpbmRleC5cbiAgICAgKi9cbiAgICBpdGVtQXQoaW5kZXgpIHtcbiAgICAgICAgbGV0IGRhdGFJdGVtO1xuICAgICAgICBpZiAodGhpcy5pdGVtc0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YUl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBlZCkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLl9mbGF0RGF0YS5maW5kKChpdGVtKSA9PiAhaXRlbS5oZWFkZXIgJiYgaXRlbS5vZmZzZXRJbmRleCA9PT0gaW5kZXgpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgZGF0YUl0ZW0gPSBtYXRjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFJdGVtID0gdGhpcy5kYXRhW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YUl0ZW07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBVc2VkIHRvIGdldCB0aGUgZ3JvdXAgYXQgdGhlIHByb3ZpZGVkIGluZGV4LlxuICAgICAqL1xuICAgIGdyb3VwQXQoaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXRlbXNDb3VudCA9PT0gMCB8fCAhdGhpcy5pc0dyb3VwZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZmxhdERhdGEuZmluZCgoaXRlbSkgPT4gaXRlbS5oZWFkZXIgJiYgaXRlbS5pbmRleCA9PT0gaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogVXNlZCB0byBnZXQgdGhlIGZpZWxkIGJ5IHdoaWNoIHRoZSBkYXRhIGlzIGdyb3VwZWQuXG4gICAgICovXG4gICAgZ3JvdXBGaWVsZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXRlbXNDb3VudCA9PT0gMCB8fCAhdGhpcy5pc0dyb3VwZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVswXS5maWVsZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFVzZWQgdG8gZ2V0IHRoZSBncm91cCB0byB3aGljaCBhIGRhdGFJdGVtIGJlbG9uZ3MuXG4gICAgICovXG4gICAgaXRlbUdyb3VwKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFpdGVtIHx8IHRoaXMuaXRlbXNDb3VudCA9PT0gMCB8fCAhdGhpcy5pc0dyb3VwZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSB0aGlzLmdyb3VwRmllbGQoKTtcbiAgICAgICAgaWYgKGZpZWxkTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1bZmllbGROYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbGF0dGVuKGRhdGEsIGdyb3VwID0gdW5kZWZpbmVkLCBvZmZzZXQgPSAwLCBncm91cEluZGV4ID0gMCkge1xuICAgICAgICBsZXQgZmxhdCA9IFtdO1xuICAgICAgICBpZiAoaXNQcmVzZW50KGdyb3VwKSkge1xuICAgICAgICAgICAgZmxhdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBoZWFkZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgaW5kZXg6IGdyb3VwSW5kZXggKyBvZmZzZXQsXG4gICAgICAgICAgICAgICAgb2Zmc2V0SW5kZXg6IGdyb3VwSW5kZXgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGdyb3VwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGlmIChkYXRhW2ldLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5mbGF0dGVuKGRhdGFbaV0uaXRlbXMsIGRhdGFbaV0udmFsdWUsIG9mZnNldCwgaSk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgZGF0YVtpXS5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBncm91cEluZGV4ICsgb2Zmc2V0ICsgaSArIDEsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldEluZGV4OiBvZmZzZXQgKyBpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YVtpXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmxhdCA9IGZsYXQuY29uY2F0KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYXQ7XG4gICAgfVxufVxuRGF0YVNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBEaXNhYmxlZEl0ZW1zU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoZGF0YVNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5kYXRhU2VydmljZSA9IGRhdGFTZXJ2aWNlO1xuICAgICAgICB0aGlzLml0ZW1EaXNhYmxlZCA9IG51bGw7XG4gICAgfVxuICAgIGlzSW5kZXhEaXNhYmxlZChpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5pdGVtRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmRhdGFTZXJ2aWNlLml0ZW1BdChpbmRleCk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbURpc2FibGVkKHsgZGF0YUl0ZW06IGl0ZW0sIGluZGV4IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNQcmVzZW50KHRoaXMuZGVmYXVsdEl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbURpc2FibGVkKHsgZGF0YUl0ZW06IHRoaXMuZGVmYXVsdEl0ZW0sIGluZGV4OiAtMSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0l0ZW1EaXNhYmxlZChpdGVtKSB7XG4gICAgICAgIGlmICh0aGlzLml0ZW1EaXNhYmxlZCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmRhdGFTZXJ2aWNlLmluZGV4T2YoaXRlbSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbURpc2FibGVkKHsgZGF0YUl0ZW06IGl0ZW0sIGluZGV4IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNQcmVzZW50KHRoaXMuZGVmYXVsdEl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbURpc2FibGVkKHsgZGF0YUl0ZW06IHRoaXMuZGVmYXVsdEl0ZW0sIGluZGV4OiAtMSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbkRpc2FibGVkSXRlbXNTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5EaXNhYmxlZEl0ZW1zU2VydmljZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IERhdGFTZXJ2aWNlIH1cbl07XG5cbmNvbnN0IE1JTl9JTkRFWCA9IDA7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgTmF2aWdhdGlvbkV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGl0ZW0gdG8gd2hpY2ggdGhlIHVzZXIgbmF2aWdhdGVkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGluZGV4LCBvcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgICB9XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgTmF2aWdhdGlvblNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGRpc2FibGVkSXRlbXNTZXJ2aWNlLCBzZWxlY3Rpb25TZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWRJdGVtc1NlcnZpY2UgPSBkaXNhYmxlZEl0ZW1zU2VydmljZTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlID0gc2VsZWN0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5vcGVuID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmVudGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnRhYiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5lc2MgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMudXAgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMucmlnaHQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZG93biA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmRlbGV0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5iYWNrc3BhY2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuaG9tZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5lbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIHByb2Nlc3MoYXJncykge1xuICAgICAgICBjb25zdCBrZXlDb2RlID0gYXJncy5vcmlnaW5hbEV2ZW50LmtleUNvZGU7XG4gICAgICAgIGNvbnN0IGFsdEtleSA9IGFyZ3Mub3JpZ2luYWxFdmVudC5hbHRLZXk7XG4gICAgICAgIGxldCBpbmRleDtcbiAgICAgICAgbGV0IGFjdGlvbiA9IE5hdmlnYXRpb25BY3Rpb24uVW5kZWZpbmVkO1xuICAgICAgICBpZiAoYWx0S2V5ICYmIGtleUNvZGUgPT09IEtleXMuZG93bikge1xuICAgICAgICAgICAgYWN0aW9uID0gTmF2aWdhdGlvbkFjdGlvbi5PcGVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFsdEtleSAmJiBrZXlDb2RlID09PSBLZXlzLnVwKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBOYXZpZ2F0aW9uQWN0aW9uLkNsb3NlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleUNvZGUgPT09IEtleXMuZW50ZXIpIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IE5hdmlnYXRpb25BY3Rpb24uRW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5Q29kZSA9PT0gS2V5cy5lc2MpIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IE5hdmlnYXRpb25BY3Rpb24uRXNjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleUNvZGUgPT09IEtleXMudGFiKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBOYXZpZ2F0aW9uQWN0aW9uLlRhYjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXlDb2RlID09PSBLZXlzLnVwKSB7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMubmV4dCh7IGN1cnJlbnQ6IGFyZ3MuY3VycmVudCwgc3RhcnQ6IGFyZ3MubWluLCBlbmQ6IGFyZ3MubWF4LCBzdGVwOiAtMSB9KTtcbiAgICAgICAgICAgIGFjdGlvbiA9IE5hdmlnYXRpb25BY3Rpb24uVXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5Q29kZSA9PT0gS2V5cy5sZWZ0KSB7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMubmV4dCh7IGN1cnJlbnQ6IGFyZ3MuY3VycmVudCwgc3RhcnQ6IGFyZ3MubWluLCBlbmQ6IGFyZ3MubWF4LCBzdGVwOiAtMSB9KTtcbiAgICAgICAgICAgIGFjdGlvbiA9IE5hdmlnYXRpb25BY3Rpb24uTGVmdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXlDb2RlID09PSBLZXlzLmRvd24pIHtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5uZXh0KHsgY3VycmVudDogYXJncy5jdXJyZW50LCBzdGFydDogYXJncy5taW4sIGVuZDogYXJncy5tYXgsIHN0ZXA6IDEgfSk7XG4gICAgICAgICAgICBhY3Rpb24gPSBOYXZpZ2F0aW9uQWN0aW9uLkRvd247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5Q29kZSA9PT0gS2V5cy5yaWdodCkge1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLm5leHQoeyBjdXJyZW50OiBhcmdzLmN1cnJlbnQsIHN0YXJ0OiBhcmdzLm1pbiwgZW5kOiBhcmdzLm1heCwgc3RlcDogMSB9KTtcbiAgICAgICAgICAgIGFjdGlvbiA9IE5hdmlnYXRpb25BY3Rpb24uUmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5Q29kZSA9PT0gS2V5cy5ob21lKSB7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuaXNEaXNhYmxlZChNSU5fSU5ERVgpID8gYXJncy5jdXJyZW50IDogTUlOX0lOREVYO1xuICAgICAgICAgICAgYWN0aW9uID0gTmF2aWdhdGlvbkFjdGlvbi5Ib21lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleUNvZGUgPT09IEtleXMuZW5kKSB7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuaXNEaXNhYmxlZChhcmdzLm1heCkgPyBhcmdzLmN1cnJlbnQgOiBhcmdzLm1heDtcbiAgICAgICAgICAgIGFjdGlvbiA9IE5hdmlnYXRpb25BY3Rpb24uRW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleUNvZGUgPT09IEtleXMuZGVsZXRlKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBOYXZpZ2F0aW9uQWN0aW9uLkRlbGV0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXlDb2RlID09PSBLZXlzLmJhY2tzcGFjZSkge1xuICAgICAgICAgICAgYWN0aW9uID0gTmF2aWdhdGlvbkFjdGlvbi5CYWNrc3BhY2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZlbnREYXRhID0gbmV3IE5hdmlnYXRpb25FdmVudChpbmRleCwgYXJncy5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgaWYgKGFjdGlvbiAhPT0gTmF2aWdhdGlvbkFjdGlvbi5VbmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXNbTmF2aWdhdGlvbkFjdGlvblthY3Rpb25dLnRvTG93ZXJDYXNlKCldLmVtaXQoZXZlbnREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH1cbiAgICBuZXh0KGFyZ3MpIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50LCBzdGFydCwgZW5kLCBzdGVwIH0gPSBhcmdzO1xuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSAhaXNQcmVzZW50KGN1cnJlbnQpID8gc3RhcnQgOiB0aGlzLmNsYW1wSW5kZXgoY3VycmVudCArIHN0ZXAsIHN0YXJ0LCBlbmQpO1xuICAgICAgICBjb25zdCBmaXJzdEZvY3VzYWJsZUluZGV4ID0gdGhpcy5maXJzdEZvY3VzYWJsZUluZGV4KG5leHRJbmRleCwgc3RhcnQsIGVuZCwgc3RlcCk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoZmlyc3RGb2N1c2FibGVJbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdEZvY3VzYWJsZUluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvblNlcnZpY2UuaXNTZWxlY3RlZChjdXJyZW50KSAmJiBjdXJyZW50ID49IHN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnZlcnNlZFN0ZXAgPSAtMSAqIHN0ZXA7XG4gICAgICAgIHJldHVybiB0aGlzLmZpcnN0Rm9jdXNhYmxlSW5kZXgobmV4dEluZGV4LCBzdGFydCwgZW5kLCBpbnZlcnNlZFN0ZXApO1xuICAgIH1cbiAgICBjbGFtcEluZGV4KGluZGV4LCBtaW4sIG1heCkge1xuICAgICAgICBpZiAoIWlzUHJlc2VudChpbmRleCkgfHwgaW5kZXggPCBtaW4pIHtcbiAgICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID4gbWF4KSB7XG4gICAgICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgZmlyc3RGb2N1c2FibGVJbmRleChzdGFydEluZGV4LCBtaW4sIG1heCwgc3RlcCkge1xuICAgICAgICB3aGlsZSAobWluIDw9IHN0YXJ0SW5kZXggJiYgc3RhcnRJbmRleCA8PSBtYXgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Rpc2FibGVkKHN0YXJ0SW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydEluZGV4ICs9IHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaXNEaXNhYmxlZChpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZEl0ZW1zU2VydmljZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWRJdGVtc1NlcnZpY2UuaXNJbmRleERpc2FibGVkKGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbk5hdmlnYXRpb25TZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5OYXZpZ2F0aW9uU2VydmljZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IERpc2FibGVkSXRlbXNTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBTZWxlY3Rpb25TZXJ2aWNlIH1cbl07XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBSZW5kZXJzIGNvbnRlbnQgd2hlbiBubyBkYXRhIGlzIGF2YWlsYWJsZS4gVG8gZGVmaW5lIHRoZSBuby1kYXRhIHRlbXBsYXRlLCBuZXN0IGEgYDxuZy10ZW1wbGF0ZT5gIHRhZ1xuICogd2l0aCB0aGUgYGtlbmRvPENvbXBvbmVudE5hbWU+Tm9EYXRhVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgdGhlIGNvbXBvbmVudCB0YWcuXG4gKlxuICogLSBbVXNpbmcgYE5vRGF0YVRlbXBsYXRlYCB3aXRoIHRoZSBBdXRvQ29tcGxldGVdKHslIHNsdWcgdGVtcGxhdGVzX2F1dG9jb21wbGV0ZSAlfSN0b2Mtbm8tZGF0YS10ZW1wbGF0ZSlcbiAqIC0gW1VzaW5nIGBOb0RhdGFUZW1wbGF0ZWAgd2l0aCB0aGUgQ29tYm9Cb3hdKHslIHNsdWcgdGVtcGxhdGVzX2NvbWJvYm94ICV9I3RvYy1uby1kYXRhLXRlbXBsYXRlKVxuICogLSBbVXNpbmcgYE5vRGF0YVRlbXBsYXRlYCB3aXRoIHRoZSBEcm9wRG93bkxpc3RdKHslIHNsdWcgdGVtcGxhdGVzX2RkbCAlfSN0b2Mtbm8tZGF0YS10ZW1wbGF0ZSlcbiAqIC0gW1VzaW5nIGBOb0RhdGFUZW1wbGF0ZWAgd2l0aCB0aGUgTXVsdGlTZWxlY3RdKHslIHNsdWcgdGVtcGxhdGVzX211bHRpc2VsZWN0ICV9I3RvYy1uby1kYXRhLXRlbXBsYXRlKVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogX0BDb21wb25lbnQoe1xuICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICogdGVtcGxhdGU6IGBcbiAqICA8a2VuZG8tY29tYm9ib3ggW2RhdGFdPVwibGlzdEl0ZW1zXCI+XG4gKiAgICA8bmctdGVtcGxhdGUga2VuZG9Db21ib0JveE5vRGF0YVRlbXBsYXRlPlxuICogICAgICA8aDQ+Tm8gZGF0YSE8L2g0PlxuICogICAgPC9uZy10ZW1wbGF0ZT5cbiAqICA8L2tlbmRvLWNvbWJvYm94PlxuICogYFxuICogfSlcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgIHB1YmxpYyBsaXN0SXRlbXM6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAqIH1cbiAqIGBgYFxuICovXG5jbGFzcyBOb0RhdGFUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn1cbk5vRGF0YVRlbXBsYXRlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9Ecm9wRG93bkxpc3ROb0RhdGFUZW1wbGF0ZV0sW2tlbmRvQ29tYm9Cb3hOb0RhdGFUZW1wbGF0ZV0sW2tlbmRvQXV0b0NvbXBsZXRlTm9EYXRhVGVtcGxhdGVdLFtrZW5kb011bHRpU2VsZWN0Tm9EYXRhVGVtcGxhdGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Ob0RhdGFUZW1wbGF0ZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmIH1cbl07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBQcmV2ZW50YWJsZUV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uIGZvciBhIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBJbiB0aGlzIHdheSwgdGhlIHNvdXJjZSBjb21wb25lbnQgc3VwcHJlc3NlcyB0aGUgYnVpbHQtaW4gYmVoYXZpb3IgdGhhdCBmb2xsb3dzIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgdGhpcy5wcmV2ZW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZXZlbnQgaXMgcHJldmVudGVkIGJ5IGFueSBvZiBpdHMgc3Vic2NyaWJlcnMsIHJldHVybnMgYHRydWVgLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBkZWZhdWx0IGFjdGlvbiB3YXMgcHJldmVudGVkLiBPdGhlcndpc2UsIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBpc0RlZmF1bHRQcmV2ZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZlbnRlZDtcbiAgICB9XG59XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgbWFuZGF0b3J5IHByb3BlcnRpZXMgb2YgdGhlIGBrZW5kb0Ryb3BEb3duRmlsdGVyYCBkaXJlY3RpdmVcbiAqIHNvIHRoYXQgYGtlbmRvRHJvcERvd25GaWx0ZXJgIGNhbiBiZSB1c2VkIHdpdGggYW55IG9mIHRoZSBEcm9wRG93bnMgY29tcG9uZW50c1xuICogd2hpY2ggaW1wbGVtZW50IHRoZSBgRmlsdGVyYWJsZURyb3BEb3duQ29tcG9uZW50QmFzZWAgY2xhc3MuXG4gKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBGaWx0ZXJhYmxlRHJvcERvd25Db21wb25lbnRCYXNlIHtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIExpc3RJdGVtRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgfVxufVxuTGlzdEl0ZW1EaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1wibGlbcm9sZT1vcHRpb25dLCBsaVtyb2xlPWdyb3VwXVwiJyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkxpc3RJdGVtRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9XG5dO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgTGlzdENvbXBvbmVudCB7XG4gICAgLyogdHNsaW50OmRpc2FibGU6bWVtYmVyLW9yZGVyaW5nICovXG4gICAgY29uc3RydWN0b3IoZGF0YVNlcnZpY2UsIHdyYXBwZXIsIHNlbGVjdGlvblNlcnZpY2UsIGRpc2FibGVkSXRlbXNTZXJ2aWNlLCBjZHIsIHpvbmUsIHJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuZGF0YVNlcnZpY2UgPSBkYXRhU2VydmljZTtcbiAgICAgICAgdGhpcy53cmFwcGVyID0gd3JhcHBlcjtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlID0gc2VsZWN0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5kaXNhYmxlZEl0ZW1zU2VydmljZSA9IGRpc2FibGVkSXRlbXNTZXJ2aWNlO1xuICAgICAgICB0aGlzLmNkciA9IGNkcjtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gW107XG4gICAgICAgIHRoaXMuZm9jdXNlZCA9IC0xO1xuICAgICAgICB0aGlzLnNob3cgPSB0cnVlO1xuICAgICAgICB0aGlzLm11bHRpcGxlU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25DbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5wYWdlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnN0YXJ0RnJvbSA9IDA7XG4gICAgICAgIHRoaXMubGFzdExvYWRlZCA9IDA7XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbFRvcCA9IDA7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9Gb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VsZWN0U3Vic2NyaXB0aW9uID0gbWVyZ2UodGhpcy5zZWxlY3Rpb25TZXJ2aWNlLm9uU2VsZWN0LnBpcGUobWFwKChhcmdzKSA9PiBhcmdzLmluZGljZXNbMF0pKSwgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLm9uRm9jdXMpLnN1YnNjcmliZSh0aGlzLnNjcm9sbFRvSXRlbS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgc2V0IGRhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YVswXSAmJiBkYXRhWzBdLmhlYWRlciA/IGRhdGEuc2xpY2UoMCkgOiBkYXRhO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfVxuICAgIHNldCBpdGVtcyhpdGVtcykge1xuICAgICAgICB0aGlzLl9pdGVtcyA9IGl0ZW1zO1xuICAgIH1cbiAgICBnZXQgaXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcztcbiAgICB9XG4gICAgZ2V0IHBhZ2VTaXplKCkge1xuICAgICAgICBpZiAodGhpcy52aXJ0dWFsLnBhZ2VTaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aXJ0dWFsLnBhZ2VTaXplO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaXplID0gTWF0aC5yb3VuZCh0aGlzLmhlaWdodCAvIHRoaXMudmlydHVhbC5pdGVtSGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIGdldCBzY3JvbGxIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5kYXRhU2VydmljZS5ncm91cGVkID8gdGhpcy52aXJ0dWFsLnRvdGFsIC0gMSA6IHRoaXMudmlydHVhbC50b3RhbCkgKiB0aGlzLnZpcnR1YWwuaXRlbUhlaWdodDtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoaXNDaGFuZ2VkKCdkYXRhJywgY2hhbmdlcywgZmFsc2UpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0TG9hZGVkIDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RMb2FkZWQgPSB0aGlzLmRhdGEubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRvRm9jdXNlZCA9ICFjaGFuZ2VzLmRhdGEuaXNGaXJzdENoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsU3Vic2NyaXB0aW9uID0gZnJvbUV2ZW50KHRoaXMuY29udGVudC5uYXRpdmVFbGVtZW50LCBcInNjcm9sbFwiKS5waXBlKGF1ZGl0VGltZSgxMDApLCB0YXAodGhpcy5wcmVmZXRjaERhdGEuYmluZCh0aGlzKSksIHRhcCh0aGlzLmZpbmRDdXJyZW50R3JvdXAuYmluZCh0aGlzKSkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0U2Nyb2xsVG9wID0gdGhpcy5jb250ZW50Lm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLnZpcnR1YWwpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25JdGVtcygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLml0ZW1zICYmIHRoaXMuc2Nyb2xsVG9Gb2N1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsVGFyZ2V0ID0gdGhpcy5pdGVtcy5sZW5ndGggJiYgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmZvY3VzZWQgPT09IC0xID8gMCA6IHRoaXMuc2VsZWN0aW9uU2VydmljZS5mb2N1c2VkO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb0l0ZW0oc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXRhU2VydmljZS5ncm91cGVkKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRDdXJyZW50R3JvdXAoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpcnN0VmlzaWJsZUl0ZW0oKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3QgY29udGVudFBhcmVudCA9IGNvbnRlbnQub2Zmc2V0UGFyZW50O1xuICAgICAgICBjb25zdCBvZmZzZXRZID0gKGNvbnRlbnRQYXJlbnQgPyBjb250ZW50UGFyZW50Lm9mZnNldFRvcCA6IDApICsgY29udGVudC5vZmZzZXRUb3AgKyAxO1xuICAgICAgICBjb25zdCBvZmZzZXRYID0gKGNvbnRlbnRQYXJlbnQgPyBjb250ZW50UGFyZW50Lm9mZnNldExlZnQgOiAwKSArIGNvbnRlbnQub2Zmc2V0TGVmdCArIDE7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gICAgZmluZEN1cnJlbnRHcm91cCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRhdGFTZXJ2aWNlLmdyb3VwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEdyb3VwID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmZpcnN0VmlzaWJsZUl0ZW0oKTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGxldCBpbmRleDtcbiAgICAgICAgICAgIGlmIChpdGVtLmdldEF0dHJpYnV0ZShcInJvbGVcIikgPT09IFwiZ3JvdXBcIikge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gcGFyc2VJbnQoaXRlbS5nZXRBdHRyaWJ1dGUoXCJncm91cC1pbmRleFwiKSwgMTApO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEdyb3VwID0gdGhpcy5kYXRhU2VydmljZS5ncm91cEF0KGluZGV4KS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gcGFyc2VJbnQoaXRlbS5nZXRBdHRyaWJ1dGUoXCJpbmRleFwiKSwgMTApO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEdyb3VwID0gdGhpcy5kYXRhU2VydmljZS5pdGVtR3JvdXAodGhpcy5kYXRhU2VydmljZS5pdGVtQXQoaW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEdyb3VwID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG4gICAgcHJlZmV0Y2hEYXRhKCkge1xuICAgICAgICBpZiAoIXRoaXMudmlydHVhbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpc2libGVJdGVtcyA9IE1hdGgudHJ1bmModGhpcy5jb250ZW50Lm5hdGl2ZUVsZW1lbnQuY2xpZW50SGVpZ2h0IC8gdGhpcy52aXJ0dWFsLml0ZW1IZWlnaHQpO1xuICAgICAgICBjb25zdCBvZmZzZXRZID0gdGhpcy5jb250ZW50Lm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgICBjb25zdCBzdGFydCA9IE1hdGgudHJ1bmMob2Zmc2V0WSAvIHRoaXMudmlydHVhbC5pdGVtSGVpZ2h0KTtcbiAgICAgICAgY29uc3QgZG93biA9IG9mZnNldFkgPiB0aGlzLmxhc3RTY3JvbGxUb3A7XG4gICAgICAgIGNvbnN0IG5leHRQYWdlID0gKHN0YXJ0ICsgdmlzaWJsZUl0ZW1zID49IHRoaXMubGFzdExvYWRlZCkgJiYgdGhpcy5sYXN0TG9hZGVkIDwgdGhpcy52aXJ0dWFsLnRvdGFsIC0gMTtcbiAgICAgICAgY29uc3QgbGVmdE92ZXIgPSB0aGlzLnBhZ2VTaXplIC0gKHRoaXMubGFzdExvYWRlZCAtIHRoaXMuc3RhcnRGcm9tKTtcbiAgICAgICAgY29uc3QgcHJldlBhZ2UgPSB0aGlzLmxhc3RMb2FkZWQgLSB0aGlzLnBhZ2VTaXplICsgdmlzaWJsZUl0ZW1zID49IHN0YXJ0IC0gbGVmdE92ZXI7XG4gICAgICAgIGlmIChkb3duICYmIG5leHRQYWdlKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVBhZ2Uoc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZG93biAmJiBwcmV2UGFnZSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VQYWdlKHN0YXJ0IC0gdGhpcy5wYWdlU2l6ZSArIHZpc2libGVJdGVtcyArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoYW5nZVBhZ2Uoc3RhcnQpIHtcbiAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICBsZXQgZW5kID0gdGhpcy5wYWdlU2l6ZSArIHN0YXJ0O1xuICAgICAgICAgICAgaWYgKGVuZCA+IHRoaXMudmlydHVhbC50b3RhbCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0LS07XG4gICAgICAgICAgICAgICAgZW5kID0gdGhpcy52aXJ0dWFsLnRvdGFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhcnRGcm9tID0gc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLmxhc3RMb2FkZWQgPSBlbmQ7XG4gICAgICAgICAgICB0aGlzLnBhZ2VDaGFuZ2UuZW1pdCh7IHNraXA6IHN0YXJ0LCB0YWtlOiB0aGlzLnBhZ2VTaXplIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5kZXgoZ3JvdXBJbmRleCwgaXRlbUluZGV4KSB7XG4gICAgICAgIHJldHVybiBncm91cEluZGV4ID4gMCA/ICh0aGlzLmRhdGFTZXJ2aWNlLmdyb3VwSW5kaWNlc1tncm91cEluZGV4IC0gMV0gKyBpdGVtSW5kZXgpIDogaXRlbUluZGV4O1xuICAgIH1cbiAgICBnZXRUZXh0KGRhdGFJdGVtKSB7XG4gICAgICAgIHJldHVybiBnZXR0ZXIoZGF0YUl0ZW0sIHRoaXMudGV4dEZpZWxkKTtcbiAgICB9XG4gICAgZ2V0VmFsdWUoZGF0YUl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGdldHRlcihkYXRhSXRlbSwgdGhpcy52YWx1ZUZpZWxkKTtcbiAgICB9XG4gICAgaXNEaXNhYmxlZChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZEl0ZW1zU2VydmljZS5pc0luZGV4RGlzYWJsZWQoaW5kZXgpO1xuICAgIH1cbiAgICBzY3JvbGxUb0l0ZW0oaW5kZXgpIHtcbiAgICAgICAgbGV0IGZsYXRJbmRleCA9IGluZGV4O1xuICAgICAgICBpZiAodGhpcy5kYXRhU2VydmljZS5ncm91cGVkKSB7XG4gICAgICAgICAgICAvLyB0YWtlcyBpbnRvIGFjY291bnQgdGhlIGdyb3VwIGhlYWRlciBpdGVtc1xuICAgICAgICAgICAgZmxhdEluZGV4ID0gdGhpcy5kYXRhU2VydmljZS5mbGF0SW5kZXgoaW5kZXgpO1xuICAgICAgICAgICAgLyogVGhlIGZpcnN0IGdyb3VwIGhlYWRlciBpdGVtIGlzIG5vdCByZW5kZXJlZCBpbiB0aGUgbGlzdCAoc2VlIHRlbXBsYXRlKSwgc28gc3VidHJhY3QgMSB3aGVuIGNhbHVsYXRpbmcgdGhlIGZsYXQgaW5kZXguXG4gICAgICAgICAgICAgICBXaXRoIHZpcnR1YWxpemF0aW9uIGVuYWJsZWQsIHRoZSBmaXJzdCBncm91cCBoZWFkZXIgY291bGQgYmUgaW4gYSBwcmV2aW91cyBwYWdlLCBpbiB3aGljaCBjYXNlIGRvbid0IHN1YnRyYWN0IGFueXRoaW5nLiAqL1xuICAgICAgICAgICAgY29uc3QgZ3JvdXBIZWFkZXJPZmZzZXQgPSB0aGlzLmZpcnN0R3JvdXBIZWFkZXJJblRhcmdldGVkUGFnZShmbGF0SW5kZXgpID8gLTEgOiAwO1xuICAgICAgICAgICAgZmxhdEluZGV4ICs9IGdyb3VwSGVhZGVyT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpcnR1YWwgJiYgZmxhdEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9JbmRleChmbGF0SW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcy50b0FycmF5KCk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoaXRlbXNbZmxhdEluZGV4XSkgJiYgZmxhdEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGwoaXRlbXNbZmxhdEluZGV4XS5lbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY3JvbGxUb0luZGV4KGluZGV4KSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5jb250ZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGxldCBjb250ZW50U2Nyb2xsVG9wID0gY29udGVudC5zY3JvbGxUb3A7XG4gICAgICAgIGNvbnN0IGl0ZW1PZmZzZXRUb3AgPSBpbmRleCAqIHRoaXMudmlydHVhbC5pdGVtSGVpZ2h0O1xuICAgICAgICBjb25zdCBpdGVtT2Zmc2V0SGVpZ2h0ID0gdGhpcy52aXJ0dWFsLml0ZW1IZWlnaHQ7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRPZmZzZXRIZWlnaHQgPSBjb250ZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgY29uc3QgYm90dG9tRGlzdGFuY2UgPSBpdGVtT2Zmc2V0VG9wICsgaXRlbU9mZnNldEhlaWdodDtcbiAgICAgICAgaWYgKGNvbnRlbnRTY3JvbGxUb3AgPiBpdGVtT2Zmc2V0VG9wKSB7XG4gICAgICAgICAgICBjb250ZW50U2Nyb2xsVG9wID0gaXRlbU9mZnNldFRvcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChib3R0b21EaXN0YW5jZSA+IChjb250ZW50U2Nyb2xsVG9wICsgY29udGVudE9mZnNldEhlaWdodCkpIHtcbiAgICAgICAgICAgIGNvbnRlbnRTY3JvbGxUb3AgPSAoYm90dG9tRGlzdGFuY2UgLSBjb250ZW50T2Zmc2V0SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZW50LnNjcm9sbFRvcCA9IGNvbnRlbnRTY3JvbGxUb3A7XG4gICAgfVxuICAgIHNjcm9sbChpdGVtKSB7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hdGl2ZUVsZW1lbnQgPSBpdGVtLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5jb250ZW50Lm5hdGl2ZUVsZW1lbnQsIGl0ZW1PZmZzZXRUb3AgPSBuYXRpdmVFbGVtZW50Lm9mZnNldFRvcCwgaXRlbU9mZnNldEhlaWdodCA9IG5hdGl2ZUVsZW1lbnQub2Zmc2V0SGVpZ2h0LCBjb250ZW50U2Nyb2xsVG9wID0gY29udGVudC5zY3JvbGxUb3AsIGNvbnRlbnRPZmZzZXRIZWlnaHQgPSBjb250ZW50LmNsaWVudEhlaWdodCwgYm90dG9tRGlzdGFuY2UgPSBpdGVtT2Zmc2V0VG9wICsgaXRlbU9mZnNldEhlaWdodDtcbiAgICAgICAgaWYgKGNvbnRlbnRTY3JvbGxUb3AgPiBpdGVtT2Zmc2V0VG9wKSB7XG4gICAgICAgICAgICBjb250ZW50U2Nyb2xsVG9wID0gaXRlbU9mZnNldFRvcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChib3R0b21EaXN0YW5jZSA+IChjb250ZW50U2Nyb2xsVG9wICsgY29udGVudE9mZnNldEhlaWdodCkpIHtcbiAgICAgICAgICAgIGNvbnRlbnRTY3JvbGxUb3AgPSAoYm90dG9tRGlzdGFuY2UgLSBjb250ZW50T2Zmc2V0SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZW50LnNjcm9sbFRvcCA9IGNvbnRlbnRTY3JvbGxUb3A7XG4gICAgfVxuICAgIHBvc2l0aW9uSXRlbXMoKSB7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldFkgPSAoaW5kZXggKyB0aGlzLnN0YXJ0RnJvbSkgKiB0aGlzLnZpcnR1YWwuaXRlbUhlaWdodDtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoaXRlbS5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGVZKCR7b2Zmc2V0WX1weGApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGZpcnN0IGdyb3VwIGhlYWRlciBmcm9tIHRoZSBkYXRhIHNldCBpcyBpbiB0aGUgdGFyZ2V0ZWQgdmlydHVhbCBwYWdlLlxuICAgICAqL1xuICAgIGZpcnN0R3JvdXBIZWFkZXJJblRhcmdldGVkUGFnZShpdGVtSW5kZXgpIHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy52aXJ0dWFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmlydHVhbC5za2lwID09PSAwICYmICh0aGlzLnZpcnR1YWwucGFnZVNpemUgPiBpdGVtSW5kZXgpO1xuICAgIH1cbn1cbkxpc3RDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWxpc3QnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPGRpdiAqbmdJZj1cImRhdGFTZXJ2aWNlLmdyb3VwZWRcIlxuICAgICAgICBjbGFzcz0nay1vdXRlci1ncm91cC1oZWFkZXIgay1maXJzdCdcbiAgICAgICAgW25nQ2xhc3NdPVwieydrLXZpcnR1YWwtaXRlbSc6IHZpcnR1YWx9XCJcbiAgICAgICAgW25nU3R5bGVdPVwie1xuICAgICAgICAgICAgJ2hlaWdodC5weCc6IHZpcnR1YWw/Lml0ZW1IZWlnaHQsXG4gICAgICAgICAgICAnbWluSGVpZ2h0LnB4JyA6IHZpcnR1YWw/Lml0ZW1IZWlnaHQsXG4gICAgICAgICAgICAnYm94U2l6aW5nJyA6IHZpcnR1YWwgPyAnYm9yZGVyLWJveCcgOiAnaW5oZXJpdCd9XCJcbiAgICAgICAgPlxuICAgICAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCJmaXhlZEdyb3VwVGVtcGxhdGVcIlxuICAgICAgICAgICAgW3RlbXBsYXRlQ29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVSZWY6IGZpeGVkR3JvdXBUZW1wbGF0ZS50ZW1wbGF0ZVJlZixcbiAgICAgICAgICAgICAgICAkaW1wbGljaXQ6IGN1cnJlbnRHcm91cFxuICAgICAgICAgICAgfVwiPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWZpeGVkR3JvdXBUZW1wbGF0ZVwiPjxzdHJvbmc+e3sgY3VycmVudEdyb3VwIH19PC9zdHJvbmc+IDwvbmctdGVtcGxhdGU+XG4gICAgPC9kaXY+XG4gICAgPGRpdiAjY29udGVudFxuICAgICAgICAgW25nQ2xhc3NdPVwieyAnay12aXJ0dWFsLWNvbnRlbnQnOiB2aXJ0dWFsLCAnay1saXN0LXNjcm9sbGVyJzogIXZpcnR1YWwgfVwiXG4gICAgICAgICBbc3R5bGUubWF4SGVpZ2h0LnB4XT1cImhlaWdodFwiXG4gICAgICAgICB1bnNlbGVjdGFibGU9XCJvblwiPlxuICAgIDx1bCAjbGlzdFxuICAgICAgICByb2xlPVwibGlzdGJveFwiXG4gICAgICAgIGNsYXNzPVwiay1saXN0IGstcmVzZXRcIlxuICAgICAgICBbbmdDbGFzc109XCJ7ICdrLXZpcnR1YWwtbGlzdCc6IHZpcnR1YWwgfVwiXG4gICAgICAgIFthdHRyLmlkXT1cImlkXCJcbiAgICAgICAgW2F0dHIuYXJpYS1oaWRkZW5dPVwiIXNob3dcIj5cbiAgICAgICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cIiFkYXRhU2VydmljZS5ncm91cGVkICYmIHNob3dcIiBuZ0ZvciBsZXQtZGF0YUl0ZW0gbGV0LWl0ZW1JbmRleD1cImluZGV4XCIgW25nRm9yT2ZdPVwiZGF0YVwiPlxuICAgICAgICAgICAgPGxpXG4gICAgICAgICAgICAgICAgcm9sZT1cIm9wdGlvblwiXG4gICAgICAgICAgICAgICAga2VuZG9Ecm9wRG93bnNTZWxlY3RhYmxlXG4gICAgICAgICAgICAgICAgW2hlaWdodF09XCJ2aXJ0dWFsPy5pdGVtSGVpZ2h0XCJcbiAgICAgICAgICAgICAgICBbaW5kZXhdPVwiaXRlbUluZGV4ICsgc3RhcnRGcm9tXCJcbiAgICAgICAgICAgICAgICBbbXVsdGlwbGVTZWxlY3Rpb25dPVwibXVsdGlwbGVTZWxlY3Rpb25cIlxuICAgICAgICAgICAgICAgIFthdHRyLmlkXT1cIm9wdGlvblByZWZpeCArICctJyArIGdldFZhbHVlKGRhdGFJdGVtKVwiXG4gICAgICAgICAgICAgICAgW2F0dHIudGFiSW5kZXhdPVwiLTFcIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwiay1pdGVtXCJcbiAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJ7ICdrLXZpcnR1YWwtaXRlbSc6IHZpcnR1YWwsICdrLXN0YXRlLWRpc2FibGVkJzogaXNEaXNhYmxlZChpdGVtSW5kZXgpIH1cIj5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCJ0ZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgIFt0ZW1wbGF0ZUNvbnRleHRdPVwie1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVSZWY6IHRlbXBsYXRlLnRlbXBsYXRlUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgJGltcGxpY2l0OiBkYXRhSXRlbVxuICAgICAgICAgICAgICAgICAgICB9XCI+XG4gICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIXRlbXBsYXRlXCI+e3sgZ2V0VGV4dChkYXRhSXRlbSkgfX08L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCJkYXRhU2VydmljZS5ncm91cGVkXCIgbmdGb3IgbGV0LWRhdGFJdGVtIGxldC1pdGVtSW5kZXg9XCJpbmRleFwiIFtuZ0Zvck9mXT1cImRhdGFcIj5cbiAgICAgICAgICAgIDxsaVxuICAgICAgICAgICAgICAgICpuZ0lmPVwiZGF0YUl0ZW0uaGVhZGVyICYmIGRhdGFJdGVtLmluZGV4ID4gMFwiXG4gICAgICAgICAgICAgICAgcm9sZT1cImdyb3VwXCJcbiAgICAgICAgICAgICAgICBjbGFzcz0nay1vdXRlci1ncm91cC1oZWFkZXInXG4gICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwieyAnay12aXJ0dWFsLWl0ZW0nOiB2aXJ0dWFsIH1cIlxuICAgICAgICAgICAgICAgIFtuZ1N0eWxlXT1cIntcbiAgICAgICAgICAgICAgICAgICAgJ2hlaWdodC5weCc6IHZpcnR1YWw/Lml0ZW1IZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICdtaW5IZWlnaHQucHgnIDogdmlydHVhbD8uaXRlbUhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgJ2JveFNpemluZycgOiB2aXJ0dWFsID8gJ2JvcmRlci1ib3gnIDogJ2luaGVyaXQnfVwiXG4gICAgICAgICAgICAgICAgW2F0dHIuZ3JvdXAtaW5kZXhdPVwiZGF0YUl0ZW0uaW5kZXhcIlxuICAgICAgICAgICAgICAgIFthdHRyLmlkXT1cIm9wdGlvblByZWZpeCArICctJyArIGdldFZhbHVlKGRhdGFJdGVtLnZhbHVlKVwiXG4gICAgICAgICAgICAgICAgW2F0dHIudGFiSW5kZXhdPVwiLTFcIj5cbiAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiZ3JvdXBUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFt0ZW1wbGF0ZUNvbnRleHRdPVwie1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlUmVmOiBncm91cFRlbXBsYXRlLnRlbXBsYXRlUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRpbXBsaWNpdDogZGF0YUl0ZW0udmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfVwiPlxuICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWdyb3VwVGVtcGxhdGVcIj48c3Ryb25nPiB7eyBkYXRhSXRlbS52YWx1ZSB9fTwvc3Ryb25nPiA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgPGxpXG4gICAgICAgICAgICAgICAgKm5nSWY9XCIhZGF0YUl0ZW0uaGVhZGVyXCJcbiAgICAgICAgICAgICAgICByb2xlPVwib3B0aW9uXCJcbiAgICAgICAgICAgICAgICBrZW5kb0Ryb3BEb3duc1NlbGVjdGFibGVcbiAgICAgICAgICAgICAgICBbaGVpZ2h0XT1cInZpcnR1YWw/Lml0ZW1IZWlnaHRcIlxuICAgICAgICAgICAgICAgIFtpbmRleF09XCJkYXRhSXRlbS5vZmZzZXRJbmRleFwiXG4gICAgICAgICAgICAgICAgW211bHRpcGxlU2VsZWN0aW9uXT1cIm11bHRpcGxlU2VsZWN0aW9uXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5hYnNvbHV0ZS1pbmRleF09XCJkYXRhSXRlbS5pbmRleFwiXG4gICAgICAgICAgICAgICAgW2F0dHIuaWRdPVwib3B0aW9uUHJlZml4ICsgJy0nICsgZ2V0VmFsdWUoZGF0YUl0ZW0udmFsdWUpXCJcbiAgICAgICAgICAgICAgICBbYXR0ci50YWJJbmRleF09XCItMVwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJrLWl0ZW1cIlxuICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cInsgJ2stdmlydHVhbC1pdGVtJzogdmlydHVhbCwgJ2stc3RhdGUtZGlzYWJsZWQnOiBpc0Rpc2FibGVkKGRhdGFJdGVtLm9mZnNldEluZGV4KSB9XCI+XG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwidGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICBbdGVtcGxhdGVDb250ZXh0XT1cIntcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlUmVmOiB0ZW1wbGF0ZS50ZW1wbGF0ZVJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICRpbXBsaWNpdDogZGF0YUl0ZW0udmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfVwiPlxuICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiF0ZW1wbGF0ZVwiPnt7IGdldFRleHQoZGF0YUl0ZW0udmFsdWUpIH19PC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPC91bD5cbiAgICA8ZGl2ICpuZ0lmPVwidmlydHVhbFwiIGNsYXNzPVwiay1oZWlnaHQtY29udGFpbmVyXCIgcm9sZT1cInByZXNlbnRhdGlvblwiPlxuICAgICAgICA8ZGl2IFtzdHlsZS5oZWlnaHQucHhdPVwic2Nyb2xsSGVpZ2h0XCI+PC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuTGlzdENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IERhdGFTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBTZWxlY3Rpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBEaXNhYmxlZEl0ZW1zU2VydmljZSB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyIH1cbl07XG5MaXN0Q29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHNlbGVjdGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmb2N1c2VkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0ZXh0RmllbGQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZhbHVlRmllbGQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGhlaWdodDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGVtcGxhdGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGdyb3VwVGVtcGxhdGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpeGVkR3JvdXBUZW1wbGF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2hvdzogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG9wdGlvblByZWZpeDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbXVsdGlwbGVTZWxlY3Rpb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZpcnR1YWw6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRhdGE6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG9uQ2xpY2s6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBwYWdlQ2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgaXRlbXM6IFt7IHR5cGU6IFZpZXdDaGlsZHJlbiwgYXJnczogW0xpc3RJdGVtRGlyZWN0aXZlLF0gfV0sXG4gICAgY29udGVudDogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ2NvbnRlbnQnLF0gfV0sXG4gICAgbGlzdDogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ2xpc3QnLF0gfV1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBERUZBVUxUUyA9IHtcbiAgICBwYWdlU2l6ZTogNTAsXG4gICAgaXRlbUhlaWdodDogMjhcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgbm9ybWFsaXplVmlydHVhbGl6YXRpb25TZXR0aW5ncyA9IChzZXR0aW5ncykgPT4ge1xuICAgIGlmIChzZXR0aW5ncyA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gREVGQVVMVFM7XG4gICAgfVxuICAgIGlmICghc2V0dGluZ3MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgcGFnZVNpemU6IERFRkFVTFRTLnBhZ2VTaXplIH0sIHNldHRpbmdzKTtcbn07XG5cbi8qIHRzbGludDpkaXNhYmxlOm5vLW51bGwta2V5d29yZCAqL1xuY29uc3QgTk9fVkFMVUUgPSBcIlwiO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IEFVVE9DT01QTEVURV9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICBtdWx0aTogdHJ1ZSxcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdXNlLWJlZm9yZS1kZWNsYXJlXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQXV0b0NvbXBsZXRlQ29tcG9uZW50KVxufTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIEF1dG9Db21wbGV0ZSBjb21wb25lbnQgZm9yIEFuZ3VsYXJdKHslIHNsdWcgb3ZlcnZpZXdfYXV0b2NvbXBsZXRlICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIF9AQ29tcG9uZW50KHtcbiAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqIHRlbXBsYXRlOiBgXG4gKiAgPGtlbmRvLWF1dG9jb21wbGV0ZVxuICogICAgICBbZGF0YV09XCJsaXN0SXRlbXNcIlxuICogICAgICBbcGxhY2Vob2xkZXJdPVwicGxhY2Vob2xkZXJcIlxuICogID5cbiAqIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICBwdWJsaWMgcGxhY2Vob2xkZXI6IHN0cmluZyA9ICdUeXBlIFwiaXRcIiBmb3Igc3VnZ2VzdGlvbnMnO1xuICogICBwdWJsaWMgbGlzdEl0ZW1zOiBBcnJheTxzdHJpbmc+ID0gW1wiSXRlbSAxXCIsIFwiSXRlbSAyXCIsIFwiSXRlbSAzXCIsIFwiSXRlbSA0XCJdO1xuICogfVxuICogYGBgXG4gKi9cbmNsYXNzIEF1dG9Db21wbGV0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uLCBkYXRhU2VydmljZSwgcG9wdXBTZXJ2aWNlLCBzZWxlY3Rpb25TZXJ2aWNlLCBuYXZpZ2F0aW9uU2VydmljZSwgZGlzYWJsZWRJdGVtc1NlcnZpY2UsIF96b25lLCBjZHIsIHJlbmRlcmVyLCB3cmFwcGVyKSB7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLmRhdGFTZXJ2aWNlID0gZGF0YVNlcnZpY2U7XG4gICAgICAgIHRoaXMucG9wdXBTZXJ2aWNlID0gcG9wdXBTZXJ2aWNlO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UgPSBzZWxlY3Rpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlID0gbmF2aWdhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuZGlzYWJsZWRJdGVtc1NlcnZpY2UgPSBkaXNhYmxlZEl0ZW1zU2VydmljZTtcbiAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xuICAgICAgICB0aGlzLmNkciA9IGNkcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB3aGV0aGVyIHRoZSBmaXJzdCBtYXRjaCBmcm9tIHRoZSBzdWdnZXN0aW9ucyBsaXN0IHdpbGwgYmUgYXV0b21hdGljYWxseSBmb2N1c2VkLlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCBgaGlnaGxpZ2h0Rmlyc3RgIGlzIHNldCB0byBgdHJ1ZWAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhpZ2hsaWdodEZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZm9jdXNhYmxlSWQgPSBgay0ke2d1aWQoKX1gO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhpbnQgd2hpY2ggaXMgZGlzcGxheWVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBlbXB0eS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBcIlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBzdWdnZXN0aW9ucyBsaXN0LiBCeSBkZWZhdWx0LCBgbGlzdEhlaWdodGAgaXMgMjAwcHguXG4gICAgICAgICAqXG4gICAgICAgICAqID4gVGhlIGBsaXN0SGVpZ2h0YCBwcm9wZXJ0eSBhZmZlY3RzIG9ubHkgdGhlIGxpc3Qgb2Ygc3VnZ2VzdGlvbnMgYW5kIG5vdCB0aGUgd2hvbGUgcG9wdXAgY29udGFpbmVyLlxuICAgICAgICAgKiA+IFRvIHNldCB0aGUgaGVpZ2h0IG9mIHRoZSBwb3B1cCBjb250YWluZXIsIHVzZSBgcG9wdXBTZXR0aW5ncy5oZWlnaHRgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0SGVpZ2h0ID0gMjAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBzZXQgdG8gYHRydWVgLCByZW5kZXJzIGEgYnV0dG9uIG9uIGhvdmVyaW5nIG92ZXIgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICogQ2xpY2tpbmcgdGhpcyBidXR0b24gcmVzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgY29tcG9uZW50IHRvIGB1bmRlZmluZWRgIGFuZCB0cmlnZ2VycyB0aGUgYGNoYW5nZWAgZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsZWFyQnV0dG9uID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGRpc2FibGVkIHN0YXRlIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSByZWFkLW9ubHkgc3RhdGUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhZG9ubHkgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgW2B0YWJpbmRleGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXgpIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZXMgdGhlIFtmaWx0ZXJpbmddKHslIHNsdWcgZmlsdGVyaW5nX2F1dG9jb21wbGV0ZSAlfSkgZnVuY3Rpb25hbGl0eS5cbiAgICAgICAgICogSWYgc2V0IHRvIGB0cnVlYCwgdGhlIGNvbXBvbmVudCBlbWl0cyB0aGUgYGZpbHRlckNoYW5nZWAgZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbHRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdmFsdWUgaXMgY2hhbmdlZCZtZGFzaDtcbiAgICAgICAgICogd2hlbiB0aGUgY29tcG9uZW50IGlzIGJsdXJyZWQgb3IgdGhlIHZhbHVlIGlzIGNsZWFyZWQgdGhyb3VnaCB0aGUgKipDbGVhcioqIGJ1dHRvblxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X2F1dG9jb21wbGV0ZSAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqIFdoZW4gdGhlIHZhbHVlIG9mIHRoZSBjb21wb25lbnQgaXMgcHJvZ3JhbW1hdGljYWxseSBjaGFuZ2VkIHRvIGBuZ01vZGVsYCBvciBgZm9ybUNvbnRyb2xgXG4gICAgICAgICAqIHRocm91Z2ggaXRzIEFQSSBvciBmb3JtIGJpbmRpbmcsIHRoZSBgdmFsdWVDaGFuZ2VgIGV2ZW50IGlzIG5vdCB0cmlnZ2VyZWQgYmVjYXVzZSBpdFxuICAgICAgICAgKiBtaWdodCBjYXVzZSBhIG1peC11cCB3aXRoIHRoZSBidWlsdC1pbiBgdmFsdWVDaGFuZ2VgIG1lY2hhbmlzbXMgb2YgdGhlIGBuZ01vZGVsYCBvciBgZm9ybUNvbnRyb2xgIGJpbmRpbmdzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdXNlciB0eXBlcyBpbiB0aGUgaW5wdXQgZmllbGQuXG4gICAgICAgICAqIFlvdSBjYW4gZmlsdGVyIHRoZSBzb3VyY2UgYmFzZWQgb24gdGhlIHBhc3NlZCBmaWx0cmF0aW9uIHZhbHVlXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfYXV0b2NvbXBsZXRlICV9I3RvYy1ldmVudHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsdGVyQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBwb3B1cCBpcyBhYm91dCB0byBvcGVuLlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIHByZXZlbnRhYmxlLiBJZiB5b3UgY2FuY2VsIGl0LCB0aGUgcG9wdXAgd2lsbCByZW1haW4gY2xvc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcGVuID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBwb3B1cCBpcyBhYm91dCB0byBjbG9zZS5cbiAgICAgICAgICogVGhpcyBldmVudCBpcyBwcmV2ZW50YWJsZS4gSWYgeW91IGNhbmNlbCBpdCwgdGhlIHBvcHVwIHdpbGwgcmVtYWluIG9wZW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIGZvY3VzZXMgdGhlIEF1dG9Db21wbGV0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25Gb2N1cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTsgLy90c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLW91dHB1dC1yZW5hbWVcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgQXV0b0NvbXBsZXRlIGdldHMgYmx1cnJlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25CbHVyID0gbmV3IEV2ZW50RW1pdHRlcigpOyAvL3RzbGludDpkaXNhYmxlLWxpbmU6bm8tb3V0cHV0LXJlbmFtZVxuICAgICAgICB0aGlzLndpZGdldENsYXNzZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLmxpc3RCb3hJZCA9IGd1aWQoKTtcbiAgICAgICAgdGhpcy5vcHRpb25QcmVmaXggPSBndWlkKCk7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IChfdmFsdWUpID0+IHsgfTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjayA9IChfKSA9PiB7IH07XG4gICAgICAgIHRoaXMucG9wdXBNb3VzZURvd25IYW5kbGVyID0gKGV2ZW50KSA9PiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLl9wb3B1cFNldHRpbmdzID0geyBhbmltYXRlOiB0cnVlIH07XG4gICAgICAgIHRoaXMuX29wZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLl9wcmV2aW91c1ZhbHVlID0gTk9fVkFMVUU7XG4gICAgICAgIHRoaXMuX2ZpbHRlcmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlU3ViamVjdCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuX2lzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IGxvY2FsaXphdGlvbi5ydGwgPyAncnRsJyA6ICdsdHInO1xuICAgICAgICB0aGlzLndyYXBwZXIgPSB3cmFwcGVyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLnN1YnNjcmliZUV2ZW50cygpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UucmVzZXRTZWxlY3Rpb24oWy0xXSk7XG4gICAgfVxuICAgIGdldCB3aWR0aCgpIHtcbiAgICAgICAgbGV0IHdyYXBwZXJPZmZzZXRXaWR0aCA9IDA7XG4gICAgICAgIGlmIChpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHdyYXBwZXJPZmZzZXRXaWR0aCA9IHRoaXMud3JhcHBlci5vZmZzZXRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMucG9wdXBTZXR0aW5ncy53aWR0aCB8fCB3cmFwcGVyT2Zmc2V0V2lkdGg7XG4gICAgICAgIGNvbnN0IG1pbldpZHRoID0gaXNOYU4od3JhcHBlck9mZnNldFdpZHRoKSA/IHdyYXBwZXJPZmZzZXRXaWR0aCA6IGAke3dyYXBwZXJPZmZzZXRXaWR0aH1weGA7XG4gICAgICAgIGNvbnN0IG1heFdpZHRoID0gaXNOYU4od2lkdGgpID8gd2lkdGggOiBgJHt3aWR0aH1weGA7XG4gICAgICAgIHJldHVybiB7IG1pbjogbWluV2lkdGgsIG1heDogbWF4V2lkdGggfTtcbiAgICB9XG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgY29uc3QgcG9wdXBIZWlnaHQgPSB0aGlzLnBvcHVwU2V0dGluZ3MuaGVpZ2h0O1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHBvcHVwSGVpZ2h0KSA/IGAke3BvcHVwSGVpZ2h0fXB4YCA6ICdhdXRvJztcbiAgICB9XG4gICAgZ2V0IGxpc3RDb250YWluZXJDbGFzc2VzKCkge1xuICAgICAgICBjb25zdCBjb250YWluZXJDbGFzc2VzID0gWydrLWxpc3QtY29udGFpbmVyJywgJ2stcmVzZXQnXTtcbiAgICAgICAgaWYgKHRoaXMucG9wdXBTZXR0aW5ncy5wb3B1cENsYXNzKSB7XG4gICAgICAgICAgICBjb250YWluZXJDbGFzc2VzLnB1c2godGhpcy5wb3B1cFNldHRpbmdzLnBvcHVwQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250YWluZXJDbGFzc2VzO1xuICAgIH1cbiAgICBnZXQgc3VnZ2VzdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRleHQgfHwgIXRoaXMuc3VnZ2VzdGVkVGV4dCkge1xuICAgICAgICAgICAgdGhpcy5zdWdnZXN0ZWRUZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc01hdGNoID0gdGhpcy5zdWdnZXN0ZWRUZXh0LnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCh0aGlzLnRleHQudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGNvbnN0IHNob3VsZFN1Z2dlc3QgPSB0aGlzLnN1Z2dlc3QgJiYgIXRoaXMuYmFja3NwYWNlUHJlc3NlZDtcbiAgICAgICAgaWYgKHNob3VsZFN1Z2dlc3QgJiYgaGFzTWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1Z2dlc3RlZFRleHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGFwcGVuZFRvKCkge1xuICAgICAgICBjb25zdCB7IGFwcGVuZFRvIH0gPSB0aGlzLnBvcHVwU2V0dGluZ3M7XG4gICAgICAgIGlmICghYXBwZW5kVG8gfHwgYXBwZW5kVG8gPT09ICdyb290Jykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwZW5kVG8gPT09ICdjb21wb25lbnQnID8gdGhpcy5jb250YWluZXIgOiBhcHBlbmRUbztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgcG9wdXAuXG4gICAgICogSWYgeW91IHVzZSB0aGUgYHRvZ2dsZWAgbWV0aG9kIHRvIG9wZW4gb3IgY2xvc2UgdGhlIHBvcHVwLCB0aGUgYG9wZW5gIGFuZCBgY2xvc2VgIGV2ZW50cyB3aWxsIG5vdCBiZSBmaXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcGVuIC0gVGhlIHN0YXRlIG9mIHRoZSBwb3B1cC5cbiAgICAgKi9cbiAgICB0b2dnbGUob3Blbikge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUobnVsbCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGUob3Blbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG9wZW4gc3RhdGUgb2YgdGhlIHBvcHVwLlxuICAgICAqL1xuICAgIGdldCBpc09wZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcGVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdG9nZ2xlUG9wdXAob3Blbikge1xuICAgICAgICBjb25zdCBpc0Rpc2FibGVkID0gdGhpcy5kaXNhYmxlZCB8fCB0aGlzLnJlYWRvbmx5O1xuICAgICAgICBjb25zdCBzYW1lU3RhdGUgPSB0aGlzLmlzT3BlbiA9PT0gb3BlbjtcbiAgICAgICAgaWYgKGlzRGlzYWJsZWQgfHwgc2FtZVN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNEZWZhdWx0UHJldmVudGVkID0gdGhpcy50cmlnZ2VyUG9wdXBFdmVudHMob3Blbik7XG4gICAgICAgIGlmICghaXNEZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGUob3Blbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGFjdGl2ZURlc2NlbmRhbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4gfHwgIWlzUHJlc2VudCh0aGlzLnNlbGVjdGlvblNlcnZpY2UuZm9jdXNlZCkgfHwgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmZvY3VzZWQgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhSXRlbSA9IHRoaXMuZGF0YVNlcnZpY2UuaXRlbUF0KHRoaXMuc2VsZWN0aW9uU2VydmljZS5mb2N1c2VkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uUHJlZml4ICsgXCItXCIgKyBnZXR0ZXIoZGF0YUl0ZW0sIHRoaXMudmFsdWVGaWVsZCk7XG4gICAgfVxuICAgIGdldCBub0RhdGFMYWJlbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vRGF0YVRleHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNsZWFyVGl0bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvbi5nZXQoJ2NsZWFyVGl0bGUnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGF0YSBvZiB0aGUgQXV0b0NvbXBsZXRlLlxuICAgICAqXG4gICAgICogPiBUaGUgZGF0YSBoYXMgdG8gYmUgcHJvdmlkZWQgaW4gYW4gYXJyYXktbGlrZSBsaXN0LlxuICAgICAqL1xuICAgIHNldCBkYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhU2VydmljZS5kYXRhID0gZGF0YSB8fCBbXTtcbiAgICAgICAgaWYgKHRoaXMudmlydHVhbCkge1xuICAgICAgICAgICAgdGhpcy52aXJ0dWFsLnNraXAgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U3RhdGUodGhpcy52YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLmZpbHRlcmFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5mb2N1c2VkID0gdGhpcy5pc09wZW4gJiYgdGhpcy5kYXRhLmxlbmd0aCAmJiB0aGlzLmhpZ2hsaWdodEZpcnN0ID8gdGhpcy5maXJzdEZvY3VzYWJsZUluZGV4KDApIDogLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3VnZ2VzdCAmJiB0aGlzLmRhdGFTZXJ2aWNlLml0ZW1zQ291bnQgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnN1Z2dlc3RlZFRleHQgPSBnZXR0ZXIodGhpcy5kYXRhU2VydmljZS5pdGVtQXQoMCksIHRoaXMudmFsdWVGaWVsZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIGNvbnN0IHZpcnR1YWwgPSB0aGlzLnZpcnR1YWw7XG4gICAgICAgIGlmICh2aXJ0dWFsKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHZpcnR1YWwuc2tpcCB8fCAwO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gc3RhcnQgKyB2aXJ0dWFsLnBhZ2VTaXplO1xuICAgICAgICAgICAgLy8gVXNlIGxlbmd0aCBpbnN0ZWFkIG9mIGl0ZW1zQ291bnQgYmVjYXVzZSBvZiB0aGUgZ3JvdXBpbmcuXG4gICAgICAgICAgICB2aXJ0dWFsLnRvdGFsID0gdGhpcy5kYXRhU2VydmljZS5kYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTZXJ2aWNlLmRhdGEuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNlcnZpY2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIEF1dG9Db21wbGV0ZS5cbiAgICAgKi9cbiAgICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlTZXR0aW5ncyhuZXdWYWx1ZSk7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbmV3VmFsdWUgfHwgTk9fVkFMVUU7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZSB8fCBOT19WQUxVRTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyB0aGUgcG9wdXAgb2YgdGhlIEF1dG9Db21wbGV0ZS5cbiAgICAgKlxuICAgICAqIFRoZSBhdmFpbGFibGUgb3B0aW9ucyBhcmU6XG4gICAgICogLSBgYW5pbWF0ZTogQm9vbGVhbmAmbWRhc2g7Q29udHJvbHMgdGhlIHBvcHVwIGFuaW1hdGlvbi4gQnkgZGVmYXVsdCwgdGhlIG9wZW4gYW5kIGNsb3NlIGFuaW1hdGlvbnMgYXJlIGVuYWJsZWQuXG4gICAgICogLSBgd2lkdGg6IE51bWJlciB8IFN0cmluZ2AmbWRhc2g7U2V0cyB0aGUgd2lkdGggb2YgdGhlIHBvcHVwIGNvbnRhaW5lci4gQnkgZGVmYXVsdCwgdGhlIHdpZHRoIG9mIHRoZSBob3N0IGVsZW1lbnQgaXMgdXNlZC4gSWYgc2V0IHRvIGBhdXRvYCwgdGhlIGNvbXBvbmVudCBhdXRvbWF0aWNhbGx5IGFkanVzdHMgdGhlIHdpZHRoIG9mIHRoZSBwb3B1cCBhbmQgbm8gaXRlbSBsYWJlbHMgYXJlIHdyYXBwZWQuIFRoZSBgYXV0b2AgbW9kZSBpcyBub3Qgc3VwcG9ydGVkIHdoZW4gdmlydHVhbCBzY3JvbGxpbmcgaXMgZW5hYmxlZC5cbiAgICAgKiAtIGBoZWlnaHQ6IE51bWJlcmAmbWRhc2g7U2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBwb3B1cCBjb250YWluZXIuXG4gICAgICogLSBgcG9wdXBDbGFzczogU3RyaW5nYCZtZGFzaDtTcGVjaWZpZXMgYSBsaXN0IG9mIENTUyBjbGFzc2VzIHRoYXQgYXJlIHVzZWQgdG8gc3R5bGUgdGhlIHBvcHVwLlxuICAgICAqIC0gYGFwcGVuZFRvOiBcInJvb3RcIiB8IFwiY29tcG9uZW50XCIgfCBWaWV3Q29udGFpbmVyUmVmYCZtZGFzaDtTcGVjaWZpZXMgdGhlIGNvbXBvbmVudCB0byB3aGljaCB0aGUgcG9wdXAgd2lsbCBiZSBhcHBlbmRlZC5cbiAgICAgKi9cbiAgICBzZXQgcG9wdXBTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgICAgICB0aGlzLl9wb3B1cFNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7IGFuaW1hdGU6IHRydWUgfSwgc2V0dGluZ3MpO1xuICAgIH1cbiAgICBnZXQgcG9wdXBTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcHVwU2V0dGluZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZXMgYSBCb29sZWFuIGZ1bmN0aW9uIHRoYXQgaXMgZXhlY3V0ZWQgZm9yIGVhY2ggZGF0YSBpdGVtIGluIHRoZSBjb21wb25lbnRcbiAgICAgKiAoW3NlZSBleGFtcGxlc10oeyUgc2x1ZyBkaXNhYmxlZGl0ZW1zX2F1dG9jb21wbGV0ZSAlfSkpLlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgaXRlbSB3aWxsIGJlIGRpc2FibGVkLlxuICAgICAqL1xuICAgIHNldCBpdGVtRGlzYWJsZWQoZm4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpdGVtRGlzYWJsZWQgbXVzdCBiZSBhIGZ1bmN0aW9uLCBidXQgcmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeShmbil9LmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzYWJsZWRJdGVtc1NlcnZpY2UuaXRlbURpc2FibGVkID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgdGFiSW5kZXgodGFiSW5kZXgpIHtcbiAgICAgICAgdGhpcy50YWJpbmRleCA9IHRhYkluZGV4O1xuICAgIH1cbiAgICBnZXQgdGFiSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhYmluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRoZSBbdmlydHVhbGl6YXRpb25dKHslIHNsdWcgdmlydHVhbGl6YXRpb25fYXV0b2NvbXBsZXRlICV9KSBmdW5jdGlvbmFsaXR5LlxuICAgICAqL1xuICAgIHNldCB2aXJ0dWFsKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuX3ZpcnR1YWxTZXR0aW5ncyA9IG5vcm1hbGl6ZVZpcnR1YWxpemF0aW9uU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgIH1cbiAgICBnZXQgdmlydHVhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpcnR1YWxTZXR0aW5ncztcbiAgICB9XG4gICAgZ2V0IGlzRm9jdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRm9jdXNlZDtcbiAgICB9XG4gICAgc2V0IGlzRm9jdXNlZChpc0ZvY3VzZWQpIHtcbiAgICAgICAgdGhpcy5faXNGb2N1c2VkID0gaXNGb2N1c2VkO1xuICAgIH1cbiAgICBnZXQgaXNEaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQ7XG4gICAgfVxuICAgIGdldCBkaXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGlvbjtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQXR0cmlidXRlKHRoaXMud3JhcHBlciwgXCJ0YWJpbmRleFwiKTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb25DaGFuZ2VTdWJzY3JpcHRpb24gPSB0aGlzLmxvY2FsaXphdGlvblxuICAgICAgICAgICAgLmNoYW5nZXNcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHsgcnRsIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gcnRsID8gJ3J0bCcgOiAnbHRyJztcbiAgICAgICAgICAgIHRoaXMuc2V0TWVzc2FnZXMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0TWVzc2FnZXMoKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveVBvcHVwKCk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVFdmVudHMoKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubWVzc2FnZXNUaW1lb3V0KTtcbiAgICAgICAgaWYgKHRoaXMubG9jYWxpemF0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsaXphdGlvbkNoYW5nZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgY29uc3QgdmlydHVhbCA9IHRoaXMudmlydHVhbDtcbiAgICAgICAgY29uc3QgcmVxdWVzdEluaXRpYWxEYXRhID0gdmlydHVhbCAmJiBjaGFuZ2VzLmRhdGEgJiYgY2hhbmdlcy5kYXRhLmlzRmlyc3RDaGFuZ2UoKTtcbiAgICAgICAgaWYgKHJlcXVlc3RJbml0aWFsRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5wYWdlQ2hhbmdlKHsgc2tpcDogMCwgdGFrZTogdmlydHVhbC5wYWdlU2l6ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBTVEFURV9QUk9QUyA9IC8odmFsdWV8dmFsdWVGaWVsZCkvZztcbiAgICAgICAgaWYgKFNUQVRFX1BST1BTLnRlc3QoT2JqZWN0LmtleXMoY2hhbmdlcykuam9pbigpKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIHZhbHVlIG9mIHRoZSBBdXRvQ29tcGxldGUuXG4gICAgICogSWYgeW91IHVzZSB0aGUgYHJlc2V0YCBtZXRob2QgdG8gY2xlYXIgdGhlIHZhbHVlIG9mIHRoZSBjb21wb25lbnQsXG4gICAgICogdGhlIG1vZGVsIHdpbGwgbm90IHVwZGF0ZSBhdXRvbWF0aWNhbGx5IGFuZCB0aGUgYHNlbGVjdGlvbkNoYW5nZWAgYW5kIGB2YWx1ZUNoYW5nZWAgZXZlbnRzIHdpbGwgbm90IGJlIGZpcmVkLlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKE5PX1ZBTFVFKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNsZWFyVmFsdWUoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5jaGFuZ2UoTk9fVkFMVUUpO1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlckNoYW5nZS5lbWl0KCcnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UucmVzZXRTZWxlY3Rpb24oW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbikge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIEF1dG9Db21wbGV0ZS5cbiAgICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNlYXJjaGJhci5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJsdXJzIHRoZSBBdXRvQ29tcGxldGUuXG4gICAgICovXG4gICAgYmx1cigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNlYXJjaGJhci5ibHVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uUmVzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5fb3Blbikge1xuICAgICAgICAgICAgY29uc3QgcG9wdXBXcmFwcGVyID0gdGhpcy5wb3B1cFJlZi5wb3B1cEVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCB7IG1pbiwgbWF4IH0gPSB0aGlzLndpZHRoO1xuICAgICAgICAgICAgcG9wdXBXcmFwcGVyLnN0eWxlLm1pbldpZHRoID0gbWluO1xuICAgICAgICAgICAgcG9wdXBXcmFwcGVyLnN0eWxlLndpZHRoID0gbWF4O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVtaXRDaGFuZ2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSB0aGlzLl9wcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJldmlvdXNWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayh0aGlzLnZhbHVlKTtcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICB2ZXJpZnlTZXR0aW5ncyhuZXdWYWx1ZSkge1xuICAgICAgICBpZiAoIWlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJlc2VudChuZXdWYWx1ZSkgJiYgdHlwZW9mIG5ld1ZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCB2YWx1ZSBvZiB0eXBlIHN0cmluZy4gU2VlIGh0dHA6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL2Ryb3Bkb3ducy9hdXRvY29tcGxldGUvI3RvYy12YWx1ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWFyY2godGV4dCwgc3RhcnRGcm9tID0gMCkge1xuICAgICAgICBsZXQgaW5kZXg7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCAmJiB0aGlzLmRhdGFTZXJ2aWNlLml0ZW1zQ291bnQpIHtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5kYXRhU2VydmljZS5maW5kSW5kZXgodGhpcy5maW5kSW5kZXhQcmVkaWNhdGUodGV4dCksIHN0YXJ0RnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkSXRlbXNTZXJ2aWNlLmlzSW5kZXhEaXNhYmxlZChpbmRleCkpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCArIDEgPCB0aGlzLmRhdGFTZXJ2aWNlLml0ZW1zQ291bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaCh0ZXh0LCBpbmRleCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmZvY3VzKC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5mb2N1cyhpbmRleCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdWdnZXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWdnZXN0ZWRUZXh0ID0gZ2V0dGVyKHRoaXMuZGF0YVNlcnZpY2UuaXRlbUF0KGluZGV4KSwgdGhpcy52YWx1ZUZpZWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBuYXZpZ2F0ZShpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmZvY3VzKGluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZU5hdmlnYXRlKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGZvY3VzZWQgPSBpc05hTih0aGlzLnNlbGVjdGlvblNlcnZpY2UuZm9jdXNlZCkgPyB0aGlzLmZpcnN0Rm9jdXNhYmxlSW5kZXgoMCkgOiB0aGlzLnNlbGVjdGlvblNlcnZpY2UuZm9jdXNlZDtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5yZWFkb25seSB8fCBpc05hTihmb2N1c2VkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMubmF2aWdhdGlvblNlcnZpY2UucHJvY2Vzcyh7XG4gICAgICAgICAgICBjdXJyZW50OiBmb2N1c2VkLFxuICAgICAgICAgICAgbWF4OiB0aGlzLmRhdGFTZXJ2aWNlLml0ZW1zQ291bnQgLSAxLFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhY3Rpb24gIT09IE5hdmlnYXRpb25BY3Rpb24uVW5kZWZpbmVkICYmXG4gICAgICAgICAgICBhY3Rpb24gIT09IE5hdmlnYXRpb25BY3Rpb24uQmFja3NwYWNlICYmXG4gICAgICAgICAgICBhY3Rpb24gIT09IE5hdmlnYXRpb25BY3Rpb24uRGVsZXRlICYmXG4gICAgICAgICAgICBhY3Rpb24gIT09IE5hdmlnYXRpb25BY3Rpb24uSG9tZSAmJlxuICAgICAgICAgICAgYWN0aW9uICE9PSBOYXZpZ2F0aW9uQWN0aW9uLkVuZCAmJlxuICAgICAgICAgICAgYWN0aW9uICE9PSBOYXZpZ2F0aW9uQWN0aW9uLkxlZnQgJiZcbiAgICAgICAgICAgIGFjdGlvbiAhPT0gTmF2aWdhdGlvbkFjdGlvbi5SaWdodCAmJlxuICAgICAgICAgICAgKChhY3Rpb24gPT09IE5hdmlnYXRpb25BY3Rpb24uRW50ZXIgJiYgdGhpcy5pc09wZW4pIHx8IGFjdGlvbiAhPT0gTmF2aWdhdGlvbkFjdGlvbi5FbnRlcikpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRW50ZXIoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZm9jdXNlZCA9IHRoaXMuc2VsZWN0aW9uU2VydmljZS5mb2N1c2VkO1xuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIHRoaXMuX2ZpbHRlcmluZyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9jdXNlZCA+PSAwKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGdldHRlcih0aGlzLmRhdGFTZXJ2aWNlLml0ZW1BdChmb2N1c2VkKSwgdGhpcy52YWx1ZUZpZWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy5zdWdnZXN0ICYmIHRoaXMuc3VnZ2VzdGVkVGV4dCAmJiB0aGlzLmRhdGEubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgZ2V0dGVyKHRoaXMuZGF0YVNlcnZpY2UuaXRlbUF0KDApLCB0aGlzLnZhbHVlRmllbGQsIHRydWUpLnRvTG93ZXJDYXNlKCkgPT09IHRoaXMuc2VhcmNoYmFyLnZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc09wZW4gJiYgbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuc3VnZ2VzdGVkVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5zZWFyY2hiYXIudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFuZ2UodmFsdWUpO1xuICAgIH1cbiAgICBoYW5kbGVFc2NhcGUoKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlUG9wdXAoZmFsc2UpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuZm9jdXNlZCA9IC0xO1xuICAgICAgICB0aGlzLnN1Z2dlc3RlZFRleHQgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2VhcmNoQmFyQ2hhbmdlKHRleHQpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFRleHRMZW5ndGggPSBpc1ByZXNlbnQodGhpcy50ZXh0KSA/IHRoaXMudGV4dC5sZW5ndGggOiAwO1xuICAgICAgICB0aGlzLmJhY2tzcGFjZVByZXNzZWQgPSAodGV4dC5sZW5ndGggPCBjdXJyZW50VGV4dExlbmd0aCkgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMudG9nZ2xlUG9wdXAodGV4dC5sZW5ndGggPiAwKTtcbiAgICAgICAgdGhpcy5fZmlsdGVyaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmhpZ2hsaWdodEZpcnN0KSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuZm9jdXNlZCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZpbHRlcmFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyQ2hhbmdlLmVtaXQodGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5oaWdobGlnaHRGaXJzdCkge1xuICAgICAgICAgICAgdGhpcy5zZWFyY2godGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUZvY3VzKCkge1xuICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMub25Gb2N1cy5lbWl0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVCbHVyKCkge1xuICAgICAgICB0aGlzLl9maWx0ZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgZm9jdXNlZCA9IHRoaXMuZmlsdGVyYWJsZSA/IHRoaXMuc2VsZWN0aW9uU2VydmljZS5mb2N1c2VkIDogLTE7XG4gICAgICAgIGxldCBkYXRhSXRlbTtcbiAgICAgICAgbGV0IHRleHQ7XG4gICAgICAgIGlmIChmb2N1c2VkICE9PSAtMSkge1xuICAgICAgICAgICAgZGF0YUl0ZW0gPSB0aGlzLmRhdGFTZXJ2aWNlLml0ZW1BdChmb2N1c2VkKTtcbiAgICAgICAgICAgIHRleHQgPSBnZXR0ZXIoZGF0YUl0ZW0sIHRoaXMudmFsdWVGaWVsZCwgdHJ1ZSkgfHwgXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLnNlYXJjaGJhci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGFjdE1hdGNoID0gdGV4dCA9PT0gdGhpcy5zZWFyY2hiYXIudmFsdWU7XG4gICAgICAgIGNvbnN0IGluc2Vuc2l0aXZlTWF0Y2ggPSB0ZXh0LnRvTG93ZXJDYXNlKCkgPT09IHRoaXMuc2VhcmNoYmFyLnZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghZXhhY3RNYXRjaCAmJiBpbnNlbnNpdGl2ZU1hdGNoKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UucmVzZXRTZWxlY3Rpb24oW10pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbmdlKHRoaXMuc2VhcmNoYmFyLnZhbHVlKTtcbiAgICAgICAgdGhpcy50b2dnbGVQb3B1cChmYWxzZSk7XG4gICAgICAgIHRoaXMuaXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25CbHVyLmVtaXQoKTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcGFnZUNoYW5nZShldmVudCkge1xuICAgICAgICBjb25zdCB2aXJ0dWFsID0gdGhpcy52aXJ0dWFsO1xuICAgICAgICB2aXJ0dWFsLnNraXAgPSBldmVudC5za2lwO1xuICAgIH1cbiAgICBzZXRTdGF0ZShuZXdWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fZmlsdGVyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLl9wcmV2aW91c1ZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgY2hhbmdlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlUG9wdXAoZmFsc2UpO1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlU3ViamVjdC5uZXh0KHZhbHVlKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlRXZlbnRzKCkge1xuICAgICAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2VTdWJzY3JpcHRpb24gPSB0aGlzLnZhbHVlQ2hhbmdlU3ViamVjdC5waXBlKGZpbHRlcigoY2FuZGlkYXRlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gISh0aGlzLnZhbHVlID09PSBjYW5kaWRhdGUgJiYgdGhpcy50ZXh0ID09PSBjYW5kaWRhdGUpO1xuICAgICAgICB9KSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jaGFuZ2VTdWJzY3JpcHRpb24gPSB0aGlzLnNlbGVjdGlvblNlcnZpY2Uub25DaGFuZ2Uuc3Vic2NyaWJlKHRoaXMuaGFuZGxlSXRlbUNoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5mb2N1c1N1YnNjcmlwdGlvbiA9IHRoaXMuc2VsZWN0aW9uU2VydmljZS5vbkZvY3VzLnN1YnNjcmliZSh0aGlzLmhhbmRsZUl0ZW1Gb2N1cy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU3Vic2NyaXB0aW9uID0gbWVyZ2UodGhpcy5uYXZpZ2F0aW9uU2VydmljZS51cCwgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5kb3duKS5zdWJzY3JpYmUoKGV2ZW50KSA9PiB0aGlzLm5hdmlnYXRlKGV2ZW50LmluZGV4KSk7XG4gICAgICAgIHRoaXMuY2xvc2VTdWJzY3JpcHRpb24gPSB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmNsb3NlLnN1YnNjcmliZSgoKSA9PiB0aGlzLnRvZ2dsZVBvcHVwKGZhbHNlKSk7XG4gICAgICAgIHRoaXMuZW50ZXJTdWJzY3JpcHRpb24gPSB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmVudGVyLnN1YnNjcmliZSh0aGlzLmhhbmRsZUVudGVyLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmVzY1N1YnNjcmlwdGlvbiA9IHRoaXMubmF2aWdhdGlvblNlcnZpY2UuZXNjLnN1YnNjcmliZSh0aGlzLmhhbmRsZUVzY2FwZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmVFdmVudHMoKSB7XG4gICAgICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFuZ2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuY2xvc2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5lbnRlclN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmVzY1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuZm9jdXNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgaGFuZGxlSXRlbUNoYW5nZShldmVudCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGV2ZW50LmluZGljZXMubGVuZ3RoID8gZXZlbnQuaW5kaWNlc1swXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fZmlsdGVyaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5yZXNldFNlbGVjdGlvbihbLTFdKTtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQoaW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRleHQgPSBnZXR0ZXIodGhpcy5kYXRhU2VydmljZS5pdGVtQXQoaW5kZXgpLCB0aGlzLnZhbHVlRmllbGQpO1xuICAgICAgICB0aGlzLmNoYW5nZSh0ZXh0KTtcbiAgICB9XG4gICAgaGFuZGxlSXRlbUZvY3VzKF9ldmVudCkge1xuICAgICAgICBjb25zdCBmb2N1c2VkID0gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmZvY3VzZWQ7XG4gICAgICAgIGNvbnN0IHNob3VsZFN1Z2dlc3QgPSBCb29sZWFuKHRoaXMuc3VnZ2VzdCAmJiB0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmxlbmd0aCAmJiBmb2N1c2VkID49IDApO1xuICAgICAgICBpZiAoc2hvdWxkU3VnZ2VzdCkge1xuICAgICAgICAgICAgdGhpcy5zdWdnZXN0ZWRUZXh0ID0gZ2V0dGVyKHRoaXMuZGF0YVNlcnZpY2UuaXRlbUF0KGZvY3VzZWQpLCB0aGlzLnZhbHVlRmllbGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZVBvcHVwKCkge1xuICAgICAgICBpZiAodGhpcy52aXJ0dWFsKSB7XG4gICAgICAgICAgICB0aGlzLnZpcnR1YWwuc2tpcCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG9yaXpvbnRhbEFsaWduID0gdGhpcy5kaXJlY3Rpb24gPT09IFwicnRsXCIgPyBcInJpZ2h0XCIgOiBcImxlZnRcIjtcbiAgICAgICAgY29uc3QgYW5jaG9yUG9zaXRpb24gPSB7IGhvcml6b250YWw6IGhvcml6b250YWxBbGlnbiwgdmVydGljYWw6IFwiYm90dG9tXCIgfTtcbiAgICAgICAgY29uc3QgcG9wdXBQb3NpdGlvbiA9IHsgaG9yaXpvbnRhbDogaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbDogXCJ0b3BcIiB9O1xuICAgICAgICB0aGlzLnBvcHVwUmVmID0gdGhpcy5wb3B1cFNlcnZpY2Uub3Blbih7XG4gICAgICAgICAgICBhbmNob3I6IHRoaXMud3JhcHBlcixcbiAgICAgICAgICAgIGFuaW1hdGU6IHRoaXMucG9wdXBTZXR0aW5ncy5hbmltYXRlLFxuICAgICAgICAgICAgYXBwZW5kVG86IHRoaXMuYXBwZW5kVG8sXG4gICAgICAgICAgICBjb250ZW50OiB0aGlzLnBvcHVwVGVtcGxhdGUsXG4gICAgICAgICAgICBwb3B1cENsYXNzOiB0aGlzLmxpc3RDb250YWluZXJDbGFzc2VzLFxuICAgICAgICAgICAgcG9zaXRpb25Nb2RlOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgcG9wdXBBbGlnbjogcG9wdXBQb3NpdGlvbixcbiAgICAgICAgICAgIGFuY2hvckFsaWduOiBhbmNob3JQb3NpdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcG9wdXBXcmFwcGVyID0gdGhpcy5wb3B1cFJlZi5wb3B1cEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHsgbWluLCBtYXggfSA9IHRoaXMud2lkdGg7XG4gICAgICAgIHBvcHVwV3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLnBvcHVwTW91c2VEb3duSGFuZGxlcik7XG4gICAgICAgIHBvcHVwV3JhcHBlci5zdHlsZS5taW5XaWR0aCA9IG1pbjtcbiAgICAgICAgcG9wdXBXcmFwcGVyLnN0eWxlLndpZHRoID0gbWF4O1xuICAgICAgICBwb3B1cFdyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIHBvcHVwV3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJkaXJcIiwgdGhpcy5kaXJlY3Rpb24pO1xuICAgICAgICB0aGlzLnBvcHVwUmVmLnBvcHVwT3Blbi5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zTGlzdC5zY3JvbGxUb0l0ZW0odGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmZvY3VzZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wb3B1cFJlZi5wb3B1cEFuY2hvclZpZXdwb3J0TGVhdmUuc3Vic2NyaWJlKCgpID0+IHRoaXMudG9nZ2xlUG9wdXAoZmFsc2UpKTtcbiAgICB9XG4gICAgZGVzdHJveVBvcHVwKCkge1xuICAgICAgICBpZiAodGhpcy5wb3B1cFJlZikge1xuICAgICAgICAgICAgdGhpcy5wb3B1cFJlZi5wb3B1cEVsZW1lbnRcbiAgICAgICAgICAgICAgICAucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5wb3B1cE1vdXNlRG93bkhhbmRsZXIpO1xuICAgICAgICAgICAgdGhpcy5wb3B1cFJlZi5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5wb3B1cFJlZiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3RvZ2dsZShvcGVuKSB7XG4gICAgICAgIHRoaXMuX29wZW4gPSAob3BlbiA9PT0gdW5kZWZpbmVkKSA/ICF0aGlzLl9vcGVuIDogb3BlbjtcbiAgICAgICAgdGhpcy5kZXN0cm95UG9wdXAoKTtcbiAgICAgICAgaWYgKHRoaXMuX29wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlUG9wdXAoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmlnZ2VyUG9wdXBFdmVudHMob3Blbikge1xuICAgICAgICBjb25zdCBldmVudEFyZ3MgPSBuZXcgUHJldmVudGFibGVFdmVudCgpO1xuICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgdGhpcy5vcGVuLmVtaXQoZXZlbnRBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UuZW1pdChldmVudEFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudEFyZ3MuaXNEZWZhdWx0UHJldmVudGVkKCk7XG4gICAgfVxuICAgIGZpcnN0Rm9jdXNhYmxlSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgbWF4SW5kZXggPSB0aGlzLmRhdGEubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWRJdGVtc1NlcnZpY2UuaXNJbmRleERpc2FibGVkKGluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuIChpbmRleCA8IG1heEluZGV4KSA/IHRoaXMuZmlyc3RGb2N1c2FibGVJbmRleChpbmRleCArIDEpIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRJbmRleFByZWRpY2F0ZSh0ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFTZXJ2aWNlLmdyb3VwZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBpdGVtVGV4dCA9IGdldHRlcihpdGVtLnZhbHVlLCB0aGlzLnZhbHVlRmllbGQpO1xuICAgICAgICAgICAgICAgIGl0ZW1UZXh0ID0gIWlzUHJlc2VudChpdGVtVGV4dCkgPyBcIlwiIDogaXRlbVRleHQudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtVGV4dC5zdGFydHNXaXRoKHRleHQudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1UZXh0ID0gZ2V0dGVyKGl0ZW0sIHRoaXMudmFsdWVGaWVsZCk7XG4gICAgICAgICAgICAgICAgaXRlbVRleHQgPSAhaXNQcmVzZW50KGl0ZW1UZXh0KSA/IFwiXCIgOiBpdGVtVGV4dC50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1UZXh0LnN0YXJ0c1dpdGgodGV4dC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0TWVzc2FnZXMoKSB7XG4gICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubWVzc2FnZXNUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZXNUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub0RhdGFUZXh0ID0gdGhpcy5sb2NhbGl6YXRpb24uZ2V0KCdub0RhdGFUZXh0Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbkF1dG9Db21wbGV0ZUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAna2VuZG9BdXRvQ29tcGxldGUnLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICBBVVRPQ09NUExFVEVfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgICAgICAgICAgICAgIERhdGFTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBTZWxlY3Rpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBOYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAgRGlzYWJsZWRJdGVtc1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEwxME5fUFJFRklYLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlVmFsdWU6ICdrZW5kby5hdXRvY29tcGxldGUnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEZpbHRlcmFibGVEcm9wRG93bkNvbXBvbmVudEJhc2UsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEF1dG9Db21wbGV0ZUNvbXBvbmVudClcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogS2VuZG9JbnB1dCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQXV0b0NvbXBsZXRlQ29tcG9uZW50KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWF1dG9jb21wbGV0ZScsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRhaW5lciBrZW5kb0F1dG9Db21wbGV0ZUxvY2FsaXplZE1lc3NhZ2VzXG4gICAgICAgICAgICBpMThuLW5vRGF0YVRleHQ9XCJrZW5kby5hdXRvY29tcGxldGUubm9EYXRhVGV4dHxUaGUgdGV4dCBkaXNwbGF5ZWQgaW4gdGhlIHBvcHVwIHdoZW4gdGhlcmUgYXJlIG5vIGl0ZW1zXCJcbiAgICAgICAgICAgIG5vRGF0YVRleHQ9XCJOTyBEQVRBIEZPVU5EXCJcblxuICAgICAgICAgICAgaTE4bi1jbGVhclRpdGxlPVwia2VuZG8uYXV0b2NvbXBsZXRlLmNsZWFyVGl0bGV8VGhlIHRpdGxlIG9mIHRoZSBjbGVhciBidXR0b25cIlxuICAgICAgICAgICAgY2xlYXJUaXRsZT1cImNsZWFyXCJcbiAgICAgICAgPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPGtlbmRvLXNlYXJjaGJhciAjc2VhcmNoYmFyXG4gICAgICAgICAgICBbcm9sZV09XCInY29tYm9ib3gnXCJcbiAgICAgICAgICAgIFtpZF09XCJmb2N1c2FibGVJZFwiXG4gICAgICAgICAgICBbbGlzdElkXT1cImxpc3RCb3hJZFwiXG4gICAgICAgICAgICBbYWN0aXZlRGVzY2VuZGFudF09XCJhY3RpdmVEZXNjZW5kYW50XCJcbiAgICAgICAgICAgIFtub0RhdGFMYWJlbF09XCJub0RhdGFMYWJlbFwiXG4gICAgICAgICAgICBbdXNlcklucHV0XT1cInRleHRcIlxuICAgICAgICAgICAgW3N1Z2dlc3RlZFRleHRdPVwic3VnZ2VzdGlvblwiXG4gICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgW3JlYWRvbmx5XT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgIFt0YWJJbmRleF09XCJ0YWJJbmRleFwiXG4gICAgICAgICAgICBbcG9wdXBPcGVuXT1cImlzT3BlblwiXG4gICAgICAgICAgICBbcGxhY2Vob2xkZXJdPVwicGxhY2Vob2xkZXJcIlxuICAgICAgICAgICAgKG9uTmF2aWdhdGUpPVwiaGFuZGxlTmF2aWdhdGUoJGV2ZW50KVwiXG4gICAgICAgICAgICAodmFsdWVDaGFuZ2UpPVwic2VhcmNoQmFyQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgKG9uQmx1cik9XCJoYW5kbGVCbHVyKClcIlxuICAgICAgICAgICAgKG9uRm9jdXMpPVwiaGFuZGxlRm9jdXMoKVwiXG4gICAgICAgID48L2tlbmRvLXNlYXJjaGJhcj5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCIhbG9hZGluZyAmJiAhcmVhZG9ubHkgJiYgKGNsZWFyQnV0dG9uICYmIHRleHQ/Lmxlbmd0aClcIiBjbGFzcz1cImstaWNvbiBrLWNsZWFyLXZhbHVlIGstaS1jbG9zZVwiIFthdHRyLnRpdGxlXT1cImNsZWFyVGl0bGVcIiByb2xlPVwiYnV0dG9uXCIgdGFiaW5kZXg9XCItMVwiIChjbGljayk9XCJjbGVhclZhbHVlKCRldmVudClcIiAobW91c2Vkb3duKT1cIiRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCI+XG48L3NwYW4+XG4gICAgICAgIDxzcGFuICpuZ0lmPVwibG9hZGluZ1wiIGNsYXNzPVwiay1pY29uIGstaS1sb2FkaW5nXCI+PC9zcGFuPlxuICAgICAgICA8bmctdGVtcGxhdGUgI3BvcHVwVGVtcGxhdGU+XG4gICAgICAgICAgICA8IS0taGVhZGVyIHRlbXBsYXRlLS0+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCJoZWFkZXJUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgW3RlbXBsYXRlQ29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlUmVmOiBoZWFkZXJUZW1wbGF0ZS50ZW1wbGF0ZVJlZlxuICAgICAgICAgICAgICAgIH1cIj5cbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICA8IS0tbGlzdC0tPlxuICAgICAgICAgICAgPGtlbmRvLWxpc3RcbiAgICAgICAgICAgICAgICAjb3B0aW9uc0xpc3RcbiAgICAgICAgICAgICAgICBbaWRdPVwibGlzdEJveElkXCJcbiAgICAgICAgICAgICAgICBbb3B0aW9uUHJlZml4XT1cIm9wdGlvblByZWZpeFwiXG4gICAgICAgICAgICAgICAgW2RhdGFdPVwiZGF0YVwiXG4gICAgICAgICAgICAgICAgW3RleHRGaWVsZF09XCJ2YWx1ZUZpZWxkXCJcbiAgICAgICAgICAgICAgICBbdmFsdWVGaWVsZF09XCJ2YWx1ZUZpZWxkXCJcbiAgICAgICAgICAgICAgICBbdGVtcGxhdGVdPVwidGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIFtncm91cFRlbXBsYXRlXT1cImdyb3VwVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIFtmaXhlZEdyb3VwVGVtcGxhdGVdPVwiZml4ZWRHcm91cFRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICBbaGVpZ2h0XT1cImxpc3RIZWlnaHRcIlxuICAgICAgICAgICAgICAgIFtzaG93XT1cImlzT3BlblwiXG4gICAgICAgICAgICAgICAgW3ZpcnR1YWxdPVwidmlydHVhbFwiXG4gICAgICAgICAgICAgICAgKHBhZ2VDaGFuZ2UpPVwicGFnZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDwva2VuZG8tbGlzdD5cbiAgICAgICAgICAgIDwhLS1uby1kYXRhIHRlbXBsYXRlLS0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiay1ub2RhdGFcIiAqbmdJZj1cImRhdGEubGVuZ3RoID09PSAwXCI+XG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIm5vRGF0YVRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgW3RlbXBsYXRlQ29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVJlZjogbm9EYXRhVGVtcGxhdGU/LnRlbXBsYXRlUmVmXG4gICAgICAgICAgICAgICAgICAgIH1cIj5cbiAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhbm9EYXRhVGVtcGxhdGVcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdj57eyBub0RhdGFUZXh0IH19PC9kaXY+XG4gICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPCEtLWZvb3RlciB0ZW1wbGF0ZS0tPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiZm9vdGVyVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIFt0ZW1wbGF0ZUNvbnRleHRdPVwie1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVJlZjogZm9vdGVyVGVtcGxhdGUudGVtcGxhdGVSZWZcbiAgICAgICAgICAgICAgICB9XCI+XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiaXNPcGVuXCI+XG4gICAgICAgICAgICA8a2VuZG8tcmVzaXplLXNlbnNvciAocmVzaXplKT1cIm9uUmVzaXplKClcIj48L2tlbmRvLXJlc2l6ZS1zZW5zb3I+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDxuZy1jb250YWluZXIgI2NvbnRhaW5lcj48L25nLWNvbnRhaW5lcj5cbiAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5BdXRvQ29tcGxldGVDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBEYXRhU2VydmljZSB9LFxuICAgIHsgdHlwZTogUG9wdXBTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBTZWxlY3Rpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOYXZpZ2F0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogRGlzYWJsZWRJdGVtc1NlcnZpY2UgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9XG5dO1xuQXV0b0NvbXBsZXRlQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGhpZ2hsaWdodEZpcnN0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmb2N1c2FibGVJZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGF0YTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdmFsdWU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZhbHVlRmllbGQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBsYWNlaG9sZGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBwb3B1cFNldHRpbmdzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBsaXN0SGVpZ2h0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBsb2FkaW5nOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjbGVhckJ1dHRvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc3VnZ2VzdDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGlzYWJsZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGl0ZW1EaXNhYmxlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcmVhZG9ubHk6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRhYmluZGV4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0YWJJbmRleDogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFtcInRhYkluZGV4XCIsXSB9XSxcbiAgICBmaWx0ZXJhYmxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB2aXJ0dWFsOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB2YWx1ZUNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGZpbHRlckNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIG9wZW46IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBjbG9zZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIG9uRm9jdXM6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydmb2N1cycsXSB9XSxcbiAgICBvbkJsdXI6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydibHVyJyxdIH1dLFxuICAgIHRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtJdGVtVGVtcGxhdGVEaXJlY3RpdmUsXSB9XSxcbiAgICBoZWFkZXJUZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUsXSB9XSxcbiAgICBmb290ZXJUZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUsXSB9XSxcbiAgICBub0RhdGFUZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbTm9EYXRhVGVtcGxhdGVEaXJlY3RpdmUsXSB9XSxcbiAgICBncm91cFRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtHcm91cFRlbXBsYXRlRGlyZWN0aXZlLF0gfV0sXG4gICAgZml4ZWRHcm91cFRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtGaXhlZEdyb3VwVGVtcGxhdGVEaXJlY3RpdmUsXSB9XSxcbiAgICBjb250YWluZXI6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWydjb250YWluZXInLCB7IHJlYWQ6IFZpZXdDb250YWluZXJSZWYgfSxdIH1dLFxuICAgIHBvcHVwVGVtcGxhdGU6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWydwb3B1cFRlbXBsYXRlJyxdIH1dLFxuICAgIHNlYXJjaGJhcjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbU2VhcmNoQmFyQ29tcG9uZW50LF0gfV0sXG4gICAgb3B0aW9uc0xpc3Q6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWydvcHRpb25zTGlzdCcsXSB9XSxcbiAgICB3aWRnZXRDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXdpZGdldCcsXSB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstYXV0b2NvbXBsZXRlJyxdIH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1oZWFkZXInLF0gfV0sXG4gICAgaXNGb2N1c2VkOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXN0YXRlLWZvY3VzZWQnLF0gfV0sXG4gICAgaXNEaXNhYmxlZDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1zdGF0ZS1kaXNhYmxlZCcsXSB9XSxcbiAgICBkaXI6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuZGlyJyxdIH1dXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgVE9VQ0hfRU5BQkxFRCA9IG5ldyBJbmplY3Rpb25Ub2tlbignZHJvcGRvd25zLXRvdWNoLWVuYWJsZWQnKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyogdHNsaW50OmRpc2FibGU6dmFyaWFibGUtbmFtZSAqL1xuY29uc3QgTXVsdGlzZWxlY3RNZXNzYWdlcyA9IHtcbiAgICAnYXJyYXknOiAnRXhwZWN0ZWQgdmFsdWVzIG9mIGFycmF5IHR5cGUuIFNlZSBodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9kcm9wZG93bnMvbXVsdGlzZWxlY3QvI3ZhbHVlLXNlbGVjdGlvbicsXG4gICAgJ29iamVjdCc6ICdFeHBlY3RlZCB2YWx1ZXMgb2YgT2JqZWN0IHR5cGUuIFNlZSBodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9kcm9wZG93bnMvbXVsdGlzZWxlY3QvI3ZhbHVlLXNlbGVjdGlvbicsXG4gICAgJ3ByaW1pdGl2ZSc6ICdFeHBlY3RlZCB2YWx1ZXMgb2YgcHJpbWl0aXZlIHR5cGUuIFNlZSBodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9kcm9wZG93bnMvbXVsdGlzZWxlY3QvI3ZhbHVlLXNlbGVjdGlvbicsXG4gICAgJ3RleHRBbmRWYWx1ZSc6ICdFeHBlY3RlZCB0ZXh0RmllbGQgYW5kIHZhbHVlRmllbGQgb3B0aW9ucyB0byBiZSBzZXQuIFNlZSBodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9kcm9wZG93bnMvbXVsdGlzZWxlY3QvI3RvYy1iaW5kLXRvLWFycmF5cy1vZi1jb21wbGV4LWRhdGEnXG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyogdHNsaW50OmRpc2FibGU6dmFyaWFibGUtbmFtZSAqL1xuY29uc3QgQ29tYm9Cb3hNZXNzYWdlcyA9IHtcbiAgICAnb2JqZWN0JzogJ0V4cGVjdGVkIHZhbHVlIG9mIHR5cGUgT2JqZWN0LiBTZWUgaHR0cDovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL2NvbXBvbmVudHMvZHJvcGRvd25zL2NvbWJvYm94LyN0b2MtdmFsdWUtc2VsZWN0aW9uJyxcbiAgICAncHJpbWl0aXZlJzogJ0V4cGVjdGVkIHZhbHVlIG9mIHByaW1pdGl2ZSB0eXBlLiBTZWUgaHR0cDovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL2NvbXBvbmVudHMvZHJvcGRvd25zL2NvbWJvYm94LyN0b2MtdmFsdWUtc2VsZWN0aW9uJyxcbiAgICAndGV4dEFuZFZhbHVlJzogJ0V4cGVjdGVkIHRleHRGaWVsZCBhbmQgdmFsdWVGaWVsZCBvcHRpb25zIHRvIGJlIHNldC4gU2VlIGh0dHA6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL2Ryb3Bkb3ducy9jb21ib2JveC8jdG9jLWJpbmQtdG8tYXJyYXlzLW9mLWNvbXBsZXgtZGF0YScsXG4gICAgJ25vSXRlbUhlaWdodCc6ICdFeHBlY3RlZCB2aXJ0dWFsLml0ZW1IZWlnaHQgb2YgdHlwZSBudW1iZXIuJ1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qIHRzbGludDpkaXNhYmxlOnZhcmlhYmxlLW5hbWUgKi9cbmNvbnN0IERyb3BEb3duTGlzdE1lc3NhZ2VzID0ge1xuICAgICdkZWZhdWx0SXRlbSc6ICdkZWZhdWx0SXRlbSBhbmQgZGF0YSBpdGVtcyBtdXN0IGJlIG9mIHNhbWUgdHlwZS4gU2VlIGh0dHA6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL2Ryb3Bkb3ducy9hcGkvRHJvcERvd25MaXN0Q29tcG9uZW50LyN0b2MtZGVmYXVsdGl0ZW0nLFxuICAgICdvYmplY3QnOiAnRXhwZWN0ZWQgdmFsdWUgb2YgdHlwZSBPYmplY3QuIFNlZSBodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9kcm9wZG93bnMvZHJvcGRvd25saXN0LyN0b2MtdmFsdWUtc2VsZWN0aW9uJyxcbiAgICAncHJpbWl0aXZlJzogJ0V4cGVjdGVkIHZhbHVlIG9mIHByaW1pdGl2ZSB0eXBlLiBTZWUgaHR0cDovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL2NvbXBvbmVudHMvZHJvcGRvd25zL2Ryb3Bkb3dubGlzdC8jdG9jLXZhbHVlLXNlbGVjdGlvbicsXG4gICAgJ3RleHRBbmRWYWx1ZSc6ICdFeHBlY3RlZCB0ZXh0RmllbGQgYW5kIHZhbHVlRmllbGQgb3B0aW9ucyB0byBiZSBzZXQuIFNlZSBodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9kcm9wZG93bnMvZHJvcGRvd25saXN0LyN0b2MtYmluZC10by1hcnJheXMtb2YtY29tcGxleC1kYXRhJ1xufTtcblxuLyogdHNsaW50OmRpc2FibGU6bm8tbnVsbC1rZXl3b3JkICovXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgQ09NQk9CT1hfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgbXVsdGk6IHRydWUsXG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXVzZS1iZWZvcmUtZGVjbGFyZVxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENvbWJvQm94Q29tcG9uZW50KVxufTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIENvbWJvQm94IGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19jb21ib2JveCAlfSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBfQENvbXBvbmVudCh7XG4gKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiB0ZW1wbGF0ZTogYFxuICogIDxrZW5kby1jb21ib2JveCBbZGF0YV09XCJsaXN0SXRlbXNcIj5cbiAqICA8L2tlbmRvLWNvbWJvYm94PlxuICogYFxuICogfSlcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgIHB1YmxpYyBsaXN0SXRlbXM6IEFycmF5PHN0cmluZz4gPSBbXCJJdGVtIDFcIiwgXCJJdGVtIDJcIiwgXCJJdGVtIDNcIiwgXCJJdGVtIDRcIl07XG4gKiB9XG4gKiBgYGBcbiAqL1xuY2xhc3MgQ29tYm9Cb3hDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbiwgcG9wdXBTZXJ2aWNlLCBzZWxlY3Rpb25TZXJ2aWNlLCBuYXZpZ2F0aW9uU2VydmljZSwgZGlzYWJsZWRJdGVtc1NlcnZpY2UsIGRhdGFTZXJ2aWNlLCBfem9uZSwgY2RyLCByZW5kZXJlciwgd3JhcHBlciwgdG91Y2hFbmFibGVkKSB7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLnBvcHVwU2VydmljZSA9IHBvcHVwU2VydmljZTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlID0gc2VsZWN0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZSA9IG5hdmlnYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmRpc2FibGVkSXRlbXNTZXJ2aWNlID0gZGlzYWJsZWRJdGVtc1NlcnZpY2U7XG4gICAgICAgIHRoaXMuZGF0YVNlcnZpY2UgPSBkYXRhU2VydmljZTtcbiAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xuICAgICAgICB0aGlzLmNkciA9IGNkcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLnRvdWNoRW5hYmxlZCA9IHRvdWNoRW5hYmxlZDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb2N1c2FibGVJZCA9IGBrLSR7Z3VpZCgpfWA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB0aGUgQ29tYm9Cb3ggYWxsb3dzIHVzZXItZGVmaW5lZCB2YWx1ZXMgdGhhdCBhcmUgbm90IHByZXNlbnQgaW4gdGhlIGRhdGFzZXRcbiAgICAgICAgICogKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlc10oeyUgc2x1ZyBjdXN0b21fdmFsdWVzX2NvbWJvYm94ICV9KSkuXG4gICAgICAgICAqIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFsbG93Q3VzdG9tID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHVzZXItZGVmaW5lZCBjYWxsYmFjayB3aGljaCByZXR1cm5zIG5vcm1hbGl6ZWQgY3VzdG9tIHZhbHVlcy5cbiAgICAgICAgICogVHlwaWNhbGx5IHVzZWQgd2hlbiB0aGUgZGF0YSBpdGVtcyBhcmUgZGlmZmVyZW50IGZyb20gdHlwZSBgc3RyaW5nYC5cbiAgICAgICAgICogQHBhcmFtIHsgQW55IH0gdmFsdWUgLSBUaGUgY3VzdG9tIHZhbHVlIGRlZmluZWQgYnkgdGhlIHVzZXIuXG4gICAgICAgICAqIEByZXR1cm5zIHsgQW55IH1cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuICAgICAgICAgKlxuICAgICAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgICAgICogdGVtcGxhdGU6IGBcbiAgICAgICAgICogICA8a2VuZG8tY29tYm9ib3hcbiAgICAgICAgICogICAgICAgW2FsbG93Q3VzdG9tXT1cInRydWVcIlxuICAgICAgICAgKiAgICAgICBbZGF0YV09XCJsaXN0SXRlbXNcIlxuICAgICAgICAgKiAgICAgICBbdGV4dEZpZWxkXT1cIid0ZXh0J1wiXG4gICAgICAgICAqICAgICAgIFt2YWx1ZUZpZWxkXT1cIid2YWx1ZSdcIlxuICAgICAgICAgKiAgICAgICBbdmFsdWVOb3JtYWxpemVyXT1cInZhbHVlTm9ybWFsaXplclwiXG4gICAgICAgICAqICAgICAgICh2YWx1ZUNoYW5nZSk9XCJvblZhbHVlQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgKiAgID5cbiAgICAgICAgICogICA8L2tlbmRvLWNvbWJvYm94PlxuICAgICAgICAgKiBgXG4gICAgICAgICAqIH0pXG4gICAgICAgICAqXG4gICAgICAgICAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICAgICAqICAgcHVibGljIGxpc3RJdGVtczogQXJyYXk8eyB0ZXh0OiBzdHJpbmcsIHZhbHVlOiBudW1iZXIgfT4gPSBbXG4gICAgICAgICAqICAgICAgIHsgdGV4dDogXCJTbWFsbFwiLCB2YWx1ZTogMSB9LFxuICAgICAgICAgKiAgICAgICB7IHRleHQ6IFwiTWVkaXVtXCIsIHZhbHVlOiAyIH0sXG4gICAgICAgICAqICAgICAgIHsgdGV4dDogXCJMYXJnZVwiLCB2YWx1ZTogMyB9XG4gICAgICAgICAqICAgXTtcbiAgICAgICAgICpcbiAgICAgICAgICogICBwdWJsaWMgb25WYWx1ZUNoYW5nZSh2YWx1ZSkge1xuICAgICAgICAgKiAgICAgICBjb25zb2xlLmxvZyhcInZhbHVlQ2hhbmdlIDogXCIsIHZhbHVlKTtcbiAgICAgICAgICogICB9XG4gICAgICAgICAqXG4gICAgICAgICAqICAgcHVibGljIHZhbHVlTm9ybWFsaXplciA9ICh0ZXh0JDogT2JzZXJ2YWJsZTxzdHJpbmc+KSA9PiB0ZXh0JC5waXBlKG1hcCgodGV4dDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAqICAgICAgcmV0dXJuIHsgUHJvZHVjdElEOiBudWxsLCBQcm9kdWN0TmFtZTogdGV4dCB9O1xuICAgICAgICAgKiAgIH0pKTtcbiAgICAgICAgICpcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVOb3JtYWxpemVyID0gKHRleHQpID0+IHRleHQucGlwZShtYXAoKHVzZXJJbnB1dCkgPT4gdXNlcklucHV0KSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGludCB0aGF0IGlzIGRpc3BsYXllZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgZW1wdHkuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gXCJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiB0aGUgc3VnZ2VzdGlvbnMgbGlzdC4gQnkgZGVmYXVsdCwgYGxpc3RIZWlnaHRgIGlzIDIwMHB4LlxuICAgICAgICAgKlxuICAgICAgICAgKiA+IFRoZSBgbGlzdEhlaWdodGAgcHJvcGVydHkgYWZmZWN0cyBvbmx5IHRoZSBsaXN0IG9mIHN1Z2dlc3Rpb25zIGFuZCBub3QgdGhlIHdob2xlIHBvcHVwIGNvbnRhaW5lci5cbiAgICAgICAgICogPiBUbyBzZXQgdGhlIGhlaWdodCBvZiB0aGUgcG9wdXAgY29udGFpbmVyLCB1c2UgYHBvcHVwU2V0dGluZ3MuaGVpZ2h0YC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdEhlaWdodCA9IDIwMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZXMgdGhlIGF1dG8tY29tcGxldGlvbiBvZiB0aGUgdGV4dCBiYXNlZCBvbiB0aGUgZmlyc3QgZGF0YSBpdGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdWdnZXN0ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gYHRydWVgLCByZW5kZXJzIGEgYnV0dG9uIG9uIGhvdmVyaW5nIG92ZXIgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICogQ2xpY2tpbmcgdGhpcyBidXR0b24gcmVzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgY29tcG9uZW50IHRvIGB1bmRlZmluZWRgIGFuZCB0cmlnZ2VycyB0aGUgYGNoYW5nZWAgZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsZWFyQnV0dG9uID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGRpc2FibGVkIHN0YXRlIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSByZWFkLW9ubHkgc3RhdGUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhZG9ubHkgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgW2B0YWJpbmRleGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXgpIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZXMgdGhlIFtmaWx0ZXJpbmddKHslIHNsdWcgZmlsdGVyaW5nX2NvbWJvYm94ICV9KSBmdW5jdGlvbmFsaXR5LlxuICAgICAgICAgKiBJZiBzZXQgdG8gYHRydWVgLCB0aGUgY29tcG9uZW50IGVtaXRzIHRoZSBgZmlsdGVyQ2hhbmdlYCBldmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsdGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB2YWx1ZSBpcyBjaGFuZ2VkJm1kYXNoO1xuICAgICAgICAgKiB3aGVuIHRoZSBjb21wb25lbnQgaXMgYmx1cnJlZCBvciB0aGUgdmFsdWUgaXMgY2xlYXJlZCB0aHJvdWdoIHRoZSAqKkNsZWFyKiogYnV0dG9uXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfY29tYm9ib3ggJX0jdG9jLWV2ZW50cykpLlxuICAgICAgICAgKiBXaGVuIHRoZSB2YWx1ZSBvZiB0aGUgY29tcG9uZW50IGlzIHByb2dyYW1tYXRpY2FsbHkgY2hhbmdlZCB0byBgbmdNb2RlbGAgb3IgYGZvcm1Db250cm9sYFxuICAgICAgICAgKiB0aHJvdWdoIGl0cyBBUEkgb3IgZm9ybSBiaW5kaW5nLCB0aGUgYHZhbHVlQ2hhbmdlYCBldmVudCBpcyBub3QgdHJpZ2dlcmVkIGJlY2F1c2UgaXRcbiAgICAgICAgICogbWlnaHQgY2F1c2UgYSBtaXgtdXAgd2l0aCB0aGUgYnVpbHQtaW4gYHZhbHVlQ2hhbmdlYCBtZWNoYW5pc21zIG9mIHRoZSBgbmdNb2RlbGAgb3IgYGZvcm1Db250cm9sYCBiaW5kaW5ncy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgYW4gaXRlbSBzZWxlY3Rpb24gaXMgY2hhbmdlZFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X2NvbWJvYm94ICV9I3RvYy1ldmVudHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIHR5cGVzIGluIHRoZSBpbnB1dCBmaWVsZC5cbiAgICAgICAgICogWW91IGNhbiBmaWx0ZXIgdGhlIHNvdXJjZSBiYXNlZCBvbiB0aGUgcGFzc2VkIGZpbHRyYXRpb24gdmFsdWVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19jb21ib2JveCAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbHRlckNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgcG9wdXAgaXMgYWJvdXQgdG8gb3Blbi5cbiAgICAgICAgICogVGhpcyBldmVudCBpcyBwcmV2ZW50YWJsZS4gSWYgeW91IGNhbmNlbCBpdCwgdGhlIHBvcHVwIHdpbGwgcmVtYWluIGNsb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3BlbiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgcG9wdXAgaXMgYWJvdXQgdG8gY2xvc2UuXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgcHJldmVudGFibGUuIElmIHlvdSBjYW5jZWwgaXQsIHRoZSBwb3B1cCB3aWxsIHJlbWFpbiBvcGVuLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdXNlciBmb2N1c2VzIHRoZSBDb21ib0JveC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25Gb2N1cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTsgLy90c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLW91dHB1dC1yZW5hbWVcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgQ29tYm9Cb3ggZ2V0cyBibHVycmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkJsdXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7IC8vdHNsaW50OmRpc2FibGUtbGluZTpuby1vdXRwdXQtcmVuYW1lXG4gICAgICAgIHRoaXMud2lkZ2V0Q2xhc3NlcyA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGlzdEJveElkID0gZ3VpZCgpO1xuICAgICAgICB0aGlzLm9wdGlvblByZWZpeCA9IGd1aWQoKTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gKF8pID0+IHsgfTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjayA9IChfKSA9PiB7IH07XG4gICAgICAgIHRoaXMuX2ZpbHRlcmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl90ZXh0ID0gJyc7XG4gICAgICAgIHRoaXMuZmlsdGVyVGV4dCA9ICcnO1xuICAgICAgICB0aGlzLl9vcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BvcHVwU2V0dGluZ3MgPSB7IGFuaW1hdGU6IHRydWUgfTtcbiAgICAgICAgdGhpcy5wb3B1cE1vdXNlRG93bkhhbmRsZXIgPSAoZXZlbnQpID0+IGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuY3VzdG9tVmFsdWVTdWJqZWN0ID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy52YWx1ZVN1YmplY3QgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLmNsZWFyVmFsdWVTdWJqZWN0ID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdWJqZWN0ID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5zdWJzID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IGxvY2FsaXphdGlvbi5ydGwgPyAncnRsJyA6ICdsdHInO1xuICAgICAgICB0aGlzLndyYXBwZXIgPSB3cmFwcGVyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIH1cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIGxldCB3cmFwcGVyT2Zmc2V0V2lkdGggPSAwO1xuICAgICAgICBpZiAoaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICB3cmFwcGVyT2Zmc2V0V2lkdGggPSB0aGlzLndyYXBwZXIub2Zmc2V0V2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLnBvcHVwU2V0dGluZ3Mud2lkdGggfHwgd3JhcHBlck9mZnNldFdpZHRoO1xuICAgICAgICBjb25zdCBtaW5XaWR0aCA9IGlzTmFOKHdyYXBwZXJPZmZzZXRXaWR0aCkgPyB3cmFwcGVyT2Zmc2V0V2lkdGggOiBgJHt3cmFwcGVyT2Zmc2V0V2lkdGh9cHhgO1xuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IGlzTmFOKHdpZHRoKSA/IHdpZHRoIDogYCR7d2lkdGh9cHhgO1xuICAgICAgICByZXR1cm4geyBtaW46IG1pbldpZHRoLCBtYXg6IG1heFdpZHRoIH07XG4gICAgfVxuICAgIGdldCBoZWlnaHQoKSB7XG4gICAgICAgIGNvbnN0IHBvcHVwSGVpZ2h0ID0gdGhpcy5wb3B1cFNldHRpbmdzLmhlaWdodDtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudChwb3B1cEhlaWdodCkgPyBgJHtwb3B1cEhlaWdodH1weGAgOiAnYXV0byc7XG4gICAgfVxuICAgIHNldCB0ZXh0KHRleHQpIHtcbiAgICAgICAgdGhpcy5fdGV4dCA9IGlzUHJlc2VudCh0ZXh0KSA/IHRleHQudG9TdHJpbmcoKSA6IFwiXCI7XG4gICAgfVxuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHRvZ2dsZVBvcHVwKG9wZW4pIHtcbiAgICAgICAgY29uc3QgaXNEaXNhYmxlZCA9IHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5yZWFkb25seTtcbiAgICAgICAgY29uc3Qgc2FtZVN0YXRlID0gdGhpcy5pc09wZW4gPT09IG9wZW47XG4gICAgICAgIGlmIChpc0Rpc2FibGVkIHx8IHNhbWVTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzRGVmYXVsdFByZXZlbnRlZCA9IHRoaXMudHJpZ2dlclBvcHVwRXZlbnRzKG9wZW4pO1xuICAgICAgICBpZiAoIWlzRGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlKG9wZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBhY3RpdmVEZXNjZW5kYW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuIHx8ICFpc1ByZXNlbnQodGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmZvY3VzZWQpIHx8IHRoaXMuc2VsZWN0aW9uU2VydmljZS5mb2N1c2VkID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YUl0ZW0gPSB0aGlzLmRhdGFTZXJ2aWNlLml0ZW1BdCh0aGlzLnNlbGVjdGlvblNlcnZpY2UuZm9jdXNlZCk7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvblByZWZpeCArIFwiLVwiICsgKGRhdGFJdGVtID8gZ2V0dGVyKGRhdGFJdGVtLCB0aGlzLnZhbHVlRmllbGQpIDogXCJcIik7XG4gICAgfVxuICAgIGdldCBub0RhdGFMYWJlbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vRGF0YVRleHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNsZWFyVGl0bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvbi5nZXQoJ2NsZWFyVGl0bGUnKTtcbiAgICB9XG4gICAgZ2V0IGFwcGVuZFRvKCkge1xuICAgICAgICBjb25zdCB7IGFwcGVuZFRvIH0gPSB0aGlzLnBvcHVwU2V0dGluZ3M7XG4gICAgICAgIGlmICghYXBwZW5kVG8gfHwgYXBwZW5kVG8gPT09ICdyb290Jykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwZW5kVG8gPT09ICdjb21wb25lbnQnID8gdGhpcy5jb250YWluZXIgOiBhcHBlbmRUbztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGF0YSBvZiB0aGUgQ29tYm9Cb3guXG4gICAgICpcbiAgICAgKiA+IFRoZSBkYXRhIGhhcyB0byBiZSBwcm92aWRlZCBpbiBhbiBhcnJheS1saWtlIGxpc3QuXG4gICAgICovXG4gICAgc2V0IGRhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGFTZXJ2aWNlLmRhdGEgPSBkYXRhIHx8IFtdO1xuICAgICAgICBpZiAodGhpcy52aXJ0dWFsKSB7XG4gICAgICAgICAgICB0aGlzLnZpcnR1YWwuc2tpcCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSgpO1xuICAgICAgICBpZiAodGhpcy5fZmlsdGVyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeUFuZERhdGFQcmVzZW50ID0gdGhpcy50ZXh0Lmxlbmd0aCA+IDAgJiYgdGhpcy5kYXRhU2VydmljZS5pdGVtc0NvdW50ID4gMDtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcXVlcnlBbmREYXRhUHJlc2VudCA/IHRoaXMuZmlyc3RGb2N1c2FibGVJbmRleCgwKSA6IC0xO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmZvY3VzZWQgPSBpbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdWdnZXN0ICYmIHRoaXMuZGF0YVNlcnZpY2UuaXRlbXNDb3VudCAmJiB0aGlzLnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuc3VnZ2VzdGVkVGV4dCA9IGdldHRlcih0aGlzLmRhdGFTZXJ2aWNlLml0ZW1BdCgwKSwgdGhpcy50ZXh0RmllbGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkYXRhKCkge1xuICAgICAgICBjb25zdCB2aXJ0dWFsID0gdGhpcy52aXJ0dWFsO1xuICAgICAgICBpZiAodmlydHVhbCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB2aXJ0dWFsLnNraXAgfHwgMDtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgdmlydHVhbC5wYWdlU2l6ZTtcbiAgICAgICAgICAgIC8vIFVzZSBsZW5ndGggaW5zdGVhZCBvZiBpdGVtc0NvdW50IGJlY2F1c2Ugb2YgdGhlIGdyb3VwaW5nLlxuICAgICAgICAgICAgdmlydHVhbC50b3RhbCA9IHRoaXMuZGF0YVNlcnZpY2UuZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU2VydmljZS5kYXRhLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTZXJ2aWNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBDb21ib0JveC5cbiAgICAgKiBJdCBjYW4gZWl0aGVyIGJlIG9mIHRoZSBwcmltaXRpdmUgKHN0cmluZywgbnVtYmVycykgb3Igb2YgdGhlIGNvbXBsZXggKG9iamVjdHMpIHR5cGUuXG4gICAgICogVG8gZGVmaW5lIHRoZSB0eXBlLCB1c2UgdGhlIGB2YWx1ZVByaW1pdGl2ZWAgb3B0aW9uLlxuICAgICAqXG4gICAgICogPiBBbGwgc2VsZWN0ZWQgdmFsdWVzIHdoaWNoIGFyZSBub3QgcHJlc2VudCBpbiB0aGUgZGF0YXNldCBhcmUgY29uc2lkZXJlZCBjdXN0b20gdmFsdWVzLlxuICAgICAqID4gV2hlbiB0aGUgYEVudGVyYCBrZXkgaXMgcHJlc3NlZCBvciB0aGUgY29tcG9uZW50IGxvc2VzIGZvY3VzLCBjdXN0b20gdmFsdWVzIGdldCBkaXNtaXNzZWQgdW5sZXNzIGBhbGxvd0N1c3RvbWAgaXMgc2V0IHRvIGB0cnVlYC5cbiAgICAgKi9cbiAgICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlTZXR0aW5ncyhuZXdWYWx1ZSk7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyB0aGUgcG9wdXAgb2YgdGhlIENvbWJvQm94LlxuICAgICAqXG4gICAgICogVGhlIGF2YWlsYWJsZSBvcHRpb25zIGFyZTpcbiAgICAgKiAtIGBhbmltYXRlOiBCb29sZWFuYCZtZGFzaDtDb250cm9scyB0aGUgcG9wdXAgYW5pbWF0aW9uLiBCeSBkZWZhdWx0LCB0aGUgb3BlbiBhbmQgY2xvc2UgYW5pbWF0aW9ucyBhcmUgZW5hYmxlZC5cbiAgICAgKiAtIGB3aWR0aDogTnVtYmVyIHwgU3RyaW5nYCZtZGFzaDtTZXRzIHRoZSB3aWR0aCBvZiB0aGUgcG9wdXAgY29udGFpbmVyLiBCeSBkZWZhdWx0LCB0aGUgd2lkdGggb2YgdGhlIGhvc3QgZWxlbWVudCBpcyB1c2VkLiBJZiBzZXQgdG8gYGF1dG9gLCB0aGUgY29tcG9uZW50IGF1dG9tYXRpY2FsbHkgYWRqdXN0cyB0aGUgd2lkdGggb2YgdGhlIHBvcHVwIGFuZCBubyBpdGVtIGxhYmVscyBhcmUgd3JhcHBlZC4gVGhlIGBhdXRvYCBtb2RlIGlzIG5vdCBzdXBwb3J0ZWQgd2hlbiB2aXJ0dWFsIHNjcm9sbGluZyBpcyBlbmFibGVkLlxuICAgICAqIC0gYGhlaWdodDogTnVtYmVyYCZtZGFzaDtTZXRzIHRoZSBoZWlnaHQgb2YgdGhlIHBvcHVwIGNvbnRhaW5lci5cbiAgICAgKiAtIGBwb3B1cENsYXNzOiBTdHJpbmdgJm1kYXNoO1NwZWNpZmllcyBhIGxpc3Qgb2YgQ1NTIGNsYXNzZXMgdGhhdCBhcmUgdXNlZCB0byBzdHlsZSB0aGUgcG9wdXAuXG4gICAgICogLSBgYXBwZW5kVG86IFwicm9vdFwiIHwgXCJjb21wb25lbnRcIiB8IFZpZXdDb250YWluZXJSZWZgJm1kYXNoO1NwZWNpZmllcyB0aGUgY29tcG9uZW50IHRvIHdoaWNoIHRoZSBwb3B1cCB3aWxsIGJlIGFwcGVuZGVkLlxuICAgICAqL1xuICAgIHNldCBwb3B1cFNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuX3BvcHVwU2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHsgYW5pbWF0ZTogdHJ1ZSB9LCBzZXR0aW5ncyk7XG4gICAgfVxuICAgIGdldCBwb3B1cFNldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9wdXBTZXR0aW5ncztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBhIEJvb2xlYW4gZnVuY3Rpb24gdGhhdCBpcyBleGVjdXRlZCBmb3IgZWFjaCBkYXRhIGl0ZW0gaW4gdGhlIGNvbXBvbmVudFxuICAgICAqIChbc2VlIGV4YW1wbGVzXSh7JSBzbHVnIGRpc2FibGVkaXRlbXNfY29tYm9ib3ggJX0pKS4gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBpdGVtIHdpbGwgYmUgZGlzYWJsZWQuXG4gICAgICovXG4gICAgc2V0IGl0ZW1EaXNhYmxlZChmbikge1xuICAgICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGl0ZW1EaXNhYmxlZCBtdXN0IGJlIGEgZnVuY3Rpb24sIGJ1dCByZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KGZuKX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNhYmxlZEl0ZW1zU2VydmljZS5pdGVtRGlzYWJsZWQgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCB0YWJJbmRleCh0YWJJbmRleCkge1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gdGFiSW5kZXg7XG4gICAgfVxuICAgIGdldCB0YWJJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFiaW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhlIFt2aXJ0dWFsaXphdGlvbl0oeyUgc2x1ZyB2aXJ0dWFsaXphdGlvbl9jb21ib2JveCAlfSkgZnVuY3Rpb25hbGl0eS5cbiAgICAgKi9cbiAgICBzZXQgdmlydHVhbChzZXR0aW5ncykge1xuICAgICAgICB0aGlzLl92aXJ0dWFsU2V0dGluZ3MgPSBub3JtYWxpemVWaXJ0dWFsaXphdGlvblNldHRpbmdzKHNldHRpbmdzKTtcbiAgICB9XG4gICAgZ2V0IHZpcnR1YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXJ0dWFsU2V0dGluZ3M7XG4gICAgfVxuICAgIGdldCBjbGVhcmFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsZWFyQnV0dG9uO1xuICAgIH1cbiAgICBnZXQgZGlyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb247XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLndyYXBwZXIsIFwidGFiaW5kZXhcIik7XG4gICAgICAgIHRoaXMuYXR0YWNoU3RyZWFtcygpO1xuICAgICAgICB0aGlzLmNyZWF0ZVNlbGVjdGlvblN0cmVhbSgpO1xuICAgICAgICB0aGlzLmNyZWF0ZVZhbHVlU3RyZWFtKCk7XG4gICAgICAgIHRoaXMuc2V0TWVzc2FnZXMoKTtcbiAgICB9XG4gICAgY3JlYXRlVmFsdWVTdHJlYW0oKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlU3RyZWFtID0gdGhpcy52YWx1ZVN1YmplY3QucGlwZShmaWx0ZXIoKGNhbmRpZGF0ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVGcm9tID0gdGhpcy5wcm9wKHRoaXMudmFsdWVGaWVsZCwgdGhpcy52YWx1ZVByaW1pdGl2ZSk7XG4gICAgICAgICAgICBjb25zdCB0ZXh0RnJvbSA9IHRoaXMucHJvcCh0aGlzLnRleHRGaWVsZCwgdGhpcy52YWx1ZVByaW1pdGl2ZSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gdmFsdWVGcm9tKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZUZyb20oY2FuZGlkYXRlKTtcbiAgICAgICAgICAgIGxldCBuZXdUZXh0ID0gdGV4dEZyb20oY2FuZGlkYXRlKTtcbiAgICAgICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMudmFsdWUpICYmICFpc1ByZXNlbnQobmV3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChuZXdUZXh0KSkge1xuICAgICAgICAgICAgICAgIG5ld1RleHQgPSBuZXdUZXh0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gbmV3VmFsdWUgJiYgdGhpcy50ZXh0ID09PSBuZXdUZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckZpbHRlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgbWFwKChjYW5kaWRhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlRnJvbSA9IHRoaXMucHJvcCh0aGlzLnZhbHVlRmllbGQsIHRoaXMudmFsdWVQcmltaXRpdmUpO1xuICAgICAgICAgICAgY29uc3QgdGV4dEZyb20gPSB0aGlzLnByb3AodGhpcy50ZXh0RmllbGQsIHRoaXMudmFsdWVQcmltaXRpdmUpO1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZUZyb20oY2FuZGlkYXRlKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1RleHQgPSB0ZXh0RnJvbShjYW5kaWRhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhSXRlbTogY2FuZGlkYXRlLFxuICAgICAgICAgICAgICAgIHRleHQ6IG5ld1RleHQsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVQcmltaXRpdmUgPyBuZXdWYWx1ZSA6IGNhbmRpZGF0ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBjdXN0b21WYWx1ZVN0cmVhbXMgPSBwYXJ0aXRpb24oKCkgPT4gdGhpcy5hbGxvd0N1c3RvbSkodGhpcy5jdXN0b21WYWx1ZVN1YmplY3QucGlwZSh0aHJvdHRsZVRpbWUoMzAwKSkpO1xuICAgICAgICBjb25zdCBhbGxvd0N1c3RvbVZhbHVlU3RyZWFtID0gY3VzdG9tVmFsdWVTdHJlYW1zWzBdLnBpcGUodGFwKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgfSksIGZpbHRlcigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZUZyb20gPSB0aGlzLnByb3AodGhpcy52YWx1ZUZpZWxkLCB0aGlzLnZhbHVlUHJpbWl0aXZlKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc0NoYW5nZSA9IHRoaXMudGV4dCAhPT0gdmFsdWVGcm9tKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gaGFzQ2hhbmdlO1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGhhc0NoYW5nZTtcbiAgICAgICAgICAgIGlmICghaGFzQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckZpbHRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhc0NoYW5nZTtcbiAgICAgICAgfSksIHRoaXMudmFsdWVOb3JtYWxpemVyLCBtYXAoKG5vcm1hbGl6ZWRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjdXN0b206IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YUl0ZW06IG5vcm1hbGl6ZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLnRleHQsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5vcm1hbGl6ZWRWYWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBkaXNhYmxlQ3VzdG9tVmFsdWVTdHJlYW0gPSBjdXN0b21WYWx1ZVN0cmVhbXNbMV0ucGlwZShtYXAoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjdXN0b206IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YUl0ZW06IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB0ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBjbGVhclZhbHVlU3RyZWFtID0gdGhpcy5jbGVhclZhbHVlU3ViamVjdC5waXBlKG1hcCgoKSA9PiAoe1xuICAgICAgICAgICAgZGF0YUl0ZW06IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgfSkpKTtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZSh2YWx1ZVN0cmVhbSwgYWxsb3dDdXN0b21WYWx1ZVN0cmVhbSwgZGlzYWJsZUN1c3RvbVZhbHVlU3RyZWFtLCBjbGVhclZhbHVlU3RyZWFtKTtcbiAgICAgICAgdGhpcy52YWx1ZVN1YnNjcmlwdGlvbiA9IG1lcmdlZC5waXBlKGNhdGNoRXJyb3IoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kYXRhSXRlbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZW1pdFNlbGVjdGlvbkNoYW5nZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgdGhpcy5lbWl0VmFsdWVDaGFuZ2UoKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlVmFsdWVTdHJlYW0oKTtcbiAgICAgICAgICAgIHJldHVybiBvZihudWxsKTtcbiAgICAgICAgfSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kYXRhSXRlbSA9IHN0YXRlLmRhdGFJdGVtO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHN0YXRlLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gc3RhdGUudGV4dDtcbiAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jbGVhckZpbHRlcigpO1xuICAgICAgICAgICAgaWYgKHN0YXRlLmN1c3RvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5mb2N1c2VkID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXRTZWxlY3Rpb25DaGFuZ2Uoc3RhdGUuY3VzdG9tID8gdW5kZWZpbmVkIDogdGhpcy5kYXRhSXRlbSk7XG4gICAgICAgICAgICB0aGlzLmVtaXRWYWx1ZUNoYW5nZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXR0YWNoU3RyZWFtcygpIHtcbiAgICAgICAgaWYgKCFpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YnMuYWRkKHRoaXMubG9jYWxpemF0aW9uXG4gICAgICAgICAgICAuY2hhbmdlcy5zdWJzY3JpYmUoKHsgcnRsIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gcnRsID8gJ3J0bCcgOiAnbHRyJztcbiAgICAgICAgICAgIHRoaXMuc2V0TWVzc2FnZXMoKTtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLnN1YnMuYWRkKG1lcmdlKHRoaXMubmF2aWdhdGlvblNlcnZpY2UudXAsIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuZG93biwgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5ob21lLCB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmVuZClcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoZXZlbnQpID0+IGlzUHJlc2VudChldmVudC5pbmRleCkpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoZXZlbnQpID0+IHRoaXMubmF2aWdhdGUoZXZlbnQuaW5kZXgpKSk7XG4gICAgICAgIHRoaXMuc3Vicy5hZGQodGhpcy5uYXZpZ2F0aW9uU2VydmljZS5vcGVuLnN1YnNjcmliZSh0aGlzLmhhbmRsZU5hdmlnYXRpb25PcGVuLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5zdWJzLmFkZCh0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmNsb3NlLnN1YnNjcmliZSgoKSA9PiB0aGlzLnRvZ2dsZVBvcHVwKGZhbHNlKSkpO1xuICAgICAgICB0aGlzLnN1YnMuYWRkKHRoaXMubmF2aWdhdGlvblNlcnZpY2UuZXNjLnN1YnNjcmliZSh0aGlzLmhhbmRsZUVzY2FwZS5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuc3Vicy5hZGQodGhpcy5uYXZpZ2F0aW9uU2VydmljZS5lbnRlci5waXBlKHRhcCgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHRoaXMuaGFuZGxlRW50ZXIuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLnN1YnMuYWRkKG1lcmdlKHRoaXMuc2VsZWN0aW9uU2VydmljZS5vbkNoYW5nZSwgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLm9uU2VsZWN0LnBpcGUoZmlsdGVyKF8gPT4gIXRoaXMuaXNPcGVuKSkpXG4gICAgICAgICAgICAucGlwZSh0YXAoXyA9PiB7XG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlUG9wdXAoZmFsc2UpO1xuICAgICAgICB9KSwgbWFwKChldmVudCkgPT4gdGhpcy5kYXRhU2VydmljZS5pdGVtQXQoZXZlbnQuaW5kaWNlc1swXSkpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShkYXRhSXRlbSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZShkYXRhSXRlbSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5zdWJzLmFkZCh0aGlzLnNlbGVjdGlvblNlcnZpY2Uub25TZWxlY3QucGlwZShmaWx0ZXIoXyA9PiB0aGlzLmlzT3BlbiksIHRhcChfID0+IHRoaXMuX2ZpbHRlcmluZyA9IGZhbHNlKSwgbWFwKChldmVudCkgPT4gdGhpcy5kYXRhU2VydmljZS5pdGVtQXQoZXZlbnQuaW5kaWNlc1swXSkpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShkYXRhSXRlbSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKHsgZGF0YUl0ZW0gfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXRTZWxlY3Rpb25DaGFuZ2UoZGF0YUl0ZW0pO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3lQb3B1cCgpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tZXNzYWdlc1RpbWVvdXQpO1xuICAgICAgICB0aGlzLnN1YnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgW3RoaXMudmFsdWVTdWJzY3JpcHRpb24sIHRoaXMuc2VsZWN0aW9uU3Vic2NyaXB0aW9uXS5mb3JFYWNoKHN1YiA9PiBpc1ByZXNlbnQoc3ViKSAmJiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgY29uc3QgdmlydHVhbCA9IHRoaXMudmlydHVhbDtcbiAgICAgICAgY29uc3QgcmVxdWVzdEluaXRpYWxEYXRhID0gdmlydHVhbCAmJiBjaGFuZ2VzLmRhdGEgJiYgY2hhbmdlcy5kYXRhLmlzRmlyc3RDaGFuZ2UoKTtcbiAgICAgICAgaWYgKHJlcXVlc3RJbml0aWFsRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5wYWdlQ2hhbmdlKHsgc2tpcDogMCwgdGFrZTogdmlydHVhbC5wYWdlU2l6ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52YWx1ZVByaW1pdGl2ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlUHJpbWl0aXZlID0gdGhpcy52YWx1ZUZpZWxkID8gZmFsc2UgOiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVyaWZ5U2V0dGluZ3ModGhpcy52YWx1ZSk7XG4gICAgICAgIGlmIChpc0NoYW5nZWQoXCJ2YWx1ZU5vcm1hbGl6ZXJcIiwgY2hhbmdlcykpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlVmFsdWVTdHJlYW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDaGFuZ2VkKFwidmFsdWVcIiwgY2hhbmdlcykpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU2VsZWN0aW9uU3RyZWFtKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmFsdWVQcmltaXRpdmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZVByaW1pdGl2ZSA9IHRoaXMudmFsdWVGaWVsZCA/IGZhbHNlIDogdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBTVEFURV9QUk9QUyA9IC8odmFsdWV8dGV4dEZpZWxkfHZhbHVlRmllbGR8dmFsdWVQcmltaXRpdmUpL2c7XG4gICAgICAgIGlmIChTVEFURV9QUk9QUy50ZXN0KE9iamVjdC5rZXlzKGNoYW5nZXMpLmpvaW4oKSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBDb21ib0JveC5cbiAgICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNlYXJjaGJhci5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJsdXJzIHRoZSBDb21ib0JveC5cbiAgICAgKi9cbiAgICBibHVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoYmFyLmJsdXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBwb3B1cC4gSWYgeW91IHVzZSB0aGUgYHRvZ2dsZWAgbWV0aG9kIHRvIG9wZW4gb3IgY2xvc2UgdGhlIHBvcHVwLFxuICAgICAqIHRoZSBgb3BlbmAgYW5kIGBjbG9zZWAgZXZlbnRzIHdpbGwgbm90IGJlIGZpcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wZW4gLSBUaGUgc3RhdGUgb2YgdGhlIHBvcHVwLlxuICAgICAqL1xuICAgIHRvZ2dsZShvcGVuKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZShudWxsKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZShvcGVuKTtcbiAgICAgICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBvcGVuIHN0YXRlIG9mIHRoZSBwb3B1cC5cbiAgICAgKi9cbiAgICBnZXQgaXNPcGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3BlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgQ29tYm9Cb3guXG4gICAgICogSWYgeW91IHVzZSB0aGUgYHJlc2V0YCBtZXRob2QgdG8gY2xlYXIgdGhlIHZhbHVlIG9mIHRoZSBjb21wb25lbnQsXG4gICAgICogdGhlIG1vZGVsIHdpbGwgbm90IHVwZGF0ZSBhdXRvbWF0aWNhbGx5IGFuZCB0aGUgYHNlbGVjdGlvbkNoYW5nZWAgYW5kIGB2YWx1ZUNoYW5nZWAgZXZlbnRzIHdpbGwgbm90IGJlIGZpcmVkLlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNsZWFyU3RhdGUoKTtcbiAgICAgICAgdGhpcy5yZXNldFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLmNyZWF0ZVNlbGVjdGlvblN0cmVhbSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKiBVc2VkIGJ5IHRoZSBUZXh0Qm94Q29udGFpbmVyIHRvIGRldGVybWluZSBpZiB0aGUgZmxvYXRpbmcgbGFiZWxcbiAgICAgKiBzaG91bGQgYmUgcmVuZGVyZWQgaW4gdGhlIGlucHV0IHdoZW4gdGhlIGNvbXBvbmVudCBpcyBub3QgZm9jdXNlZC5cbiAgICAgKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICBjb25zdCB0ZXh0RW1wdHkgPSAhaXNQcmVzZW50KHRoaXMudGV4dCkgfHwgaXNFbXB0eVN0cmluZyh0aGlzLnRleHQpO1xuICAgICAgICBjb25zdCB2YWx1ZUVtcHR5ID0gIWlzUHJlc2VudCh0aGlzLnZhbHVlKSB8fCBpc0VtcHR5U3RyaW5nKHRoaXMudmFsdWUpO1xuICAgICAgICByZXR1cm4gdGV4dEVtcHR5ICYmIHZhbHVlRW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjbGVhclZhbHVlKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIHRoaXMuX2ZpbHRlcmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzRGF0YUl0ZW0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5yZXNldFNlbGVjdGlvbihbXSk7XG4gICAgICAgIHRoaXMuY2xlYXJWYWx1ZVN1YmplY3QubmV4dCgpO1xuICAgICAgICB0aGlzLl9maWx0ZXJpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlID09PSBudWxsID8gdW5kZWZpbmVkIDogdmFsdWU7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVTZWxlY3Rpb25TdHJlYW0oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbikge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgYnV0dG9uQ2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGluZyA/ICdrLWktbG9hZGluZycgOiB0aGlzLmljb25DbGFzcyB8fCAnay1pLWFycm93LXMnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25SZXNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgY29uc3QgcG9wdXBXcmFwcGVyID0gdGhpcy5wb3B1cFJlZi5wb3B1cEVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCB7IG1pbiwgbWF4IH0gPSB0aGlzLndpZHRoO1xuICAgICAgICAgICAgcG9wdXBXcmFwcGVyLnN0eWxlLm1pbldpZHRoID0gbWluO1xuICAgICAgICAgICAgcG9wdXBXcmFwcGVyLnN0eWxlLndpZHRoID0gbWF4O1xuICAgICAgICB9XG4gICAgfVxuICAgIHZlcmlmeVNldHRpbmdzKG5ld1ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlT3JUZXh0ID0gIWlzUHJlc2VudCh0aGlzLnZhbHVlRmllbGQpICE9PSAhaXNQcmVzZW50KHRoaXMudGV4dEZpZWxkKTtcbiAgICAgICAgaWYgKCFpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZhbHVlUHJpbWl0aXZlID09PSB0cnVlICYmIGlzUHJlc2VudChuZXdWYWx1ZSkgJiYgdHlwZW9mIG5ld1ZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoQ29tYm9Cb3hNZXNzYWdlcy5wcmltaXRpdmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZhbHVlUHJpbWl0aXZlID09PSBmYWxzZSAmJiBpc1ByZXNlbnQobmV3VmFsdWUpICYmIHR5cGVvZiBuZXdWYWx1ZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKENvbWJvQm94TWVzc2FnZXMub2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVPclRleHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihDb21ib0JveE1lc3NhZ2VzLnRleHRBbmRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlydHVhbCAmJiBpc05hTih0aGlzLnZpcnR1YWwuaXRlbUhlaWdodCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihDb21ib0JveE1lc3NhZ2VzLm5vSXRlbUhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0U3RhdGUoKSB7XG4gICAgICAgIC8vIEZpbHRlcmluZyBpbiBwcm9jZXNzLCBkbyBub3RoaW5nLlxuICAgICAgICBpZiAodGhpcy5fZmlsdGVyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICBjb25zdCB2YWx1ZUZpZWxkID0gdGhpcy52YWx1ZUZpZWxkO1xuICAgICAgICBjb25zdCBwcmltaXRpdmUgPSB0aGlzLnZhbHVlUHJpbWl0aXZlO1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IHRoaXMuZmluZERhdGFJdGVtKHsgcHJpbWl0aXZlLCB2YWx1ZUZpZWxkLCB2YWx1ZSB9KTtcbiAgICAgICAgaWYgKGlzUHJlc2VudChyZXNvbHZlZC5kYXRhSXRlbSkpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoeyBkYXRhSXRlbTogcmVzb2x2ZWQuZGF0YUl0ZW0sIGNvbmZpcm06IHRydWUgfSk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0U2VsZWN0aW9uKHJlc29sdmVkLmluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQodmFsdWUpICYmIHRoaXMuYWxsb3dDdXN0b20pIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoeyBkYXRhSXRlbTogdmFsdWUgfSk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0U2VsZWN0aW9uKC0xKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9wcmV2aW91c0RhdGFJdGVtICYmIHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoeyBkYXRhSXRlbTogdGhpcy5fcHJldmlvdXNEYXRhSXRlbSB9KTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJTdGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXNldFNlbGVjdGlvbigtMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlU3RhdGUoeyBkYXRhSXRlbSwgY29uZmlybSA9IGZhbHNlIH0pIHtcbiAgICAgICAgdGhpcy5kYXRhSXRlbSA9IGRhdGFJdGVtO1xuICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnByb3AodGhpcy50ZXh0RmllbGQsIHRoaXMudmFsdWVQcmltaXRpdmUpKGRhdGFJdGVtKTtcbiAgICAgICAgaWYgKGNvbmZpcm0pIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzRGF0YUl0ZW0gPSBkYXRhSXRlbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhclN0YXRlKCkge1xuICAgICAgICB0aGlzLnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZGF0YUl0ZW0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJlc2V0U2VsZWN0aW9uKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGNsZWFyID0gIWlzUHJlc2VudChpbmRleCkgfHwgaW5kZXggPCAwO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UucmVzZXRTZWxlY3Rpb24oY2xlYXIgPyBbXSA6IFtpbmRleF0pO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuZm9jdXNlZCA9IGluZGV4O1xuICAgIH1cbiAgICBmaXJzdEZvY3VzYWJsZUluZGV4KGluZGV4KSB7XG4gICAgICAgIGNvbnN0IG1heEluZGV4ID0gdGhpcy5kYXRhLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkSXRlbXNTZXJ2aWNlLmlzSW5kZXhEaXNhYmxlZChpbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybiAoaW5kZXggPCBtYXhJbmRleCkgPyB0aGlzLmZpcnN0Rm9jdXNhYmxlSW5kZXgoaW5kZXggKyAxKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kSW5kZXhQcmVkaWNhdGUodGV4dCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhU2VydmljZS5ncm91cGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaXRlbVRleHQgPSB0aGlzLnByb3AodGhpcy50ZXh0RmllbGQsIHRoaXMudmFsdWVQcmltaXRpdmUpKGl0ZW0udmFsdWUpO1xuICAgICAgICAgICAgICAgIGl0ZW1UZXh0ID0gIWlzUHJlc2VudChpdGVtVGV4dCkgPyBcIlwiIDogaXRlbVRleHQudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtVGV4dC5zdGFydHNXaXRoKHRleHQudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1UZXh0ID0gdGhpcy5wcm9wKHRoaXMudGV4dEZpZWxkLCB0aGlzLnZhbHVlUHJpbWl0aXZlKShpdGVtKTtcbiAgICAgICAgICAgICAgICBpdGVtVGV4dCA9ICFpc1ByZXNlbnQoaXRlbVRleHQpID8gXCJcIiA6IGl0ZW1UZXh0LnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVRleHQuc3RhcnRzV2l0aCh0ZXh0LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9wKGZpZWxkLCB1c2VQcmltaXRpdmUpIHtcbiAgICAgICAgcmV0dXJuIChkYXRhSXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChkYXRhSXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodXNlUHJpbWl0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZCAmJiBpc09iamVjdChkYXRhSXRlbSkgPyBkYXRhSXRlbVtmaWVsZF0gOiBkYXRhSXRlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhSXRlbVtmaWVsZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZpbmREYXRhSXRlbSh7IHByaW1pdGl2ZSwgdmFsdWVGaWVsZCwgdmFsdWUgfSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBkYXRhSXRlbTogbnVsbCxcbiAgICAgICAgICAgIGluZGV4OiAtMVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwcm9wID0gdGhpcy5wcm9wKHZhbHVlRmllbGQsIHByaW1pdGl2ZSk7XG4gICAgICAgIGxldCBjb21wYXJlcjtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVNlcnZpY2UuZ3JvdXBlZCkge1xuICAgICAgICAgICAgY29tcGFyZXIgPSAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wKGVsZW1lbnQudmFsdWUpID09PSBwcm9wKHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb21wYXJlciA9IChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3AoZWxlbWVudCkgPT09IHByb3AodmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZGF0YVNlcnZpY2UuZmluZEluZGV4KGNvbXBhcmVyKTtcbiAgICAgICAgcmVzdWx0LmRhdGFJdGVtID0gdGhpcy5kYXRhU2VydmljZS5pdGVtQXQoaW5kZXgpO1xuICAgICAgICByZXN1bHQuaW5kZXggPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc2VhcmNoKHRleHQsIHN0YXJ0RnJvbSA9IDApIHtcbiAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggJiYgdGhpcy5kYXRhU2VydmljZS5pdGVtc0NvdW50KSB7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuZGF0YVNlcnZpY2UuZmluZEluZGV4KHRoaXMuZmluZEluZGV4UHJlZGljYXRlKHRleHQpLCBzdGFydEZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZEl0ZW1zU2VydmljZS5pc0luZGV4RGlzYWJsZWQoaW5kZXgpKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggKyAxIDwgdGhpcy5kYXRhU2VydmljZS5pdGVtc0NvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2godGV4dCwgaW5kZXggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5mb2N1cygtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuZm9jdXMoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3VnZ2VzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VnZ2VzdGVkVGV4dCA9IGdldHRlcih0aGlzLmRhdGFTZXJ2aWNlLml0ZW1BdChpbmRleCksIHRoaXMudGV4dEZpZWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0U3VnZ2VzdGlvbigpIHtcbiAgICAgICAgY29uc3QgaGFzU2VsZWN0ZWQgPSAhIXRoaXMuc2VsZWN0aW9uU2VydmljZS5zZWxlY3RlZC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHNob3VsZFN1Z2dlc3QgPSB0aGlzLnN1Z2dlc3QgJiYgIXRoaXMuYmFja3NwYWNlUHJlc3NlZCAmJiB0aGlzLnN1Z2dlc3RlZFRleHQgJiYgdGhpcy50ZXh0O1xuICAgICAgICBpZiAoIWhhc1NlbGVjdGVkICYmIHNob3VsZFN1Z2dlc3QgJiYgdGhpcy5zdWdnZXN0ZWRUZXh0LnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCh0aGlzLnRleHQudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1Z2dlc3RlZFRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN1Z2dlc3RlZFRleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmF2aWdhdGUoaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVNlcnZpY2UuaXRlbXNDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dCA9IHRoaXMucHJvcCh0aGlzLnRleHRGaWVsZCwgdGhpcy52YWx1ZVByaW1pdGl2ZSkodGhpcy5kYXRhU2VydmljZS5pdGVtQXQoaW5kZXgpKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdChpbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVOYXZpZ2F0ZShldmVudCkge1xuICAgICAgICBjb25zdCBoYXNTZWxlY3RlZCA9IGlzUHJlc2VudCh0aGlzLnNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0ZWRbMF0pO1xuICAgICAgICBjb25zdCBmb2N1c2VkID0gaXNOYU4odGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmZvY3VzZWQpID8gdGhpcy5maXJzdEZvY3VzYWJsZUluZGV4KDApIDogdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmZvY3VzZWQ7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCB0aGlzLnJlYWRvbmx5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtleXMuaG9tZSB8fCBldmVudC5rZXlDb2RlID09PSBLZXlzLmVuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGFzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBLZXlzLmRvd24pIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtleXMudXApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMubmF2aWdhdGlvblNlcnZpY2UucHJvY2Vzcyh7XG4gICAgICAgICAgICBjdXJyZW50OiBvZmZzZXQgKyBmb2N1c2VkLFxuICAgICAgICAgICAgbWF4OiB0aGlzLmRhdGFTZXJ2aWNlLml0ZW1zQ291bnQgLSAxLFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhY3Rpb24gIT09IE5hdmlnYXRpb25BY3Rpb24uVW5kZWZpbmVkICYmXG4gICAgICAgICAgICBhY3Rpb24gIT09IE5hdmlnYXRpb25BY3Rpb24uTGVmdCAmJlxuICAgICAgICAgICAgYWN0aW9uICE9PSBOYXZpZ2F0aW9uQWN0aW9uLlJpZ2h0ICYmXG4gICAgICAgICAgICBhY3Rpb24gIT09IE5hdmlnYXRpb25BY3Rpb24uQmFja3NwYWNlICYmXG4gICAgICAgICAgICBhY3Rpb24gIT09IE5hdmlnYXRpb25BY3Rpb24uRGVsZXRlICYmXG4gICAgICAgICAgICAoKGFjdGlvbiA9PT0gTmF2aWdhdGlvbkFjdGlvbi5FbnRlciAmJiB0aGlzLmlzT3BlbikgfHwgYWN0aW9uICE9PSBOYXZpZ2F0aW9uQWN0aW9uLkVudGVyKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVFbnRlcigpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IHRoaXMudGV4dDtcbiAgICAgICAgY29uc3QgZm9jdXNlZCA9IHRoaXMuc2VsZWN0aW9uU2VydmljZS5mb2N1c2VkO1xuICAgICAgICBjb25zdCBoYXNGb2N1c2VkID0gaXNQcmVzZW50KGZvY3VzZWQpICYmIGZvY3VzZWQgIT09IC0xO1xuICAgICAgICBjb25zdCBwcmV2aW91c1RleHQgPSBnZXR0ZXIodGhpcy5fcHJldmlvdXNEYXRhSXRlbSwgdGhpcy50ZXh0RmllbGQpIHx8IFwiXCI7XG4gICAgICAgIGNvbnN0IGZvY3VzZWRJdGVtVGV4dCA9IGdldHRlcih0aGlzLmRhdGFTZXJ2aWNlLml0ZW1BdChmb2N1c2VkKSwgdGhpcy50ZXh0RmllbGQpO1xuICAgICAgICBjb25zdCB0ZXh0SGFzQ2hhbmdlZCA9IHRleHQgIT09IHByZXZpb3VzVGV4dDtcbiAgICAgICAgdGhpcy50b2dnbGVQb3B1cChmYWxzZSk7XG4gICAgICAgIHRoaXMuX2ZpbHRlcmluZyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5hbGxvd0N1c3RvbSAmJiB0ZXh0SGFzQ2hhbmdlZCkge1xuICAgICAgICAgICAgaWYgKHRleHQgPT09IGZvY3VzZWRJdGVtVGV4dCB8fCB0aGlzLnVzZVN1Z2dlc3Rpb24oKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5jaGFuZ2UoZm9jdXNlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZSh0ZXh0LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuYWxsb3dDdXN0b20pIHtcbiAgICAgICAgICAgIGlmIChoYXNGb2N1c2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmNoYW5nZShmb2N1c2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRleHRIYXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2UodGV4dCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUJsdXIoKSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlcmluZyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjdXJyZW50VGV4dCA9IHRoaXMuc2VhcmNoYmFyLnZhbHVlOyAvLyBUaGUgdmFsdWUgaXMgdXBkYXRlZCwgYnV0IHRoZSBBbmd1bGFyIGBjaGFuZ2VgIGV2ZW50IGlzIG5vdCBlbWl0dGVkIHlldCBhbmQgYHRoaXMudGV4dGAgaXMgbm90IHVwZGF0ZWQuIEZhaWxzIG9uIHN1Z2dlc3RlZCB0ZXh0LlxuICAgICAgICBpZiAoIWN1cnJlbnRUZXh0ICYmICFpc1ByZXNlbnQodGhpcy5fcHJldmlvdXNEYXRhSXRlbSkgJiYgIWlzUHJlc2VudCh0aGlzLmRhdGFJdGVtKSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVQb3B1cChmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5vbkJsdXIuZW1pdCgpO1xuICAgICAgICAgICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjaygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvY3VzZWQgPSB0aGlzLnNlbGVjdGlvblNlcnZpY2UuZm9jdXNlZDtcbiAgICAgICAgbGV0IGl0ZW1UZXh0O1xuICAgICAgICBjb25zdCBpc0l0ZW1Gb2N1c2VkID0gZm9jdXNlZCAhPT0gLTEgJiYgZm9jdXNlZCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaXNJdGVtRm9jdXNlZCkge1xuICAgICAgICAgICAgaXRlbVRleHQgPSBnZXR0ZXIodGhpcy5kYXRhU2VydmljZS5pdGVtQXQoZm9jdXNlZCksIHRoaXMudGV4dEZpZWxkKTtcbiAgICAgICAgICAgIGl0ZW1UZXh0ID0gIWlzUHJlc2VudChpdGVtVGV4dCkgPyBcIlwiIDogaXRlbVRleHQudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtVGV4dCA9PT0gY3VycmVudFRleHQudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmNoYW5nZShmb2N1c2VkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlKGN1cnJlbnRUZXh0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvZ2dsZVBvcHVwKGZhbHNlKTtcbiAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbkJsdXIuZW1pdCgpO1xuICAgICAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVFc2NhcGUoKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlUG9wdXAoZmFsc2UpO1xuICAgICAgICAvLyBjbGVhciB0aGUgZm9jdXMgb25seSBpZiB0aGUgZm9jdXNlZCBpdGVtIGlzIG5vdCBzZWxlY3RlZFxuICAgICAgICBjb25zdCBoYXNTZWxlY3RlZCA9IHRoaXMuc2VsZWN0aW9uU2VydmljZS5zZWxlY3RlZC5sZW5ndGggPiAwO1xuICAgICAgICBpZiAoIWhhc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN1Z2dlc3RlZFRleHQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmZvY3VzZWQgPSAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlTmF2aWdhdGlvbk9wZW4oKSB7XG4gICAgICAgIHRoaXMucmVzdG9yZUl0ZW1Gb2N1cygpO1xuICAgICAgICB0aGlzLnRvZ2dsZVBvcHVwKHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2VhcmNoQmFyQ2hhbmdlKHRleHQpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFRleHRMZW5ndGggPSB0aGlzLnRleHQgPyB0aGlzLnRleHQubGVuZ3RoIDogMDtcbiAgICAgICAgdGhpcy5iYWNrc3BhY2VQcmVzc2VkID0gKHRleHQubGVuZ3RoIDwgY3VycmVudFRleHRMZW5ndGgpID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICAvLyBSZXNldCB0aGUgc2VsZWN0aW9uIHByaW9yIHRvIGZpbHRlci4gSWYgYSBtYXRjaCBpcyBwcmVzZW50LCBpdCB3aWxsIGJlIHJlc29sdmVkLiBJZiBhIG1hdGNoIGlzIG5vdCBwcmVzZW50LCBpdCBpcyBub3QgbmVlZGVkLlxuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UucmVzZXRTZWxlY3Rpb24oW10pO1xuICAgICAgICB0aGlzLnRvZ2dsZVBvcHVwKHRydWUpO1xuICAgICAgICB0aGlzLl9maWx0ZXJpbmcgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJhYmxlICYmIHRoaXMuZmlsdGVyVGV4dCAhPT0gdGV4dCkge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJUZXh0ID0gdGV4dDtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyQ2hhbmdlLmVtaXQodGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlYXJjaCh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlRm9jdXMoKSB7XG4gICAgICAgIHRoaXMuaXNGb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vbkZvY3VzLmVtaXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHBhZ2VDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgdmlydHVhbCA9IHRoaXMudmlydHVhbDtcbiAgICAgICAgdmlydHVhbC5za2lwID0gZXZlbnQuc2tpcDtcbiAgICB9XG4gICAgY2hhbmdlKGNhbmRpZGF0ZSwgaXNDdXN0b20gPSBmYWxzZSkge1xuICAgICAgICBpZiAoaXNDdXN0b20pIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tVmFsdWVTdWJqZWN0Lm5leHQoY2FuZGlkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVTdWJqZWN0Lm5leHQoY2FuZGlkYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbWl0U2VsZWN0aW9uQ2hhbmdlKGRhdGFJdGVtKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3ViamVjdC5uZXh0KGRhdGFJdGVtKTtcbiAgICB9XG4gICAgZW1pdFZhbHVlQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sodGhpcy52YWx1ZSk7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh0aGlzLnZhbHVlKTtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNEYXRhSXRlbSA9IHRoaXMuZGF0YUl0ZW07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZWxlY3RDbGljaygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRvdWNoRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5zZWFyY2hiYXIuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3RvcmVJdGVtRm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvZ2dsZVBvcHVwKCF0aGlzLmlzT3Blbik7XG4gICAgfVxuICAgIGdldCBsaXN0Q29udGFpbmVyQ2xhc3NlcygpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyQ2xhc3NlcyA9IFsnay1saXN0LWNvbnRhaW5lcicsICdrLXJlc2V0J107XG4gICAgICAgIGlmICh0aGlzLnBvcHVwU2V0dGluZ3MucG9wdXBDbGFzcykge1xuICAgICAgICAgICAgY29udGFpbmVyQ2xhc3Nlcy5wdXNoKHRoaXMucG9wdXBTZXR0aW5ncy5wb3B1cENsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGFpbmVyQ2xhc3NlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgZmlyc3QgbWF0Y2ggd2hlbiB0aGVyZSdzIHRleHQgaW4gdGhlIGlucHV0IGZpZWxkLCBidXQgbm8gZm9jdXNlZCBpdGVtLlxuICAgICAqL1xuICAgIHJlc3RvcmVJdGVtRm9jdXMoKSB7XG4gICAgICAgIGNvbnN0IGhhc0ZvY3VzID0gaXNQcmVzZW50KHRoaXMuc2VsZWN0aW9uU2VydmljZS5mb2N1c2VkKSAmJiB0aGlzLnNlbGVjdGlvblNlcnZpY2UuZm9jdXNlZCA+IC0xO1xuICAgICAgICBpZiAoIWhhc0ZvY3VzICYmIHRoaXMudGV4dCAmJiB0aGlzLmRhdGFTZXJ2aWNlLml0ZW1zQ291bnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcmFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuZm9jdXNlZCA9IHRoaXMuZmlyc3RGb2N1c2FibGVJbmRleCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoKHRoaXMudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXNlU3VnZ2VzdGlvbigpIHtcbiAgICAgICAgaWYgKCEodGhpcy5zdWdnZXN0ICYmIGlzUHJlc2VudCh0aGlzLnNlYXJjaGJhci52YWx1ZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9jdXNlZERhdGFJdGVtID0gdGhpcy5kYXRhU2VydmljZS5pdGVtQXQodGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmZvY3VzZWQpO1xuICAgICAgICBjb25zdCBmb2N1c2VkSXRlbVRleHQgPSB0aGlzLnByb3AodGhpcy50ZXh0RmllbGQsIHRoaXMudmFsdWVQcmltaXRpdmUpKGZvY3VzZWREYXRhSXRlbSk7XG4gICAgICAgIGlmICghaXNQcmVzZW50KGZvY3VzZWRJdGVtVGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hiYXIudmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gZm9jdXNlZEl0ZW1UZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGRlc3Ryb3lQb3B1cCgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXBSZWYpIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXBSZWYucG9wdXBFbGVtZW50XG4gICAgICAgICAgICAgICAgLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMucG9wdXBNb3VzZURvd25IYW5kbGVyKTtcbiAgICAgICAgICAgIHRoaXMucG9wdXBSZWYuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucG9wdXBSZWYgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZVBvcHVwKCkge1xuICAgICAgICBpZiAodGhpcy52aXJ0dWFsKSB7XG4gICAgICAgICAgICB0aGlzLnZpcnR1YWwuc2tpcCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG9yaXpvbnRhbEFsaWduID0gdGhpcy5kaXJlY3Rpb24gPT09IFwicnRsXCIgPyBcInJpZ2h0XCIgOiBcImxlZnRcIjtcbiAgICAgICAgY29uc3QgYW5jaG9yUG9zaXRpb24gPSB7IGhvcml6b250YWw6IGhvcml6b250YWxBbGlnbiwgdmVydGljYWw6IFwiYm90dG9tXCIgfTtcbiAgICAgICAgY29uc3QgcG9wdXBQb3NpdGlvbiA9IHsgaG9yaXpvbnRhbDogaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbDogXCJ0b3BcIiB9O1xuICAgICAgICB0aGlzLnBvcHVwUmVmID0gdGhpcy5wb3B1cFNlcnZpY2Uub3Blbih7XG4gICAgICAgICAgICBhbmNob3I6IHRoaXMud3JhcHBlcixcbiAgICAgICAgICAgIGFuaW1hdGU6IHRoaXMucG9wdXBTZXR0aW5ncy5hbmltYXRlLFxuICAgICAgICAgICAgYXBwZW5kVG86IHRoaXMuYXBwZW5kVG8sXG4gICAgICAgICAgICBjb250ZW50OiB0aGlzLnBvcHVwVGVtcGxhdGUsXG4gICAgICAgICAgICBwb3B1cENsYXNzOiB0aGlzLmxpc3RDb250YWluZXJDbGFzc2VzLFxuICAgICAgICAgICAgcG9zaXRpb25Nb2RlOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgYW5jaG9yQWxpZ246IGFuY2hvclBvc2l0aW9uLFxuICAgICAgICAgICAgcG9wdXBBbGlnbjogcG9wdXBQb3NpdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcG9wdXBXcmFwcGVyID0gdGhpcy5wb3B1cFJlZi5wb3B1cEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHsgbWluLCBtYXggfSA9IHRoaXMud2lkdGg7XG4gICAgICAgIHBvcHVwV3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLnBvcHVwTW91c2VEb3duSGFuZGxlcik7XG4gICAgICAgIHBvcHVwV3JhcHBlci5zdHlsZS5taW5XaWR0aCA9IG1pbjtcbiAgICAgICAgcG9wdXBXcmFwcGVyLnN0eWxlLndpZHRoID0gbWF4O1xuICAgICAgICBwb3B1cFdyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIHBvcHVwV3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJkaXJcIiwgdGhpcy5kaXJlY3Rpb24pO1xuICAgICAgICB0aGlzLnBvcHVwUmVmLnBvcHVwT3Blbi5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zTGlzdC5zY3JvbGxUb0l0ZW0odGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmZvY3VzZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wb3B1cFJlZi5wb3B1cEFuY2hvclZpZXdwb3J0TGVhdmUuc3Vic2NyaWJlKCgpID0+IHRoaXMudG9nZ2xlUG9wdXAoZmFsc2UpKTtcbiAgICB9XG4gICAgX3RvZ2dsZShvcGVuKSB7XG4gICAgICAgIHRoaXMuX29wZW4gPSAob3BlbiA9PT0gdW5kZWZpbmVkKSA/ICF0aGlzLl9vcGVuIDogb3BlbjtcbiAgICAgICAgdGhpcy5kZXN0cm95UG9wdXAoKTtcbiAgICAgICAgaWYgKHRoaXMuX29wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlUG9wdXAoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmlnZ2VyUG9wdXBFdmVudHMob3Blbikge1xuICAgICAgICBjb25zdCBldmVudEFyZ3MgPSBuZXcgUHJldmVudGFibGVFdmVudCgpO1xuICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgdGhpcy5vcGVuLmVtaXQoZXZlbnRBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UuZW1pdChldmVudEFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudEFyZ3MuaXNEZWZhdWx0UHJldmVudGVkKCk7XG4gICAgfVxuICAgIGNsZWFyRmlsdGVyKCkge1xuICAgICAgICBpZiAoISh0aGlzLmZpbHRlcmFibGUgJiYgdGhpcy5maWx0ZXJUZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlsdGVyVGV4dCA9ICcnO1xuICAgICAgICB0aGlzLmZpbHRlckNoYW5nZS5lbWl0KHRoaXMuZmlsdGVyVGV4dCk7XG4gICAgfVxuICAgIHNldE1lc3NhZ2VzKCkge1xuICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm1lc3NhZ2VzVGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VzVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubm9EYXRhVGV4dCA9IHRoaXMubG9jYWxpemF0aW9uLmdldCgnbm9EYXRhVGV4dCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlU2VsZWN0aW9uU3RyZWFtKCkge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc2VsZWN0aW9uU3Vic2NyaXB0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvblN1YnNjcmlwdGlvbiA9IHRoaXMuc2VsZWN0aW9uU3ViamVjdFxuICAgICAgICAgICAgLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZGF0YUl0ZW0gPT4gdGhpcy5zZWxlY3Rpb25DaGFuZ2UuZW1pdChkYXRhSXRlbSkpO1xuICAgIH1cbn1cbkNvbWJvQm94Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdrZW5kb0NvbWJvQm94JyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgQ09NQk9CT1hfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgICAgICAgICAgICAgIERhdGFTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBTZWxlY3Rpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBOYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAgRGlzYWJsZWRJdGVtc1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEwxME5fUFJFRklYLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlVmFsdWU6ICdrZW5kby5jb21ib2JveCdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogRmlsdGVyYWJsZURyb3BEb3duQ29tcG9uZW50QmFzZSwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ29tYm9Cb3hDb21wb25lbnQpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEtlbmRvSW5wdXQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENvbWJvQm94Q29tcG9uZW50KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNvbWJvYm94JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyIGtlbmRvQ29tYm9Cb3hMb2NhbGl6ZWRNZXNzYWdlc1xuICAgICAgICAgICAgaTE4bi1ub0RhdGFUZXh0PVwia2VuZG8uY29tYm9ib3gubm9EYXRhVGV4dHxUaGUgdGV4dCBkaXNwbGF5ZWQgaW4gdGhlIHBvcHVwIHdoZW4gdGhlcmUgYXJlIG5vIGl0ZW1zXCJcbiAgICAgICAgICAgIG5vRGF0YVRleHQ9XCJOTyBEQVRBIEZPVU5EXCJcblxuICAgICAgICAgICAgaTE4bi1jbGVhclRpdGxlPVwia2VuZG8uY29tYm9ib3guY2xlYXJUaXRsZXxUaGUgdGl0bGUgb2YgdGhlIGNsZWFyIGJ1dHRvblwiXG4gICAgICAgICAgICBjbGVhclRpdGxlPVwiY2xlYXJcIlxuICAgICAgICA+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8c3BhbiAjd3JhcHBlciB1bnNlbGVjdGFibGU9XCJvblwiXG4gICAgICAgICAgICBjbGFzcz1cImstZHJvcGRvd24td3JhcFwiXG4gICAgICAgICAgICBbbmdDbGFzc109XCJ7ICdrLXN0YXRlLWRlZmF1bHQnOiAhZGlzYWJsZWQsICdrLXN0YXRlLWRpc2FibGVkJzogZGlzYWJsZWQsICdrLXN0YXRlLWZvY3VzZWQnOiBpc0ZvY3VzZWQgfVwiXG4gICAgICAgID5cbiAgICAgICAgICA8a2VuZG8tc2VhcmNoYmFyICNzZWFyY2hiYXJcbiAgICAgICAgICAgICAgW3JvbGVdPVwiJ2NvbWJvYm94J1wiXG4gICAgICAgICAgICAgIFtpZF09XCJmb2N1c2FibGVJZFwiXG4gICAgICAgICAgICAgIFtsaXN0SWRdPVwibGlzdEJveElkXCJcbiAgICAgICAgICAgICAgW2FjdGl2ZURlc2NlbmRhbnRdPVwiYWN0aXZlRGVzY2VuZGFudFwiXG4gICAgICAgICAgICAgIFtub0RhdGFMYWJlbF09XCJub0RhdGFMYWJlbFwiXG4gICAgICAgICAgICAgIFt1c2VySW5wdXRdPVwidGV4dFwiXG4gICAgICAgICAgICAgIFtzdWdnZXN0ZWRUZXh0XT1cImdldFN1Z2dlc3Rpb24oKVwiXG4gICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAgIFtyZWFkb25seV09XCJyZWFkb25seVwiXG4gICAgICAgICAgICAgIFt0YWJJbmRleF09XCJ0YWJJbmRleFwiXG4gICAgICAgICAgICAgIFtwb3B1cE9wZW5dPVwiaXNPcGVuXCJcbiAgICAgICAgICAgICAgW3BsYWNlaG9sZGVyXT1cInBsYWNlaG9sZGVyXCJcbiAgICAgICAgICAgICAgKG9uTmF2aWdhdGUpPVwiaGFuZGxlTmF2aWdhdGUoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICh2YWx1ZUNoYW5nZSk9XCJzZWFyY2hCYXJDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgICAgIChvbkJsdXIpPVwiaGFuZGxlQmx1cigpXCJcbiAgICAgICAgICAgICAgKG9uRm9jdXMpPVwiaGFuZGxlRm9jdXMoKVwiXG4gICAgICAgICAgPjwva2VuZG8tc2VhcmNoYmFyPlxuICAgICAgICAgIDxzcGFuICpuZ0lmPVwiIWxvYWRpbmcgJiYgIXJlYWRvbmx5ICYmIChjbGVhckJ1dHRvbiAmJiB0ZXh0Py5sZW5ndGgpXCIgY2xhc3M9XCJrLWljb24gay1jbGVhci12YWx1ZSBrLWktY2xvc2VcIiBbYXR0ci50aXRsZV09XCJjbGVhclRpdGxlXCIgcm9sZT1cImJ1dHRvblwiIHRhYmluZGV4PVwiLTFcIiAoY2xpY2spPVwiY2xlYXJWYWx1ZSgkZXZlbnQpXCIgKG1vdXNlZG93bik9XCIkZXZlbnQucHJldmVudERlZmF1bHQoKVwiPjwvc3Bhbj5cbiAgICAgICAgICA8c3BhbiB1bnNlbGVjdGFibGU9XCJvblwiXG4gICAgICAgICAgICAgIGNsYXNzPVwiay1zZWxlY3RcIlxuICAgICAgICAgICAgICAoY2xpY2spPVwic2VsZWN0Q2xpY2soKVwiXG4gICAgICAgICAgICAgIChtb3VzZWRvd24pPVwiJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIiA+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pY29uXCIgW25nQ2xhc3NdPVwiYnV0dG9uQ2xhc3Nlc1wiPlxuICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICA8bmctdGVtcGxhdGUgI3BvcHVwVGVtcGxhdGU+XG4gICAgICAgICAgICAgIDwhLS1oZWFkZXIgdGVtcGxhdGUtLT5cbiAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiaGVhZGVyVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgW3RlbXBsYXRlQ29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVSZWY6IGhlYWRlclRlbXBsYXRlLnRlbXBsYXRlUmVmXG4gICAgICAgICAgICAgICAgICB9XCI+XG4gICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgIDwhLS1saXN0LS0+XG4gICAgICAgICAgICAgIDxrZW5kby1saXN0XG4gICAgICAgICAgICAgICAgICAjb3B0aW9uc0xpc3RcbiAgICAgICAgICAgICAgICAgIFtpZF09XCJsaXN0Qm94SWRcIlxuICAgICAgICAgICAgICAgICAgW29wdGlvblByZWZpeF09XCJvcHRpb25QcmVmaXhcIlxuICAgICAgICAgICAgICAgICAgW2RhdGFdPVwiZGF0YVwiXG4gICAgICAgICAgICAgICAgICBbdGV4dEZpZWxkXT1cInRleHRGaWVsZFwiXG4gICAgICAgICAgICAgICAgICBbdmFsdWVGaWVsZF09XCJ2YWx1ZUZpZWxkXCJcbiAgICAgICAgICAgICAgICAgIFt0ZW1wbGF0ZV09XCJ0ZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICBbZ3JvdXBUZW1wbGF0ZV09XCJncm91cFRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgIFtmaXhlZEdyb3VwVGVtcGxhdGVdPVwiZml4ZWRHcm91cFRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgIFtoZWlnaHRdPVwibGlzdEhlaWdodFwiXG4gICAgICAgICAgICAgICAgICBbc2hvd109XCJpc09wZW5cIlxuICAgICAgICAgICAgICAgICAgW3ZpcnR1YWxdPVwidmlydHVhbFwiXG4gICAgICAgICAgICAgICAgICAocGFnZUNoYW5nZSk9XCJwYWdlQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDwva2VuZG8tbGlzdD5cbiAgICAgICAgICAgICAgPCEtLW5vLWRhdGEgdGVtcGxhdGUtLT5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImstbm9kYXRhXCIgKm5nSWY9XCJkYXRhLmxlbmd0aCA9PT0gMFwiPlxuICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIm5vRGF0YVRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICBbdGVtcGxhdGVDb250ZXh0XT1cIntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVSZWY6IG5vRGF0YVRlbXBsYXRlID8gbm9EYXRhVGVtcGxhdGUudGVtcGxhdGVSZWYgOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICB9XCI+XG4gICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFub0RhdGFUZW1wbGF0ZVwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxkaXY+e3sgbm9EYXRhVGV4dCB9fTwvZGl2PlxuICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwhLS1mb290ZXIgdGVtcGxhdGUtLT5cbiAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiZm9vdGVyVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgW3RlbXBsYXRlQ29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVSZWY6IGZvb3RlclRlbXBsYXRlLnRlbXBsYXRlUmVmXG4gICAgICAgICAgICAgICAgICB9XCI+XG4gICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiaXNPcGVuXCI+XG4gICAgICAgICAgICA8a2VuZG8tcmVzaXplLXNlbnNvciAocmVzaXplKT1cIm9uUmVzaXplKClcIj48L2tlbmRvLXJlc2l6ZS1zZW5zb3I+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDxuZy1jb250YWluZXIgI2NvbnRhaW5lcj48L25nLWNvbnRhaW5lcj5cbiAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Db21ib0JveENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFBvcHVwU2VydmljZSB9LFxuICAgIHsgdHlwZTogU2VsZWN0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmF2aWdhdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IERpc2FibGVkSXRlbXNTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBEYXRhU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmdab25lIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBCb29sZWFuLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW1RPVUNIX0VOQUJMRUQsXSB9XSB9XG5dO1xuQ29tYm9Cb3hDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZm9jdXNhYmxlSWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGFsbG93Q3VzdG9tOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkYXRhOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB2YWx1ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGV4dEZpZWxkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB2YWx1ZUZpZWxkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB2YWx1ZVByaW1pdGl2ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdmFsdWVOb3JtYWxpemVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBwbGFjZWhvbGRlcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcG9wdXBTZXR0aW5nczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbGlzdEhlaWdodDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaWNvbkNsYXNzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBsb2FkaW5nOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzdWdnZXN0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjbGVhckJ1dHRvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGlzYWJsZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGl0ZW1EaXNhYmxlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcmVhZG9ubHk6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRhYmluZGV4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0YWJJbmRleDogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFtcInRhYkluZGV4XCIsXSB9XSxcbiAgICBmaWx0ZXJhYmxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB2aXJ0dWFsOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB2YWx1ZUNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIHNlbGVjdGlvbkNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGZpbHRlckNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIG9wZW46IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBjbG9zZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIG9uRm9jdXM6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydmb2N1cycsXSB9XSxcbiAgICBvbkJsdXI6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydibHVyJyxdIH1dLFxuICAgIHRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtJdGVtVGVtcGxhdGVEaXJlY3RpdmUsXSB9XSxcbiAgICBoZWFkZXJUZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUsXSB9XSxcbiAgICBmb290ZXJUZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUsXSB9XSxcbiAgICBub0RhdGFUZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbTm9EYXRhVGVtcGxhdGVEaXJlY3RpdmUsXSB9XSxcbiAgICBncm91cFRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtHcm91cFRlbXBsYXRlRGlyZWN0aXZlLF0gfV0sXG4gICAgZml4ZWRHcm91cFRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtGaXhlZEdyb3VwVGVtcGxhdGVEaXJlY3RpdmUsXSB9XSxcbiAgICBjb250YWluZXI6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWydjb250YWluZXInLCB7IHJlYWQ6IFZpZXdDb250YWluZXJSZWYgfSxdIH1dLFxuICAgIHBvcHVwVGVtcGxhdGU6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWydwb3B1cFRlbXBsYXRlJyxdIH1dLFxuICAgIHNlYXJjaGJhcjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbU2VhcmNoQmFyQ29tcG9uZW50LF0gfV0sXG4gICAgb3B0aW9uc0xpc3Q6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWydvcHRpb25zTGlzdCcsXSB9XSxcbiAgICB3aWRnZXRDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXdpZGdldCcsXSB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstY29tYm9ib3gnLF0gfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWhlYWRlcicsXSB9XSxcbiAgICBjbGVhcmFibGU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstY29tYm9ib3gtY2xlYXJhYmxlJyxdIH1dLFxuICAgIGRpcjogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5kaXInLF0gfV1cbn07XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBSZW5kZXJzIHRoZSBzZWxlY3RlZCB2YWx1ZSBvZiB0aGUgRHJvcERvd25MaXN0XG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHRlbXBsYXRlc19kZGwgJX0jdG9jLXZhbHVlLXRlbXBsYXRlKSkuXG4gKiBUaGUgdGVtcGxhdGUgY29udGV4dCBpcyBzZXQgdG8gdGhlIGN1cnJlbnQgY29tcG9uZW50LlxuICogVG8gZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGRhdGEgaXRlbSwgdXNlIHRoZSBgbGV0LWRhdGFJdGVtYCBkaXJlY3RpdmUuXG4gKlxuICogPiBUaGUgYFZhbHVlVGVtcGxhdGVgIGRpcmVjdGl2ZSBjYW4gb25seSBiZSB1c2VkIHdpdGggdGhlIERyb3BEb3duTGlzdCBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBfQENvbXBvbmVudCh7XG4gKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiB0ZW1wbGF0ZTogYFxuICogIDxrZW5kby1kcm9wZG93bmxpc3QgW2RhdGFdPVwibGlzdEl0ZW1zXCI+XG4gKiAgICA8bmctdGVtcGxhdGUga2VuZG9Ecm9wRG93bkxpc3RWYWx1ZVRlbXBsYXRlIGxldC1kYXRhSXRlbT5cbiAqICAgICAgPHNwYW4+e3tkYXRhSXRlbX19IG9wdGlvbjwvc3Bhbj5cbiAqICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgPC9rZW5kby1kcm9wZG93bmxpc3Q+XG4gKiBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgcHVibGljIGxpc3RJdGVtczogQXJyYXk8c3RyaW5nPiA9IFtcIkl0ZW0gMVwiLCBcIkl0ZW0gMlwiLCBcIkl0ZW0gM1wiLCBcIkl0ZW0gNFwiXTtcbiAqIH1cbiAqIGBgYFxuICovXG5jbGFzcyBWYWx1ZVRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufVxuVmFsdWVUZW1wbGF0ZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRHJvcERvd25MaXN0VmFsdWVUZW1wbGF0ZV0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblZhbHVlVGVtcGxhdGVEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiB9XG5dO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBEUk9QRE9XTkxJU1RfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgbXVsdGk6IHRydWUsXG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXVzZS1iZWZvcmUtZGVjbGFyZVxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERyb3BEb3duTGlzdENvbXBvbmVudClcbn07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBEcm9wRG93bkxpc3QgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X2RkbCAlfSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBfQENvbXBvbmVudCh7XG4gKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiB0ZW1wbGF0ZTogYFxuICogIDxrZW5kby1kcm9wZG93bmxpc3QgW2RhdGFdPVwibGlzdEl0ZW1zXCI+XG4gKiAgPC9rZW5kby1kcm9wZG93bmxpc3Q+XG4gKiBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgcHVibGljIGxpc3RJdGVtczogQXJyYXk8c3RyaW5nPiA9IFtcIkl0ZW0gMVwiLCBcIkl0ZW0gMlwiLCBcIkl0ZW0gM1wiLCBcIkl0ZW0gNFwiXTtcbiAqIH1cbiAqIGBgYFxuICovXG5jbGFzcyBEcm9wRG93bkxpc3RDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbiwgcG9wdXBTZXJ2aWNlLCBzZWxlY3Rpb25TZXJ2aWNlLCBuYXZpZ2F0aW9uU2VydmljZSwgZGlzYWJsZWRJdGVtc1NlcnZpY2UsIGRhdGFTZXJ2aWNlLCBfem9uZSwgcmVuZGVyZXIsIGhvc3RFbGVtZW50LCBjZHIsIHRvdWNoRW5hYmxlZCkge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5wb3B1cFNlcnZpY2UgPSBwb3B1cFNlcnZpY2U7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZSA9IHNlbGVjdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UgPSBuYXZpZ2F0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5kaXNhYmxlZEl0ZW1zU2VydmljZSA9IGRpc2FibGVkSXRlbXNTZXJ2aWNlO1xuICAgICAgICB0aGlzLmRhdGFTZXJ2aWNlID0gZGF0YVNlcnZpY2U7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmhvc3RFbGVtZW50ID0gaG9zdEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuY2RyID0gY2RyO1xuICAgICAgICB0aGlzLnRvdWNoRW5hYmxlZCA9IHRvdWNoRW5hYmxlZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZm9jdXNhYmxlSWQgPSBgay0ke2d1aWQoKX1gO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBvcHRpb25zIGxpc3QuIEJ5IGRlZmF1bHQsIGBsaXN0SGVpZ2h0YCBpcyAyMDBweC5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBUaGUgYGxpc3RIZWlnaHRgIHByb3BlcnR5IGFmZmVjdHMgb25seSB0aGUgbGlzdCBvZiBvcHRpb25zIGFuZCBub3QgdGhlIHdob2xlIHBvcHVwIGNvbnRhaW5lci5cbiAgICAgICAgICogPiBUbyBzZXQgdGhlIGhlaWdodCBvZiB0aGUgcG9wdXAgY29udGFpbmVyLCB1c2UgYHBvcHVwU2V0dGluZ3MuaGVpZ2h0YC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdEhlaWdodCA9IDIwMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGRpc2FibGVkIHN0YXRlIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSByZWFkLW9ubHkgc3RhdGUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhZG9ubHkgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZXMgdGhlIFtmaWx0ZXJpbmddKHslIHNsdWcgZmlsdGVyaW5nX2RkbCAlfSkgZnVuY3Rpb25hbGl0eSBvZiB0aGUgRHJvcERvd25MaXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWx0ZXJhYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGVzIGEgY2FzZS1pbnNlbnNpdGl2ZSBzZWFyY2guIFdoZW4gZmlsdHJhdGlvbiBpcyBkaXNhYmxlZCwgdXNlIHRoaXMgb3B0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZ25vcmVDYXNlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGRlbGF5IGJlZm9yZSBhbiBpdGVtIHNlYXJjaCBpcyBwZXJmb3JtZWQuIFdoZW4gZmlsdHJhdGlvbiBpcyBkaXNhYmxlZCwgdXNlIHRoaXMgb3B0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWxheSA9IDUwMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgW2B0YWJpbmRleGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXgpIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdmFsdWUgaXMgY2hhbmdlZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X2RkbCAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIHR5cGVzIGluIHRoZSBpbnB1dCBmaWVsZFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X2RkbCAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqIFlvdSBjYW4gZmlsdGVyIHRoZSBzb3VyY2UgYmFzZWQgb24gdGhlIHBhc3NlZCBmaWx0cmF0aW9uIHZhbHVlLlxuICAgICAgICAgKiBXaGVuIHRoZSB2YWx1ZSBvZiB0aGUgY29tcG9uZW50IGlzIHByb2dyYW1tYXRpY2FsbHkgY2hhbmdlZCB0byBgbmdNb2RlbGAgb3IgYGZvcm1Db250cm9sYFxuICAgICAgICAgKiB0aHJvdWdoIGl0cyBBUEkgb3IgZm9ybSBiaW5kaW5nLCB0aGUgYHZhbHVlQ2hhbmdlYCBldmVudCBpcyBub3QgdHJpZ2dlcmVkIGJlY2F1c2UgaXRcbiAgICAgICAgICogbWlnaHQgY2F1c2UgYSBtaXgtdXAgd2l0aCB0aGUgYnVpbHQtaW4gYHZhbHVlQ2hhbmdlYCBtZWNoYW5pc21zIG9mIHRoZSBgbmdNb2RlbGAgb3IgYGZvcm1Db250cm9sYCBiaW5kaW5ncy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsdGVyQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBpdGVtIHNlbGVjdGlvbiBpcyBjaGFuZ2VkXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfZGRsICV9I3RvYy1ldmVudHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBwb3B1cCBpcyBhYm91dCB0byBvcGVuXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3BlbnN0YXRlX2RkbCAlfSN0b2MtcHJldmVudGluZy1vcGVuaW5nLWFuZC1jbG9zaW5nKSkuXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgcHJldmVudGFibGUuIElmIHlvdSBjYW5jZWwgaXQsIHRoZSBwb3B1cCB3aWxsIHJlbWFpbiBjbG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wZW4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHBvcHVwIGlzIGFib3V0IHRvIGNsb3NlXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3BlbnN0YXRlX2RkbCAlfSN0b2MtcHJldmVudGluZy1vcGVuaW5nLWFuZC1jbG9zaW5nKSkuXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgcHJldmVudGFibGUuIElmIHlvdSBjYW5jZWwgaXQsIHRoZSBwb3B1cCB3aWxsIHJlbWFpbiBvcGVuLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdXNlciBmb2N1c2VzIHRoZSBEcm9wRG93bkxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRm9jdXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7IC8vdHNsaW50OmRpc2FibGUtbGluZTpuby1vdXRwdXQtcmVuYW1lXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIERyb3BEb3duTGlzdCBnZXRzIGJsdXJyZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQmx1ciA9IG5ldyBFdmVudEVtaXR0ZXIoKTsgLy90c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLW91dHB1dC1yZW5hbWVcbiAgICAgICAgdGhpcy53aWRnZXRDbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ncm91cEluZGljZXMgPSBbXTtcbiAgICAgICAgdGhpcy5saXN0Qm94SWQgPSBndWlkKCk7XG4gICAgICAgIHRoaXMub3B0aW9uUHJlZml4ID0gZ3VpZCgpO1xuICAgICAgICB0aGlzLnZhbHVlTGFiZWxJZCA9IGd1aWQoKTtcbiAgICAgICAgdGhpcy5maWx0ZXJUZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjayA9IChfKSA9PiB7IH07XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IChfKSA9PiB7IH07XG4gICAgICAgIHRoaXMud29yZCA9IFwiXCI7XG4gICAgICAgIHRoaXMubGFzdCA9IFwiXCI7XG4gICAgICAgIHRoaXMuZmlsdGVyRm9jdXNlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5maWx0ZXJCbHVycmVkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLndyYXBwZXJGb2N1c2VkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLndyYXBwZXJCbHVycmVkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdGhpcy5fb3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wb3B1cFNldHRpbmdzID0geyBhbmltYXRlOiB0cnVlIH07XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gbG9jYWxpemF0aW9uLnJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLnN1YnNjcmliZUV2ZW50cygpO1xuICAgICAgICB0aGlzLmhvc3RFbGVtZW50ID0gaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdGhpcy5wb3B1cE1vdXNlRG93bkhhbmRsZXIgPSB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIGdldCB3aWR0aCgpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlcldpZHRoID0gaXNEb2N1bWVudEF2YWlsYWJsZSgpID8gdGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGggOiAwO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMucG9wdXBTZXR0aW5ncy53aWR0aCB8fCB3cmFwcGVyV2lkdGg7XG4gICAgICAgIGNvbnN0IG1pbldpZHRoID0gaXNOYU4od3JhcHBlcldpZHRoKSA/IHdyYXBwZXJXaWR0aCA6IGAke3dyYXBwZXJXaWR0aH1weGA7XG4gICAgICAgIGNvbnN0IG1heFdpZHRoID0gaXNOYU4od2lkdGgpID8gd2lkdGggOiBgJHt3aWR0aH1weGA7XG4gICAgICAgIHJldHVybiB7IG1pbjogbWluV2lkdGgsIG1heDogbWF4V2lkdGggfTtcbiAgICB9XG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgY29uc3QgcG9wdXBIZWlnaHQgPSB0aGlzLnBvcHVwU2V0dGluZ3MuaGVpZ2h0O1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHBvcHVwSGVpZ2h0KSA/IGAke3BvcHVwSGVpZ2h0fXB4YCA6ICdhdXRvJztcbiAgICB9XG4gICAgZ2V0IHdpZGdldFRhYkluZGV4KCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm92aWRlZFRhYkluZGV4ID0gTnVtYmVyKHRoaXMudGFiSW5kZXgpO1xuICAgICAgICBjb25zdCBkZWZhdWx0VGFiSW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gIWlzTmFOKHByb3ZpZGVkVGFiSW5kZXgpID8gcHJvdmlkZWRUYWJJbmRleCA6IGRlZmF1bHRUYWJJbmRleDtcbiAgICB9XG4gICAgZ2V0IGFyaWFFeHBhbmRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPcGVuO1xuICAgIH1cbiAgICBnZXQgYXJpYU93bnMoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5saXN0Qm94SWQ7XG4gICAgfVxuICAgIGdldCBhcmlhQWN0aXZlZGVzY2VuZGFudCgpIHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy5kYXRhSXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25QcmVmaXggKyBcIi1cIiArIGdldHRlcih0aGlzLmRhdGFJdGVtLCB0aGlzLnZhbHVlRmllbGQpO1xuICAgIH1cbiAgICBnZXQgbm9EYXRhTGFiZWwoKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFTZXJ2aWNlLml0ZW1zQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vRGF0YVRleHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGFwcGVuZFRvKCkge1xuICAgICAgICBjb25zdCB7IGFwcGVuZFRvIH0gPSB0aGlzLnBvcHVwU2V0dGluZ3M7XG4gICAgICAgIGlmICghYXBwZW5kVG8gfHwgYXBwZW5kVG8gPT09ICdyb290Jykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwZW5kVG8gPT09ICdjb21wb25lbnQnID8gdGhpcy5jb250YWluZXIgOiBhcHBlbmRUbztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGF0YSBvZiB0aGUgRHJvcERvd25MaXN0LlxuICAgICAqXG4gICAgICogPiBUaGUgZGF0YSBoYXMgdG8gYmUgcHJvdmlkZWQgaW4gYW4gYXJyYXktbGlrZSBsaXN0LlxuICAgICAqL1xuICAgIHNldCBkYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhU2VydmljZS5kYXRhID0gZGF0YSB8fCBbXTtcbiAgICAgICAgaWYgKHRoaXMudmlydHVhbCkge1xuICAgICAgICAgICAgdGhpcy52aXJ0dWFsLnNraXAgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoKTtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIGNvbnN0IHZpcnR1YWwgPSB0aGlzLnZpcnR1YWw7XG4gICAgICAgIGlmICh2aXJ0dWFsKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHZpcnR1YWwuc2tpcCB8fCAwO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gc3RhcnQgKyB2aXJ0dWFsLnBhZ2VTaXplO1xuICAgICAgICAgICAgLy8gVXNlIGxlbmd0aCBpbnN0ZWFkIG9mIGl0ZW1zQ291bnQgYmVjYXVzZSBvZiB0aGUgZ3JvdXBpbmcuXG4gICAgICAgICAgICB2aXJ0dWFsLnRvdGFsID0gdGhpcy5kYXRhU2VydmljZS5kYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTZXJ2aWNlLmRhdGEuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNlcnZpY2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIERyb3BEb3duTGlzdC5cbiAgICAgKiBJdCBjYW4gZWl0aGVyIGJlIG9mIHRoZSBwcmltaXRpdmUgKHN0cmluZywgbnVtYmVycykgb3Igb2YgdGhlIGNvbXBsZXggKG9iamVjdHMpIHR5cGUuXG4gICAgICogVG8gZGVmaW5lIHRoZSB0eXBlLCB1c2UgdGhlIGB2YWx1ZVByaW1pdGl2ZWAgb3B0aW9uLlxuICAgICAqXG4gICAgICogPiBBbGwgc2VsZWN0ZWQgdmFsdWVzIHdoaWNoIGFyZSBub3QgcHJlc2VudCBpbiB0aGUgc291cmNlIGFyZSBpZ25vcmVkLlxuICAgICAqL1xuICAgIHNldCB2YWx1ZShuZXdWYWx1ZSkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgdGhlIHBvcHVwIG9mIHRoZSBEcm9wRG93bkxpc3QuXG4gICAgICpcbiAgICAgKiBUaGUgYXZhaWxhYmxlIG9wdGlvbnMgYXJlOlxuICAgICAqIC0gYGFuaW1hdGU6IEJvb2xlYW5gJm1kYXNoO0NvbnRyb2xzIHRoZSBwb3B1cCBhbmltYXRpb24uIEJ5IGRlZmF1bHQsIHRoZSBvcGVuIGFuZCBjbG9zZSBhbmltYXRpb25zIGFyZSBlbmFibGVkLlxuICAgICAqIC0gYHdpZHRoOiBOdW1iZXIgfCBTdHJpbmdgJm1kYXNoO1NldHMgdGhlIHdpZHRoIG9mIHRoZSBwb3B1cCBjb250YWluZXIuIEJ5IGRlZmF1bHQsIHRoZSB3aWR0aCBvZiB0aGUgaG9zdCBlbGVtZW50IGlzIHVzZWQuIElmIHNldCB0byBgYXV0b2AsIHRoZSBjb21wb25lbnQgYXV0b21hdGljYWxseSBhZGp1c3RzIHRoZSB3aWR0aCBvZiB0aGUgcG9wdXAgYW5kIG5vIGl0ZW0gbGFiZWxzIGFyZSB3cmFwcGVkLiBUaGUgYGF1dG9gIG1vZGUgaXMgbm90IHN1cHBvcnRlZCB3aGVuIHZpcnR1YWwgc2Nyb2xsaW5nIGlzIGVuYWJsZWQuXG4gICAgICogLSBgaGVpZ2h0OiBOdW1iZXJgJm1kYXNoO1NldHMgdGhlIGhlaWdodCBvZiB0aGUgcG9wdXAgY29udGFpbmVyLlxuICAgICAqIC0gYHBvcHVwQ2xhc3M6IFN0cmluZ2AmbWRhc2g7U3BlY2lmaWVzIGEgbGlzdCBvZiBDU1MgY2xhc3NlcyB0aGF0IGFyZSB1c2VkIHRvIHN0eWxlIHRoZSBwb3B1cC5cbiAgICAgKiAtIGBhcHBlbmRUbzogXCJyb290XCIgfCBcImNvbXBvbmVudFwiIHwgVmlld0NvbnRhaW5lclJlZmAmbWRhc2g7U3BlY2lmaWVzIHRoZSBjb21wb25lbnQgdG8gd2hpY2ggdGhlIHBvcHVwIHdpbGwgYmUgYXBwZW5kZWQuXG4gICAgICovXG4gICAgc2V0IHBvcHVwU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5fcG9wdXBTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oeyBhbmltYXRlOiB0cnVlIH0sIHNldHRpbmdzKTtcbiAgICB9XG4gICAgZ2V0IHBvcHVwU2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3B1cFNldHRpbmdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGEgQm9vbGVhbiBmdW5jdGlvbiB0aGF0IGlzIGV4ZWN1dGVkIGZvciBlYWNoIGRhdGEgaXRlbSBpbiB0aGUgY29tcG9uZW50XG4gICAgICogKFtzZWUgZXhhbXBsZXNdKHslIHNsdWcgZGlzYWJsZWRpdGVtc19kZGwgJX0pKS4gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBpdGVtIHdpbGwgYmUgZGlzYWJsZWQuXG4gICAgICovXG4gICAgc2V0IGl0ZW1EaXNhYmxlZChmbikge1xuICAgICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGl0ZW1EaXNhYmxlZCBtdXN0IGJlIGEgZnVuY3Rpb24sIGJ1dCByZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KGZuKX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNhYmxlZEl0ZW1zU2VydmljZS5pdGVtRGlzYWJsZWQgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlcyB0aGUgW3ZpcnR1YWxpemF0aW9uXSh7JSBzbHVnIHZpcnR1YWxpemF0aW9uX2RkbCAlfSkgZnVuY3Rpb25hbGl0eS5cbiAgICAgKi9cbiAgICBzZXQgdmlydHVhbChzZXR0aW5ncykge1xuICAgICAgICB0aGlzLl92aXJ0dWFsU2V0dGluZ3MgPSBub3JtYWxpemVWaXJ0dWFsaXphdGlvblNldHRpbmdzKHNldHRpbmdzKTtcbiAgICB9XG4gICAgZ2V0IHZpcnR1YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXJ0dWFsU2V0dGluZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgdGFiSW5kZXgodGFiSW5kZXgpIHtcbiAgICAgICAgdGhpcy50YWJpbmRleCA9IHRhYkluZGV4O1xuICAgIH1cbiAgICBnZXQgdGFiSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhYmluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgYmx1ckNvbXBvbmVudCgpIHtcbiAgICAgICAgdGhpcy53cmFwcGVyQmx1cnJlZC5lbWl0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBibHVyRmlsdGVySW5wdXQoKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyQmx1cnJlZC5lbWl0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBmb2N1c0NvbXBvbmVudCgpIHtcbiAgICAgICAgdGhpcy53cmFwcGVyRm9jdXNlZC5lbWl0KCk7XG4gICAgICAgIGlmICghdGhpcy5pc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNGb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMub25Gb2N1cy5lbWl0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGtleWRvd24oZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZmlyc3RJbmRleCA9IGlzUHJlc2VudCh0aGlzLmRlZmF1bHRJdGVtKSA/IC0xIDogMDtcbiAgICAgICAgbGV0IGZvY3VzZWQgPSBpc05hTih0aGlzLnNlbGVjdGlvblNlcnZpY2UuZm9jdXNlZCkgPyB0aGlzLmZpcnN0Rm9jdXNhYmxlSW5kZXgoZmlyc3RJbmRleCkgOiB0aGlzLnNlbGVjdGlvblNlcnZpY2UuZm9jdXNlZDtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZG9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0hvbWVFbmQgPSBldmVudC5rZXlDb2RlID09PSBLZXlzLmhvbWUgfHwgZXZlbnQua2V5Q29kZSA9PT0gS2V5cy5lbmQ7XG4gICAgICAgIGNvbnN0IGlzRmlsdGVyRm9jdXNlZCA9IHRoaXMuZmlsdGVyYWJsZSAmJiB0aGlzLmlzRm9jdXNlZCAmJiB0aGlzLmlzT3BlbjtcbiAgICAgICAgaWYgKGlzRmlsdGVyRm9jdXNlZCAmJiBpc0hvbWVFbmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNTZWxlY3RlZCA9IGlzUHJlc2VudCh0aGlzLnNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0ZWRbMF0pO1xuICAgICAgICBjb25zdCBmb2N1c2VkSXRlbU5vdFNlbGVjdGVkID0gaXNQcmVzZW50KHRoaXMuc2VsZWN0aW9uU2VydmljZS5mb2N1c2VkKSAmJiAhdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmlzU2VsZWN0ZWQodGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmZvY3VzZWQpO1xuICAgICAgICBpZiAoIWhhc1NlbGVjdGVkIHx8IGZvY3VzZWRJdGVtTm90U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBLZXlzLmRvd24gfHwgZXZlbnQua2V5Q29kZSA9PT0gS2V5cy5yaWdodCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gS2V5cy51cCB8fCBldmVudC5rZXlDb2RlID09PSBLZXlzLmxlZnQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IGV2ZW50O1xuICAgICAgICBjb25zdCBhY3Rpb24gPSB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnByb2Nlc3Moe1xuICAgICAgICAgICAgY3VycmVudDogZm9jdXNlZCArIG9mZnNldCxcbiAgICAgICAgICAgIG1heDogdGhpcy5kYXRhU2VydmljZS5pdGVtc0NvdW50IC0gMSxcbiAgICAgICAgICAgIG1pbjogdGhpcy5kZWZhdWx0SXRlbSA/IC0xIDogMCxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50RGF0YVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbGVmdFJpZ2h0S2V5cyA9IChhY3Rpb24gPT09IE5hdmlnYXRpb25BY3Rpb24uTGVmdCkgfHwgKGFjdGlvbiA9PT0gTmF2aWdhdGlvbkFjdGlvbi5SaWdodCk7XG4gICAgICAgIGlmIChhY3Rpb24gIT09IE5hdmlnYXRpb25BY3Rpb24uVW5kZWZpbmVkICYmXG4gICAgICAgICAgICBhY3Rpb24gIT09IE5hdmlnYXRpb25BY3Rpb24uVGFiICYmXG4gICAgICAgICAgICBhY3Rpb24gIT09IE5hdmlnYXRpb25BY3Rpb24uQmFja3NwYWNlICYmXG4gICAgICAgICAgICBhY3Rpb24gIT09IE5hdmlnYXRpb25BY3Rpb24uRGVsZXRlICYmXG4gICAgICAgICAgICAhKGxlZnRSaWdodEtleXMgJiYgdGhpcy5maWx0ZXJhYmxlKSAmJlxuICAgICAgICAgICAgYWN0aW9uICE9PSBOYXZpZ2F0aW9uQWN0aW9uLkVudGVyIC8vZW50ZXIgd2hlbiBwb3B1cCBpcyBvcGVuZWQgaXMgaGFuZGxlZCBiZWZvcmUgYGhhbmRsZUVudGVyYFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGV2ZW50RGF0YS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBrZXlwcmVzcyhldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCB0aGlzLnJlYWRvbmx5IHx8IHRoaXMuZmlsdGVyYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25LZXlQcmVzcyhldmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjbGljaygpIHtcbiAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB0aGlzLnRvZ2dsZVBvcHVwKCF0aGlzLmlzT3Blbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvblJlc2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX29wZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcHVwV3JhcHBlciA9IHRoaXMucG9wdXBSZWYucG9wdXBFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgeyBtaW4sIG1heCB9ID0gdGhpcy53aWR0aDtcbiAgICAgICAgICAgIHBvcHVwV3JhcHBlci5zdHlsZS5taW5XaWR0aCA9IG1pbjtcbiAgICAgICAgICAgIHBvcHVwV3JhcHBlci5zdHlsZS53aWR0aCA9IG1heDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZGlyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb247XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLmhvc3RFbGVtZW50LCBcInRhYmluZGV4XCIpO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbkNoYW5nZXNTdWJzY3JpcHRpb24gPSB0aGlzLmxvY2FsaXphdGlvblxuICAgICAgICAgICAgLmNoYW5nZXMuc3Vic2NyaWJlKCh7IHJ0bCB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgICAgICAgICB0aGlzLnNldE1lc3NhZ2VzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldE1lc3NhZ2VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBVc2VkIGJ5IHRoZSBUZXh0Qm94Q29udGFpbmVyIHRvIGRldGVybWluZSBpZiB0aGUgY29tcG9uZW50IGlzIGVtcHR5LlxuICAgICAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuICEodmFsdWUgPT09IDAgfHwgdmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlIHx8IHRoaXMuZGVmYXVsdEl0ZW0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25GaWx0ZXJGb2N1cygpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJGb2N1c2VkLmVtaXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3lQb3B1cCgpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlRXZlbnRzKCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm1lc3NhZ2VzVGltZW91dCk7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsaXphdGlvbkNoYW5nZXNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxpemF0aW9uQ2hhbmdlc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uQ2hhbmdlcyhfY2hhbmdlcykge1xuICAgICAgICBjb25zdCB2aXJ0dWFsID0gdGhpcy52aXJ0dWFsO1xuICAgICAgICBjb25zdCByZXF1ZXN0SW5pdGlhbERhdGEgPSB2aXJ0dWFsICYmIF9jaGFuZ2VzLmRhdGEgJiYgX2NoYW5nZXMuZGF0YS5pc0ZpcnN0Q2hhbmdlKCk7XG4gICAgICAgIGlmIChyZXF1ZXN0SW5pdGlhbERhdGEpIHtcbiAgICAgICAgICAgIHRoaXMucGFnZUNoYW5nZSh7IHNraXA6IDAsIHRha2U6IHZpcnR1YWwucGFnZVNpemUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmFsdWVQcmltaXRpdmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZVByaW1pdGl2ZSA9IHRoaXMudmFsdWVGaWVsZCA/IGZhbHNlIDogdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2NoYW5nZXMuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSkge1xuICAgICAgICAgICAgdGhpcy52ZXJpZnlTZXR0aW5ncyhfY2hhbmdlcy52YWx1ZS5jdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2aW91c0RhdGFJdGVtID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChfY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eShcImRlZmF1bHRJdGVtXCIpKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVkSXRlbXNTZXJ2aWNlLmRlZmF1bHRJdGVtID0gdGhpcy5kZWZhdWx0SXRlbTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBTVEFURV9QUk9QUyA9IC8odmFsdWV8dGV4dEZpZWxkfHZhbHVlRmllbGR8dmFsdWVQcmltaXRpdmV8ZGVmYXVsdEl0ZW18aXRlbURpc2FibGVkKS9nO1xuICAgICAgICBpZiAoU1RBVEVfUFJPUFMudGVzdChPYmplY3Qua2V5cyhfY2hhbmdlcykuam9pbigpKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIERyb3BEb3duTGlzdC5cbiAgICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJsdXJzIHRoZSBEcm9wRG93bkxpc3QuXG4gICAgICovXG4gICAgYmx1cigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgcG9wdXBcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIG9wZW5zdGF0ZV9kZGwgJX0jdG9jLXNldHRpbmctdGhlLWluaXRpYWxseS1vcGVuZWQtY29tcG9uZW50KSkuXG4gICAgICogSWYgeW91IHVzZSB0aGUgYHRvZ2dsZWAgbWV0aG9kIHRvIG9wZW4gb3IgY2xvc2UgdGhlIHBvcHVwLCB0aGUgYG9wZW5gIGFuZCBgY2xvc2VgIGV2ZW50cyB3aWxsIG5vdCBiZSBmaXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcGVuIC0gVGhlIHN0YXRlIG9mIHRoZSBwb3B1cC5cbiAgICAgKi9cbiAgICB0b2dnbGUob3Blbikge1xuICAgICAgICAvLyBUaGUgUHJvbWlzZSBpcyByZXF1aXJlZCB0byBvcGVuIHRoZSBwb3B1cCBvbiBsb2FkLlxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSBcIkV4cHJlc3Npb24gaGFzIGNoYW5nZWQuLi5cIiB0eXBlIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgICAgICBQcm9taXNlLnJlc29sdmUobnVsbCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGUob3Blbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfdG9nZ2xlKG9wZW4pIHtcbiAgICAgICAgdGhpcy5fb3BlbiA9IChvcGVuID09PSB1bmRlZmluZWQpID8gIXRoaXMuX29wZW4gOiBvcGVuO1xuICAgICAgICB0aGlzLmRlc3Ryb3lQb3B1cCgpO1xuICAgICAgICBpZiAodGhpcy5fb3Blbikge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVQb3B1cCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyaWdnZXJQb3B1cEV2ZW50cyhvcGVuKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50QXJncyA9IG5ldyBQcmV2ZW50YWJsZUV2ZW50KCk7XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4uZW1pdChldmVudEFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbG9zZS5lbWl0KGV2ZW50QXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50QXJncy5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHRvZ2dsZVBvcHVwKG9wZW4pIHtcbiAgICAgICAgY29uc3QgaXNEaXNhYmxlZCA9IHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5yZWFkb25seTtcbiAgICAgICAgY29uc3Qgc2FtZVN0YXRlID0gdGhpcy5pc09wZW4gPT09IG9wZW47XG4gICAgICAgIGlmIChpc0Rpc2FibGVkIHx8IHNhbWVTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzRGVmYXVsdFByZXZlbnRlZCA9IHRoaXMudHJpZ2dlclBvcHVwRXZlbnRzKG9wZW4pO1xuICAgICAgICBpZiAoIWlzRGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgaWYgKCFvcGVuICYmIHRoaXMuZmlsdGVyYWJsZSAmJiB0aGlzLmlzRm9jdXNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZShvcGVuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG9wZW4gc3RhdGUgb2YgdGhlIHBvcHVwLlxuICAgICAqL1xuICAgIGdldCBpc09wZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcGVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIHZhbHVlIG9mIHRoZSBEcm9wRG93bkxpc3QuXG4gICAgICogSWYgeW91IHVzZSB0aGUgYHJlc2V0YCBtZXRob2QgdG8gY2xlYXIgdGhlIHZhbHVlIG9mIHRoZSBjb21wb25lbnQsXG4gICAgICogdGhlIG1vZGVsIHdpbGwgbm90IHVwZGF0ZSBhdXRvbWF0aWNhbGx5IGFuZCB0aGUgYHNlbGVjdGlvbkNoYW5nZWAgYW5kIGB2YWx1ZUNoYW5nZWAgZXZlbnRzIHdpbGwgbm90IGJlIGZpcmVkLlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLl9wcmV2aW91c0RhdGFJdGVtID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnNldFN0YXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5U2V0dGluZ3ModmFsdWUpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWUgPT09IG51bGwgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c0RhdGFJdGVtID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbikge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgYnV0dG9uQ2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGluZyA/ICdrLWktbG9hZGluZycgOiB0aGlzLmljb25DbGFzcyB8fCAnay1pLWFycm93LXMnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGxpc3RDb250YWluZXJDbGFzc2VzKCkge1xuICAgICAgICBjb25zdCBjb250YWluZXJDbGFzc2VzID0gWydrLWxpc3QtY29udGFpbmVyJywgJ2stcmVzZXQnXTtcbiAgICAgICAgaWYgKHRoaXMucG9wdXBTZXR0aW5ncy5wb3B1cENsYXNzKSB7XG4gICAgICAgICAgICBjb250YWluZXJDbGFzc2VzLnB1c2godGhpcy5wb3B1cFNldHRpbmdzLnBvcHVwQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250YWluZXJDbGFzc2VzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGlzRGlzYWJsZWREZWZhdWx0SXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWRJdGVtc1NlcnZpY2UuaXNJdGVtRGlzYWJsZWQodGhpcy5kZWZhdWx0SXRlbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXRUZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdEl0ZW1UZXh0KCkge1xuICAgICAgICByZXR1cm4gZ2V0dGVyKHRoaXMuZGVmYXVsdEl0ZW0sIHRoaXMudGV4dEZpZWxkKTtcbiAgICB9XG4gICAgY3JlYXRlUG9wdXAoKSB7XG4gICAgICAgIGlmICh0aGlzLnZpcnR1YWwpIHtcbiAgICAgICAgICAgIHRoaXMudmlydHVhbC5za2lwID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3Jpem9udGFsQWxpZ24gPSB0aGlzLmRpcmVjdGlvbiA9PT0gXCJydGxcIiA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xuICAgICAgICBjb25zdCBhbmNob3JQb3NpdGlvbiA9IHsgaG9yaXpvbnRhbDogaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbDogXCJib3R0b21cIiB9O1xuICAgICAgICBjb25zdCBwb3B1cFBvc2l0aW9uID0geyBob3Jpem9udGFsOiBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsOiBcInRvcFwiIH07XG4gICAgICAgIHRoaXMucG9wdXBSZWYgPSB0aGlzLnBvcHVwU2VydmljZS5vcGVuKHtcbiAgICAgICAgICAgIGFuY2hvcjogdGhpcy53cmFwcGVyLFxuICAgICAgICAgICAgYW5jaG9yQWxpZ246IGFuY2hvclBvc2l0aW9uLFxuICAgICAgICAgICAgYW5pbWF0ZTogdGhpcy5wb3B1cFNldHRpbmdzLmFuaW1hdGUsXG4gICAgICAgICAgICBhcHBlbmRUbzogdGhpcy5hcHBlbmRUbyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMucG9wdXBUZW1wbGF0ZSxcbiAgICAgICAgICAgIHBvcHVwQWxpZ246IHBvcHVwUG9zaXRpb24sXG4gICAgICAgICAgICBwb3B1cENsYXNzOiB0aGlzLmxpc3RDb250YWluZXJDbGFzc2VzLFxuICAgICAgICAgICAgcG9zaXRpb25Nb2RlOiAnYWJzb2x1dGUnXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwb3B1cFdyYXBwZXIgPSB0aGlzLnBvcHVwUmVmLnBvcHVwRWxlbWVudDtcbiAgICAgICAgY29uc3QgeyBtaW4sIG1heCB9ID0gdGhpcy53aWR0aDtcbiAgICAgICAgcG9wdXBXcmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMucG9wdXBNb3VzZURvd25IYW5kbGVyKTtcbiAgICAgICAgcG9wdXBXcmFwcGVyLnN0eWxlLm1pbldpZHRoID0gbWluO1xuICAgICAgICBwb3B1cFdyYXBwZXIuc3R5bGUud2lkdGggPSBtYXg7XG4gICAgICAgIHBvcHVwV3JhcHBlci5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgcG9wdXBXcmFwcGVyLnNldEF0dHJpYnV0ZShcImRpclwiLCB0aGlzLmRpcmVjdGlvbik7XG4gICAgICAgIHRoaXMucG9wdXBSZWYucG9wdXBPcGVuLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNMaXN0LnNjcm9sbFRvSXRlbSh0aGlzLnNlbGVjdGlvblNlcnZpY2UuZm9jdXNlZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoaXMuZmlsdGVyYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5wb3B1cFJlZi5wb3B1cEFuY2hvclZpZXdwb3J0TGVhdmUuc3Vic2NyaWJlKCgpID0+IHRoaXMudG9nZ2xlUG9wdXAoZmFsc2UpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95UG9wdXAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcHVwUmVmKSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVwUmVmLnBvcHVwRWxlbWVudFxuICAgICAgICAgICAgICAgIC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLnBvcHVwTW91c2VEb3duSGFuZGxlcik7XG4gICAgICAgICAgICB0aGlzLnBvcHVwUmVmLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnBvcHVwUmVmID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVTdGF0ZSh7IGRhdGFJdGVtLCBjb25maXJtID0gZmFsc2UgfSkge1xuICAgICAgICB0aGlzLmRhdGFJdGVtID0gZGF0YUl0ZW07XG4gICAgICAgIHRoaXMudGV4dCA9IHRoaXMucHJvcCh0aGlzLnRleHRGaWVsZCwgdGhpcy52YWx1ZVByaW1pdGl2ZSkoZGF0YUl0ZW0pO1xuICAgICAgICBpZiAoY29uZmlybSkge1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNEYXRhSXRlbSA9IGRhdGFJdGVtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyU3RhdGUoKSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5kYXRhSXRlbSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmVzZXRTZWxlY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgY29uc3QgY2xlYXIgPSAhaXNQcmVzZW50KGluZGV4KTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnJlc2V0U2VsZWN0aW9uKGNsZWFyID8gW10gOiBbaW5kZXhdKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmZvY3VzZWQgPSBjbGVhciA/IHRoaXMuZmlyc3RGb2N1c2FibGVJbmRleCgwKSA6IGluZGV4O1xuICAgIH1cbiAgICBvblNlbGVjdGlvbkNoYW5nZSh7IGRhdGFJdGVtIH0pIHtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSh7IGRhdGFJdGVtIH0pO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZS5lbWl0KGRhdGFJdGVtKTtcbiAgICAgICAgLyogZm9yY2VzIGZpcmVmb3gvbnZkYSwgZm9yZWZveC9qYXdzLCBpZS9qYXdzIHRvIHJlYWQgdGhlIG5ldyB2YWx1ZSB3aGVuXG4gICAgICAgICB0aGUgcG9wdXAgaXMgY2xvc2VkIGFuZCB0aGUgdmFsdWUgaXMgY2hhbmdlZCB3aXRoIHRoZSBhcnJvdyBrZXlzICh1cC9kb3duKSAqL1xuICAgICAgICB0aGlzLnZhbHVlTGFiZWxJZCA9IGd1aWQoKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlRXZlbnRzKCkge1xuICAgICAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0ZW0gc2VsZWN0aW9uIHdoZW4gdGhlIHBvcHVwIGlzIG9wZW4uXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3Vic2NyaXB0aW9uLmFkZCh0aGlzLnNlbGVjdGlvblNlcnZpY2Uub25TZWxlY3QucGlwZShmaWx0ZXIoXyA9PiB0aGlzLmlzT3BlbiksIG1hcCh0aGlzLml0ZW1Gcm9tRXZlbnQuYmluZCh0aGlzKSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHRoaXMub25TZWxlY3Rpb25DaGFuZ2UuYmluZCh0aGlzKSkpO1xuICAgICAgICAvLyBJdGVtIHNlbGVjdGlvbiB3aGVuIHRoZSBwb3B1cCBpcyBjbG9zZWQgfCBjbGlja2VkIHwgZW50ZXIsIGFuZCBzbyBvbi5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdWJzY3JpcHRpb24uYWRkKG1lcmdlKHRoaXMuc2VsZWN0aW9uU2VydmljZS5vblNlbGVjdC5waXBlKGZpbHRlcihfID0+ICF0aGlzLmlzT3BlbikpLCB0aGlzLnNlbGVjdGlvblNlcnZpY2Uub25DaGFuZ2UpLnBpcGUobWFwKHRoaXMuaXRlbUZyb21FdmVudC5iaW5kKHRoaXMpKSwgdGFwKF8gPT4gdGhpcy50b2dnbGVQb3B1cChmYWxzZSkpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoeyBkYXRhSXRlbSwgdmFsdWU6IG5ld1ZhbHVlLCBuZXdTZWxlY3Rpb24gfSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5ld1NlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UoeyBkYXRhSXRlbSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFVzZVByZXZpb3VzID0gIWlzUHJlc2VudChkYXRhSXRlbSkgJiYgdGhpcy5fcHJldmlvdXNEYXRhSXRlbTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFVzZU5ld1ZhbHVlID0gbmV3VmFsdWUgIT09IHRoaXMucHJvcCh0aGlzLnZhbHVlRmllbGQsIHRoaXMudmFsdWVQcmltaXRpdmUpKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgaWYgKHNob3VsZFVzZVByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSh7IGRhdGFJdGVtOiB0aGlzLl9wcmV2aW91c0RhdGFJdGVtIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNob3VsZFVzZU5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWVQcmltaXRpdmUgPyBuZXdWYWx1ZSA6IGRhdGFJdGVtO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzRGF0YUl0ZW0gPSBkYXRhSXRlbTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRDaGFuZ2UodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsZWFyRmlsdGVyKCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU3Vic2NyaXB0aW9uID0gbWVyZ2UodGhpcy5uYXZpZ2F0aW9uU2VydmljZS51cCwgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5kb3duLCB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmxlZnQucGlwZShza2lwV2hpbGUoKCkgPT4gdGhpcy5maWx0ZXJhYmxlKSksIHRoaXMubmF2aWdhdGlvblNlcnZpY2UucmlnaHQucGlwZShza2lwV2hpbGUoKCkgPT4gdGhpcy5maWx0ZXJhYmxlKSksIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuaG9tZSwgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5lbmQpXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoKGV2ZW50KSA9PiAhaXNOYU4oZXZlbnQuaW5kZXgpKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGV2ZW50KSA9PiB0aGlzLnNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0KGV2ZW50LmluZGV4KSk7XG4gICAgICAgIHRoaXMub3BlblN1YnNjcmlwdGlvbiA9IHRoaXMubmF2aWdhdGlvblNlcnZpY2Uub3Blbi5zdWJzY3JpYmUoKCkgPT4gdGhpcy50b2dnbGVQb3B1cCh0cnVlKSk7XG4gICAgICAgIHRoaXMuY2xvc2VTdWJzY3JpcHRpb24gPSB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmNsb3NlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVBvcHVwKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW50ZXJTdWJzY3JpcHRpb24gPSB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmVudGVyXG4gICAgICAgICAgICAucGlwZSh0YXAoKGV2ZW50KSA9PiBldmVudC5vcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCkpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSh0aGlzLmhhbmRsZUVudGVyLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmVzY1N1YnNjcmlwdGlvbiA9IHRoaXMubmF2aWdhdGlvblNlcnZpY2UuZXNjXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHRoaXMuaGFuZGxlRXNjYXBlLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmZpbHRlckJsdXJyZWRTdWJzY3JpcHRpb24gPSB0aGlzLmZpbHRlckJsdXJyZWQucGlwZShjb25jYXRNYXAoKCkgPT4gaW50ZXJ2YWwoMTApLnBpcGUodGFrZSgxKSwgdGFrZVVudGlsKHRoaXMud3JhcHBlckZvY3VzZWQpKSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMud3JhcHBlckJsdXJyZWQuZW1pdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudEJsdXJyZWRTdWJzY3JpcHRpb24gPVxuICAgICAgICAgICAgICAgIG1lcmdlKHRoaXMud3JhcHBlckJsdXJyZWQucGlwZShjb25jYXRNYXAoKCkgPT4gaW50ZXJ2YWwoMTApLnBpcGUodGFrZSgxKSwgdGFrZVVudGlsKHRoaXMuZmlsdGVyRm9jdXNlZCkpKSksIHRoaXMubmF2aWdhdGlvblNlcnZpY2UudGFiKS5waXBlKHRhcChldmVudCA9PiBldmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25FdmVudCAmJiB0aGlzLmZvY3VzKCkpLCBmaWx0ZXIoKCkgPT4gdGhpcy5pc0ZvY3VzZWQpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuX3pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRCbHVyKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmVFdmVudHMoKSB7XG4gICAgICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMub3BlblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmNsb3NlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuZW50ZXJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5lc2NTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRCbHVycmVkU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuZmlsdGVyQmx1cnJlZFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXRlbUZyb21FdmVudChldmVudCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGV2ZW50LmluZGljZXNbMF07XG4gICAgICAgIGxldCBkYXRhSXRlbSA9IHRoaXMuZGF0YVNlcnZpY2UuaXRlbUF0KGluZGV4KTtcbiAgICAgICAgZGF0YUl0ZW0gPSBpc1ByZXNlbnQoZGF0YUl0ZW0pID8gZGF0YUl0ZW0gOiB0aGlzLmN1cnJlbnRPckRlZmF1bHQoaW5kZXgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucHJvcCh0aGlzLnZhbHVlRmllbGQsIHRoaXMudmFsdWVQcmltaXRpdmUpKGRhdGFJdGVtKTtcbiAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gZXZlbnQubmV3U2VsZWN0aW9uO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YUl0ZW0sXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIG5ld1NlbGVjdGlvbixcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGN1cnJlbnRPckRlZmF1bHQoc2VsZWN0ZWRJbmRleCkge1xuICAgICAgICBjb25zdCBkZWZhdWx0SXRlbUluZGV4ID0gLTE7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5kYXRhSXRlbSkgJiYgc2VsZWN0ZWRJbmRleCAhPT0gZGVmYXVsdEl0ZW1JbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0SXRlbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaXJzdEZvY3VzYWJsZUluZGV4KGluZGV4KSB7XG4gICAgICAgIGNvbnN0IG1heEluZGV4ID0gdGhpcy5kYXRhU2VydmljZS5pdGVtc0NvdW50IC0gMTtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWRJdGVtc1NlcnZpY2UuaXNJbmRleERpc2FibGVkKGluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuIChpbmRleCA8IG1heEluZGV4KSA/IHRoaXMuZmlyc3RGb2N1c2FibGVJbmRleChpbmRleCArIDEpIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUVudGVyKCkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5jaGFuZ2UodGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmZvY3VzZWQpO1xuICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVQb3B1cCh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVFc2NhcGUoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5jaGFuZ2UodGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdGVkWzBdKTtcbiAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgIH1cbiAgICBjbGVhckZpbHRlcigpIHtcbiAgICAgICAgaWYgKCEodGhpcy5maWx0ZXJhYmxlICYmIHRoaXMuZmlsdGVyVGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbHRlclRleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgdGhpcy5maWx0ZXJDaGFuZ2UuZW1pdCh0aGlzLmZpbHRlclRleHQpO1xuICAgIH1cbiAgICB2ZXJpZnlTZXR0aW5ncyhuZXdWYWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZU9yVGV4dCA9ICFpc1ByZXNlbnQodGhpcy52YWx1ZUZpZWxkKSAhPT0gIWlzUHJlc2VudCh0aGlzLnRleHRGaWVsZCk7XG4gICAgICAgIGlmICghaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWZhdWx0SXRlbSAmJiB0aGlzLnZhbHVlRmllbGQgJiYgdHlwZW9mIHRoaXMuZGVmYXVsdEl0ZW0gIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihEcm9wRG93bkxpc3RNZXNzYWdlcy5kZWZhdWx0SXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmFsdWVQcmltaXRpdmUgPT09IHRydWUgJiYgaXNQcmVzZW50KG5ld1ZhbHVlKSAmJiB0eXBlb2YgbmV3VmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihEcm9wRG93bkxpc3RNZXNzYWdlcy5wcmltaXRpdmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZhbHVlUHJpbWl0aXZlID09PSBmYWxzZSAmJiBpc1ByZXNlbnQobmV3VmFsdWUpICYmIHR5cGVvZiBuZXdWYWx1ZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKERyb3BEb3duTGlzdE1lc3NhZ2VzLm9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlT3JUZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRHJvcERvd25MaXN0TWVzc2FnZXMudGV4dEFuZFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnRCbHVyKCkge1xuICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuY2hhbmdlKHRoaXMuc2VsZWN0aW9uU2VydmljZS5zZWxlY3RlZFswXSk7XG4gICAgICAgIHRoaXMub25CbHVyLmVtaXQoKTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IGV2ZW50LnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICh0YWdOYW1lICE9PSBcImlucHV0XCIpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25LZXlQcmVzcyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQud2hpY2ggPT09IDAgfHwgZXZlbnQua2V5Q29kZSA9PT0gS2V5cy5lbnRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaGFyYWN0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2ZW50LmNoYXJDb2RlIHx8IGV2ZW50LmtleUNvZGUpO1xuICAgICAgICBpZiAodGhpcy5pZ25vcmVDYXNlKSB7XG4gICAgICAgICAgICBjaGFyYWN0ZXIgPSBjaGFyYWN0ZXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhcmFjdGVyID09PSBcIiBcIikge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndvcmQgKz0gY2hhcmFjdGVyO1xuICAgICAgICB0aGlzLmxhc3QgPSBjaGFyYWN0ZXI7XG4gICAgICAgIHRoaXMuc2VhcmNoKCk7XG4gICAgfVxuICAgIHNlYXJjaCgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudHlwaW5nVGltZW91dCk7XG4gICAgICAgIGlmICghdGhpcy5maWx0ZXJhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy53b3JkID0gXCJcIjsgfSwgdGhpcy5kZWxheSk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdE5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3ROZXh0KCkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YVNlcnZpY2VcbiAgICAgICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGlzUHJlc2VudChpdGVtKSAmJiAhaXRlbS5oZWFkZXIgJiYgIXRoaXMuZGlzYWJsZWRJdGVtc1NlcnZpY2UuaXNJdGVtRGlzYWJsZWQoaXRlbSkpXG4gICAgICAgICAgICAubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhU2VydmljZS5ncm91cGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaXRlbTogaXRlbS52YWx1ZSwgaXRlbUluZGV4OiBpdGVtLm9mZnNldEluZGV4IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBpdGVtOiBpdGVtLCBpdGVtSW5kZXg6IHRoaXMuZGF0YVNlcnZpY2UuaW5kZXhPZihpdGVtKSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaXNJbkxvb3AgPSBzYW1lQ2hhcnNPbmx5KHRoaXMud29yZCwgdGhpcy5sYXN0KTtcbiAgICAgICAgbGV0IGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgbGV0IGhhc1NlbGVjdGVkID0gIWlzTmFOKHRoaXMuc2VsZWN0aW9uU2VydmljZS5zZWxlY3RlZFswXSk7XG4gICAgICAgIGxldCBzdGFydEluZGV4ID0gIWhhc1NlbGVjdGVkID8gMCA6IHRoaXMuc2VsZWN0aW9uU2VydmljZS5zZWxlY3RlZFswXTtcbiAgICAgICAgbGV0IHRleHQsIGluZGV4LCBkZWZhdWx0SXRlbTtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdEl0ZW0gJiYgIXRoaXMuZGlzYWJsZWRJdGVtc1NlcnZpY2UuaXNJdGVtRGlzYWJsZWQodGhpcy5kZWZhdWx0SXRlbSkpIHtcbiAgICAgICAgICAgIGRlZmF1bHRJdGVtID0geyBpdGVtOiB0aGlzLmRlZmF1bHRJdGVtLCBpdGVtSW5kZXg6IC0xIH07XG4gICAgICAgICAgICBkYXRhTGVuZ3RoICs9IDE7XG4gICAgICAgICAgICBzdGFydEluZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnRJbmRleCArPSBpc0luTG9vcCAmJiBoYXNTZWxlY3RlZCA/IDEgOiAwO1xuICAgICAgICBkYXRhID0gc2h1ZmZsZURhdGEoZGF0YSwgc3RhcnRJbmRleCwgZGVmYXVsdEl0ZW0pO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIGZvciAoOyBpbmRleCA8IGRhdGFMZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHRleHQgPSBnZXR0ZXIoZGF0YVtpbmRleF0uaXRlbSwgdGhpcy50ZXh0RmllbGQpO1xuICAgICAgICAgICAgY29uc3QgbG9vcE1hdGNoID0gQm9vbGVhbihpc0luTG9vcCAmJiBtYXRjaFRleHQodGV4dCwgdGhpcy5sYXN0LCB0aGlzLmlnbm9yZUNhc2UpKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRNYXRjaCA9IEJvb2xlYW4obWF0Y2hUZXh0KHRleHQsIHRoaXMud29yZCwgdGhpcy5pZ25vcmVDYXNlKSk7XG4gICAgICAgICAgICBpZiAobG9vcE1hdGNoIHx8IG5leHRNYXRjaCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZGF0YVtpbmRleF0uaXRlbUluZGV4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCAhPT0gZGF0YUxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0ZShpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1pdENoYW5nZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sodmFsdWUpO1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodmFsdWUpO1xuICAgIH1cbiAgICBuYXZpZ2F0ZShpbmRleCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0KGluZGV4KTtcbiAgICB9XG4gICAgcHJvcChmaWVsZCwgdXNlUHJpbWl0aXZlKSB7XG4gICAgICAgIHJldHVybiAoZGF0YUl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGF0YUl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVzZVByaW1pdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmllbGQgJiYgaXNPYmplY3QoZGF0YUl0ZW0pID8gZGF0YUl0ZW1bZmllbGRdIDogZGF0YUl0ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YUl0ZW1bZmllbGRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmaW5kRGF0YUl0ZW0oeyBwcmltaXRpdmUsIHZhbHVlRmllbGQsIHZhbHVlIH0pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgZGF0YUl0ZW06IG51bGwsXG4gICAgICAgICAgICBpbmRleDogLTFcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHJvcCA9IHRoaXMucHJvcCh2YWx1ZUZpZWxkLCBwcmltaXRpdmUpO1xuICAgICAgICBsZXQgY29tcGFyZXI7XG4gICAgICAgIGlmICh0aGlzLmRhdGFTZXJ2aWNlLmdyb3VwZWQpIHtcbiAgICAgICAgICAgIGNvbXBhcmVyID0gKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcChlbGVtZW50LnZhbHVlKSA9PT0gcHJvcCh2YWx1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29tcGFyZXIgPSAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wKGVsZW1lbnQpID09PSBwcm9wKHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmRhdGFTZXJ2aWNlLmZpbmRJbmRleChjb21wYXJlcik7XG4gICAgICAgIHJlc3VsdC5kYXRhSXRlbSA9IHRoaXMuZGF0YVNlcnZpY2UuaXRlbUF0KGluZGV4KTtcbiAgICAgICAgcmVzdWx0LmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHNldFN0YXRlKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGNvbnN0IHZhbHVlRmllbGQgPSB0aGlzLnZhbHVlRmllbGQ7XG4gICAgICAgIGNvbnN0IHRleHRGaWVsZCA9IHRoaXMudGV4dEZpZWxkO1xuICAgICAgICBjb25zdCBwcmltaXRpdmUgPSB0aGlzLnZhbHVlUHJpbWl0aXZlO1xuICAgICAgICBpZiAodGhpcy5kZWZhdWx0SXRlbSkge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gdGhpcy5wcm9wKHZhbHVlRmllbGQsIHByaW1pdGl2ZSkodGhpcy5kZWZhdWx0SXRlbSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLnByb3AodmFsdWVGaWVsZCwgcHJpbWl0aXZlKSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIWlzUHJlc2VudCh2YWx1ZSkgfHwgKGN1cnJlbnRWYWx1ZSA9PT0gZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoeyBkYXRhSXRlbTogdGhpcy5kZWZhdWx0SXRlbSwgY29uZmlybTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0U2VsZWN0aW9uKC0xKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJhYmxlICYmIHRoaXMuZmlsdGVyVGV4dCAmJiB0aGlzLmRhdGFTZXJ2aWNlLml0ZW1zQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmZvY3VzZWQgPSB0aGlzLmZpcnN0Rm9jdXNhYmxlSW5kZXgoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNvbHZlZCA9IHRoaXMuZmluZERhdGFJdGVtKHsgcHJpbWl0aXZlLCB2YWx1ZUZpZWxkLCB2YWx1ZSB9KTtcbiAgICAgICAgLy8gVGhlIGRhdGEgYW5kIHZhbHVlIGFyZSBvZiBzYW1lIHNoYXBlLFxuICAgICAgICAvLyBmb3IgZXhhbXBsZSwgdmFsdWU6ICdmb28nLCBkYXRhOiBbJ2ZvbycsICdiYXInXVxuICAgICAgICAvLyBvciB2YWx1ZTogeyB2YWx1ZTogMSwgdGV4dDogJ2ZvbycgfSwgZGF0YTogW3sgdmFsdWU6IDEsIHRleHQ6ICdmb28nIH1dLlxuICAgICAgICBjb25zdCBvZlNhbWVUeXBlID0gIShwcmltaXRpdmUgJiYgdGV4dEZpZWxkKTtcbiAgICAgICAgaWYgKHJlc29sdmVkLmRhdGFJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKHsgZGF0YUl0ZW06IHJlc29sdmVkLmRhdGFJdGVtLCBjb25maXJtOiB0cnVlIH0pO1xuICAgICAgICAgICAgdGhpcy5yZXNldFNlbGVjdGlvbihyZXNvbHZlZC5pbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQcmVzZW50KHZhbHVlKSAmJiBvZlNhbWVUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKHsgZGF0YUl0ZW06IHZhbHVlIH0pO1xuICAgICAgICAgICAgdGhpcy5yZXNldFNlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3ByZXZpb3VzRGF0YUl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoeyBkYXRhSXRlbTogdGhpcy5fcHJldmlvdXNEYXRhSXRlbSB9KTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJTdGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXNldFNlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVGaWx0ZXIoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJDaGFuZ2UuZW1pdChldmVudC50YXJnZXQudmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcGFnZUNoYW5nZShldmVudCkge1xuICAgICAgICBjb25zdCB2aXJ0dWFsID0gdGhpcy52aXJ0dWFsO1xuICAgICAgICB2aXJ0dWFsLnNraXAgPSBldmVudC5za2lwO1xuICAgIH1cbiAgICBzZXRNZXNzYWdlcygpIHtcbiAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tZXNzYWdlc1RpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlc1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vRGF0YVRleHQgPSB0aGlzLmxvY2FsaXphdGlvbi5nZXQoJ25vRGF0YVRleHQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuRHJvcERvd25MaXN0Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdrZW5kb0Ryb3BEb3duTGlzdCcsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIERST1BET1dOTElTVF9WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgICAgICAgICAgRGF0YVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIFNlbGVjdGlvblNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIE5hdmlnYXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBEaXNhYmxlZEl0ZW1zU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTDEwTl9QUkVGSVgsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLmRyb3Bkb3dubGlzdCdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogRmlsdGVyYWJsZURyb3BEb3duQ29tcG9uZW50QmFzZSwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRHJvcERvd25MaXN0Q29tcG9uZW50KVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBLZW5kb0lucHV0LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEcm9wRG93bkxpc3RDb21wb25lbnQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZHJvcGRvd25saXN0JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyIGtlbmRvRHJvcERvd25MaXN0TG9jYWxpemVkTWVzc2FnZXNcbiAgICAgICAgICAgIGkxOG4tbm9EYXRhVGV4dD1cImtlbmRvLmRyb3Bkb3dubGlzdC5ub0RhdGFUZXh0fFRoZSB0ZXh0IGRpc3BsYXllZCBpbiB0aGUgcG9wdXAgd2hlbiB0aGVyZSBhcmUgbm8gaXRlbXNcIlxuICAgICAgICAgICAgbm9EYXRhVGV4dD1cIk5PIERBVEEgRk9VTkRcIlxuICAgICAgICA+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8c3BhbiAjd3JhcHBlciB1bnNlbGVjdGFibGU9XCJvblwiXG4gICAgICAgICAgcm9sZT1cImxpc3Rib3hcIlxuICAgICAgICAgIFtpZF09XCJmb2N1c2FibGVJZFwiXG4gICAgICAgICAgW25nQ2xhc3NdPVwie1xuICAgICAgICAgICAgJ2stZHJvcGRvd24td3JhcCc6IHRydWUsXG4gICAgICAgICAgICAnay1zdGF0ZS1kZWZhdWx0JzogIXRoaXMuZGlzYWJsZWQsXG4gICAgICAgICAgICAnay1zdGF0ZS1kaXNhYmxlZCc6IHRoaXMuZGlzYWJsZWQsXG4gICAgICAgICAgICAnay1zdGF0ZS1mb2N1c2VkJzogdGhpcy5pc0ZvY3VzZWRcbiAgICAgICAgICB9XCJcbiAgICAgICAgICBbYXR0ci5kaXJdPVwiZGlyZWN0aW9uXCJcbiAgICAgICAgICBbYXR0ci5yZWFkb25seV09XCJyZWFkb25seVwiXG4gICAgICAgICAgW2F0dHIudGFiaW5kZXhdPVwid2lkZ2V0VGFiSW5kZXhcIlxuICAgICAgICAgIFthdHRyLmFyaWEtZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgIFthdHRyLmFyaWEtcmVhZG9ubHldPVwicmVhZG9ubHlcIlxuICAgICAgICAgIGFyaWEtaGFzcG9wdXA9XCJsaXN0Ym94XCJcbiAgICAgICAgICBbYXR0ci5hcmlhLWV4cGFuZGVkXT1cImFyaWFFeHBhbmRlZFwiXG4gICAgICAgICAgW2F0dHIuYXJpYS1vd25zXT1cImFyaWFPd25zXCJcbiAgICAgICAgICBbYXR0ci5hcmlhLWFjdGl2ZWRlc2NlbmRhbnRdPVwiYXJpYUFjdGl2ZWRlc2NlbmRhbnRcIlxuICAgICAgICAgIFthdHRyLmFyaWEtZGVzY3JpYmVkYnldPVwidmFsdWVMYWJlbElkXCJcbiAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cIm5vRGF0YUxhYmVsXCJcbiAgICAgICAgICAoZm9jdXMpPVwiZm9jdXNDb21wb25lbnQoKVwiXG4gICAgICAgICAgKGJsdXIpPVwiYmx1ckNvbXBvbmVudCgpXCJcbiAgICAgICAgICAoa2V5ZG93bik9XCJrZXlkb3duKCRldmVudClcIlxuICAgICAgICAgIChrZXlwcmVzcyk9XCJrZXlwcmVzcygkZXZlbnQpXCJcbiAgICAgICAgICAoY2xpY2spPVwiY2xpY2soKVwiXG4gICAgICAgID5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pbnB1dFwiIHVuc2VsZWN0YWJsZT1cIm9uXCIgW2lkXT1cInZhbHVlTGFiZWxJZFwiPlxuICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwidmFsdWVUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgW3RlbXBsYXRlQ29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlUmVmOiB2YWx1ZVRlbXBsYXRlLnRlbXBsYXRlUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAkaW1wbGljaXQ6IGRhdGFJdGVtXG4gICAgICAgICAgICAgICAgICAgfVwiPlxuICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhdmFsdWVUZW1wbGF0ZVwiPnt7IGdldFRleHQoKSB9fTwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLXNlbGVjdFwiIHVuc2VsZWN0YWJsZT1cIm9uXCI+XG4gICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstaWNvblwiXG4gICAgICAgICAgICAgICAgICAgIHVuc2VsZWN0YWJsZT1cIm9uXCJcbiAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwiYnV0dG9uQ2xhc3Nlc1wiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICA8bmctdGVtcGxhdGUgI3BvcHVwVGVtcGxhdGU+XG4gICAgICAgICAgICAgICA8IS0tZmlsdGVyYWJsZS0tPlxuXG4gICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiZmlsdGVyYWJsZVwiPlxuICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1saXN0LWZpbHRlclwiIChjbGljayk9XCIkZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLW93bnNdPVwiYXJpYU93bnNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1hY3RpdmVkZXNjZW5kYW50XT1cImFyaWFBY3RpdmVkZXNjZW5kYW50XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwibm9EYXRhTGFiZWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFiaW5kZXg9XCItMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBbZmlsdGVySW5wdXRdPVwiaXNGb2N1c2VkICYmICF0b3VjaEVuYWJsZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Rpcl09XCJkaXJlY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgWyhuZ01vZGVsKV09XCJmaWx0ZXJUZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay10ZXh0Ym94XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChrZXlkb3duKT1cImtleWRvd24oJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoaW5wdXQpPVwiaGFuZGxlRmlsdGVyKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZvY3VzKT1cIm9uRmlsdGVyRm9jdXMoKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoYmx1cik9XCJibHVyRmlsdGVySW5wdXQoKVwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pY29uIGstaS1zZWFyY2hcIiB1bnNlbGVjdGFibGU9XCJvblwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICAgPCEtLWRlZmF1bHQgaXRlbS0tPlxuICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImRlZmF1bHRJdGVtICYmICFpdGVtVGVtcGxhdGVcIj5cbiAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiay1saXN0LW9wdGlvbmxhYmVsXCIgW25nQ2xhc3NdPVwieyAnay1zdGF0ZS1kaXNhYmxlZCc6IGlzRGlzYWJsZWREZWZhdWx0SXRlbSB9XCIga2VuZG9Ecm9wRG93bnNTZWxlY3RhYmxlIFtpbmRleF09XCItMVwiPlxuICAgICAgICAgICAgICAgICAgICAgICB7eyBnZXREZWZhdWx0SXRlbVRleHQoKSB9fVxuICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJkZWZhdWx0SXRlbSAmJiBpdGVtVGVtcGxhdGVcIj5cbiAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiay1saXN0LW9wdGlvbmxhYmVsXCIgW25nQ2xhc3NdPVwieyAnay1zdGF0ZS1kaXNhYmxlZCc6IGlzRGlzYWJsZWREZWZhdWx0SXRlbSB9XCIga2VuZG9Ecm9wRG93bnNTZWxlY3RhYmxlIFtpbmRleF09XCItMVwiPlxuICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0ZW1wbGF0ZUNvbnRleHRdPVwie1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlUmVmOiBpdGVtVGVtcGxhdGUudGVtcGxhdGVSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGltcGxpY2l0OiBkZWZhdWx0SXRlbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVwiPlxuICAgICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgIDwhLS1oZWFkZXIgdGVtcGxhdGUtLT5cbiAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cImhlYWRlclRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgICBbdGVtcGxhdGVDb250ZXh0XT1cIntcbiAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVSZWY6IGhlYWRlclRlbXBsYXRlLnRlbXBsYXRlUmVmXG4gICAgICAgICAgICAgICAgICAgfVwiPlxuICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgIDwhLS1saXN0LS0+XG4gICAgICAgICAgICAgICA8a2VuZG8tbGlzdFxuICAgICAgICAgICAgICAgICAgICNvcHRpb25zTGlzdFxuICAgICAgICAgICAgICAgICAgIFtpZF09XCJsaXN0Qm94SWRcIlxuICAgICAgICAgICAgICAgICAgIFtvcHRpb25QcmVmaXhdPVwib3B0aW9uUHJlZml4XCJcbiAgICAgICAgICAgICAgICAgICBbZGF0YV09XCJkYXRhXCJcbiAgICAgICAgICAgICAgICAgICBbdGV4dEZpZWxkXT1cInRleHRGaWVsZFwiXG4gICAgICAgICAgICAgICAgICAgW3ZhbHVlRmllbGRdPVwidmFsdWVGaWVsZFwiXG4gICAgICAgICAgICAgICAgICAgW3RlbXBsYXRlXT1cIml0ZW1UZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgW2dyb3VwVGVtcGxhdGVdPVwiZ3JvdXBUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgW2ZpeGVkR3JvdXBUZW1wbGF0ZV09XCJmaXhlZEdyb3VwVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgIFtoZWlnaHRdPVwibGlzdEhlaWdodFwiXG4gICAgICAgICAgICAgICAgICAgW3Nob3ddPVwiaXNPcGVuXCJcbiAgICAgICAgICAgICAgICAgICBbdmlydHVhbF09XCJ2aXJ0dWFsXCJcbiAgICAgICAgICAgICAgICAgICAocGFnZUNoYW5nZSk9XCJwYWdlQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgIDwva2VuZG8tbGlzdD5cbiAgICAgICAgICAgICAgIDwhLS1uby1kYXRhIHRlbXBsYXRlLS0+XG4gICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiay1ub2RhdGFcIiAqbmdJZj1cImRhdGEubGVuZ3RoID09PSAwXCI+XG4gICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIm5vRGF0YVRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgW3RlbXBsYXRlQ29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVJlZjogbm9EYXRhVGVtcGxhdGUgPyBub0RhdGFUZW1wbGF0ZS50ZW1wbGF0ZVJlZiA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICB9XCI+XG4gICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIW5vRGF0YVRlbXBsYXRlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgIDxkaXY+e3sgbm9EYXRhVGV4dCB9fTwvZGl2PlxuICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgIDwhLS1mb290ZXIgdGVtcGxhdGUtLT5cbiAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cImZvb3RlclRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgICBbdGVtcGxhdGVDb250ZXh0XT1cIntcbiAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVSZWY6IGZvb3RlclRlbXBsYXRlLnRlbXBsYXRlUmVmXG4gICAgICAgICAgICAgICAgICAgfVwiPlxuICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImlzT3BlblwiPlxuICAgICAgICAgICAgPGtlbmRvLXJlc2l6ZS1zZW5zb3IgKHJlc2l6ZSk9XCJvblJlc2l6ZSgpXCI+PC9rZW5kby1yZXNpemUtc2Vuc29yPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8bmctY29udGFpbmVyICNjb250YWluZXI+PC9uZy1jb250YWluZXI+XG4gIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRHJvcERvd25MaXN0Q29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogUG9wdXBTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBTZWxlY3Rpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOYXZpZ2F0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogRGlzYWJsZWRJdGVtc1NlcnZpY2UgfSxcbiAgICB7IHR5cGU6IERhdGFTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICB7IHR5cGU6IEJvb2xlYW4sIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbVE9VQ0hfRU5BQkxFRCxdIH1dIH1cbl07XG5Ecm9wRG93bkxpc3RDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZm9jdXNhYmxlSWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGljb25DbGFzczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbG9hZGluZzogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGF0YTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdmFsdWU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRleHRGaWVsZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdmFsdWVGaWVsZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcG9wdXBTZXR0aW5nczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbGlzdEhlaWdodDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGVmYXVsdEl0ZW06IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRpc2FibGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBpdGVtRGlzYWJsZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHJlYWRvbmx5OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXJhYmxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB2aXJ0dWFsOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBpZ25vcmVDYXNlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkZWxheTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdmFsdWVQcmltaXRpdmU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRhYmluZGV4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0YWJJbmRleDogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFtcInRhYkluZGV4XCIsXSB9XSxcbiAgICB2YWx1ZUNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGZpbHRlckNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIHNlbGVjdGlvbkNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIG9wZW46IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBjbG9zZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIG9uRm9jdXM6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydmb2N1cycsXSB9XSxcbiAgICBvbkJsdXI6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydibHVyJyxdIH1dLFxuICAgIGl0ZW1UZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbSXRlbVRlbXBsYXRlRGlyZWN0aXZlLF0gfV0sXG4gICAgZ3JvdXBUZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbR3JvdXBUZW1wbGF0ZURpcmVjdGl2ZSxdIH1dLFxuICAgIGZpeGVkR3JvdXBUZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbRml4ZWRHcm91cFRlbXBsYXRlRGlyZWN0aXZlLF0gfV0sXG4gICAgdmFsdWVUZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbVmFsdWVUZW1wbGF0ZURpcmVjdGl2ZSxdIH1dLFxuICAgIGhlYWRlclRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSxdIH1dLFxuICAgIGZvb3RlclRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSxdIH1dLFxuICAgIG5vRGF0YVRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtOb0RhdGFUZW1wbGF0ZURpcmVjdGl2ZSxdIH1dLFxuICAgIGNvbnRhaW5lcjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ2NvbnRhaW5lcicsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiB9LF0gfV0sXG4gICAgcG9wdXBUZW1wbGF0ZTogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ3BvcHVwVGVtcGxhdGUnLF0gfV0sXG4gICAgd3JhcHBlcjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ3dyYXBwZXInLF0gfV0sXG4gICAgb3B0aW9uc0xpc3Q6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWydvcHRpb25zTGlzdCcsXSB9XSxcbiAgICB3aWRnZXRDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXdpZGdldCcsXSB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstZHJvcGRvd24nLF0gfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWhlYWRlcicsXSB9XSxcbiAgICBkaXI6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuZGlyJyxdIH1dXG59O1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUmVuZGVycyB0aGUgY29udGVudCBvZiB0aGUgY3VzdG9tIGxpc3QgaXRlbSBpbiB0aGUgTXVsdGlTZWxlY3RcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgdGVtcGxhdGVzX211bHRpc2VsZWN0ICV9I3RvYy1jdXN0b21pemluZy10aGUtaXRlbS1jb250ZW50KSkuXG4gKiBUaGUgdGVtcGxhdGUgY29udGV4dCBpcyBzZXQgdG8gdGhlIGN1cnJlbnQgY29tcG9uZW50LlxuICogVG8gZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHRleHQgdGhhdCBpcyB0eXBlZCBieSB0aGVcbiAqIHVzZXIsIHVzZSB0aGUgYGxldC1jdXN0b21JdGVtYCBkaXJlY3RpdmUuXG4gKlxuICogPiBUaGUgYEN1c3RvbUl0ZW1UZW1wbGF0ZWAgZGlyZWN0aXZlIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCB0aGUgTXVsdGlTZWxlY3QgY29tcG9uZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogX0BDb21wb25lbnQoe1xuICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICogdGVtcGxhdGU6IGBcbiAqICA8a2VuZG8tbXVsdGlzZWxlY3QgW2RhdGFdPVwibGlzdEl0ZW1zXCIgW2FsbG93Q3VzdG9tXT1cInRydWVcIj5cbiAqICAgIDxuZy10ZW1wbGF0ZSBrZW5kb011bHRpU2VsZWN0Q3VzdG9tSXRlbVRlbXBsYXRlIGxldC1jdXN0b21JdGVtPlxuICogICAgICA8c3Bhbj5OZXcgSXRlbToge3tjdXN0b21JdGVtfX08L3NwYW4+XG4gKiAgICA8L25nLXRlbXBsYXRlPlxuICogIDwva2VuZG8tbXVsdGlzZWxlY3Q+XG4gKiBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgcHVibGljIGxpc3RJdGVtczogQXJyYXk8c3RyaW5nPiA9IFtcIkl0ZW0gMVwiLCBcIkl0ZW0gMlwiLCBcIkl0ZW0gM1wiLCBcIkl0ZW0gNFwiXTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqL1xuY2xhc3MgQ3VzdG9tSXRlbVRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufVxuQ3VzdG9tSXRlbVRlbXBsYXRlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9NdWx0aVNlbGVjdEN1c3RvbUl0ZW1UZW1wbGF0ZV0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkN1c3RvbUl0ZW1UZW1wbGF0ZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmIH1cbl07XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBSZW5kZXJzIHRoZSBzZWxlY3RlZCB0YWcgdmFsdWUgb2YgdGhlIE11bHRpU2VsZWN0XG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHRlbXBsYXRlc19tdWx0aXNlbGVjdCAlfSN0b2MtdGFnLXRlbXBsYXRlKSkuXG4gKiBUaGUgdGVtcGxhdGUgY29udGV4dCBpcyBzZXQgdG8gdGhlIGN1cnJlbnQgY29tcG9uZW50LlxuICogVG8gZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGRhdGEgaXRlbSwgdXNlIHRoZSBgbGV0LWRhdGFJdGVtYCBkaXJlY3RpdmUuXG4gKlxuICogPiBUaGUgYFRhZ1RlbXBsYXRlYCBkaXJlY3RpdmUgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIHRoZSBNdWx0aVNlbGVjdCBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBfQENvbXBvbmVudCh7XG4gKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiB0ZW1wbGF0ZTogYFxuICogIDxrZW5kby1tdWx0aXNlbGVjdCBbZGF0YV09XCJpdGVtc1wiPlxuICogICAgPG5nLXRlbXBsYXRlIGtlbmRvTXVsdGlTZWxlY3RUYWdUZW1wbGF0ZSBsZXQtZGF0YUl0ZW0+XG4gKiAgICAgIDxzcGFuPnt7ZGF0YUl0ZW19fSBvcHRpb248L3NwYW4+XG4gKiAgICA8L25nLXRlbXBsYXRlPlxuICogIDwva2VuZG8tbXVsdGlzZWxlY3Q+XG4gKiBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgcHVibGljIGl0ZW1zOiBBcnJheTxzdHJpbmc+ID0gW1wiSXRlbSAxXCIsIFwiSXRlbSAyXCIsIFwiSXRlbSAzXCIsIFwiSXRlbSA0XCJdO1xuICogfVxuICogYGBgXG4gKi9cbmNsYXNzIFRhZ1RlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufVxuVGFnVGVtcGxhdGVEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb011bHRpU2VsZWN0VGFnVGVtcGxhdGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5UYWdUZW1wbGF0ZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmIH1cbl07XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBSZW5kZXJzIHRoZSBncm91cGVkIHRhZyB2YWx1ZXMgaW4gdGhlIE11bHRpU2VsZWN0XG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHN1bW1hcnl0YWdtb2RlX211bHRpc2VsZWN0ICV9KSkuXG4gKiBUaGUgdGVtcGxhdGUgY29udGV4dCBpcyBzZXQgdG8gdGhlIGN1cnJlbnQgY29tcG9uZW50LlxuICogVG8gZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGdyb3VwZWRcbiAqIGRhdGEgaXRlbXMgY29sbGVjdGlvbiwgdXNlIHRoZSBgbGV0LWRhdGFJdGVtc2AgZGlyZWN0aXZlLlxuICpcbiAqID4gVGhlIGBHcm91cFRhZ1RlbXBsYXRlYCBkaXJlY3RpdmUgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIHRoZSBNdWx0aVNlbGVjdCBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBfQENvbXBvbmVudCh7XG4gKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiB0ZW1wbGF0ZTogYFxuICogIDxrZW5kby1tdWx0aXNlbGVjdCBrZW5kb011bHRpU2VsZWN0U3VtbWFyeVRhZyBbZGF0YV09XCJpdGVtc1wiPlxuICogICAgPG5nLXRlbXBsYXRlIGtlbmRvTXVsdGlTZWxlY3RHcm91cFRhZ1RlbXBsYXRlIGxldC1kYXRhSXRlbXM+XG4gKiAgICAgIDxzcGFuPnt7ZGF0YUl0ZW1zLmxlbmd0aH19IGl0ZW0ocykgc2VsZWN0ZWQ8L3NwYW4+XG4gKiAgICA8L25nLXRlbXBsYXRlPlxuICogIDwva2VuZG8tbXVsdGlzZWxlY3Q+XG4gKiBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgcHVibGljIGl0ZW1zOiBBcnJheTxzdHJpbmc+ID0gW1wiSXRlbSAxXCIsIFwiSXRlbSAyXCIsIFwiSXRlbSAzXCIsIFwiSXRlbSA0XCJdO1xuICogfVxuICogYGBgXG4gKi9cbmNsYXNzIEdyb3VwVGFnVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59XG5Hcm91cFRhZ1RlbXBsYXRlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9NdWx0aVNlbGVjdEdyb3VwVGFnVGVtcGxhdGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Hcm91cFRhZ1RlbXBsYXRlRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogVGVtcGxhdGVSZWYgfVxuXTtcblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgcmVtb3ZlVGFnYCBldmVudC4gVGhlIGByZW1vdmVUYWdgIGV2ZW50IGZpcmVzIHdoZW4gYSB0YWcgaXMgYWJvdXRcbiAqIHRvIHRoZSByZW1vdmVkLiBJZiB5b3UgY2FuY2VsIHRoZSBldmVudCwgdGhlIHJlbW92YWwgaXMgcHJldmVudGVkLlxuICovXG5jbGFzcyBSZW1vdmVUYWdFdmVudCBleHRlbmRzIFByZXZlbnRhYmxlRXZlbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgdGhlIGV2ZW50IGFyZ3VtZW50cyBmb3IgdGhlIGByZW1vdmVgIGV2ZW50LlxuICAgICAqIEBwYXJhbSBkYXRhSXRlbSAtIFRoZSBkYXRhIGl0ZW0gb3IgYW4gYXJyYXkgb2YgZGF0YSBpdGVtcyB0aGF0IHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkYXRhSXRlbSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRhdGFJdGVtID0gZGF0YUl0ZW07XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbmNvbnN0IE1VTFRJU0VMRUNUX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIG11bHRpOiB0cnVlLFxuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby11c2UtYmVmb3JlLWRlY2xhcmVcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNdWx0aVNlbGVjdENvbXBvbmVudClcbn07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBNdWx0aVNlbGVjdCBjb21wb25lbnQgZm9yIEFuZ3VsYXJdKHslIHNsdWcgb3ZlcnZpZXdfbXVsdGlzZWxlY3QgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogX0BDb21wb25lbnQoe1xuICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICogdGVtcGxhdGU6IGBcbiAqICA8a2VuZG8tbXVsdGlzZWxlY3QgW2RhdGFdPVwibGlzdEl0ZW1zXCI+XG4gKiAgPC9rZW5kby1tdWx0aXNlbGVjdD5cbiAqIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICBwdWJsaWMgbGlzdEl0ZW1zOiBBcnJheTxzdHJpbmc+ID0gW1wiSXRlbSAxXCIsIFwiSXRlbSAyXCIsIFwiSXRlbSAzXCIsIFwiSXRlbSA0XCJdO1xuICogfVxuICogYGBgXG4gKi9cbmNsYXNzIE11bHRpU2VsZWN0Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24sIHBvcHVwU2VydmljZSwgZGF0YVNlcnZpY2UsIHNlbGVjdGlvblNlcnZpY2UsIG5hdmlnYXRpb25TZXJ2aWNlLCBkaXNhYmxlZEl0ZW1zU2VydmljZSwgY2RyLCBkaWZmZXJzLCByZW5kZXJlciwgaG9zdEVsZW1lbnQsIF96b25lLCB0b3VjaEVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMucG9wdXBTZXJ2aWNlID0gcG9wdXBTZXJ2aWNlO1xuICAgICAgICB0aGlzLmRhdGFTZXJ2aWNlID0gZGF0YVNlcnZpY2U7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZSA9IHNlbGVjdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UgPSBuYXZpZ2F0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5kaXNhYmxlZEl0ZW1zU2VydmljZSA9IGRpc2FibGVkSXRlbXNTZXJ2aWNlO1xuICAgICAgICB0aGlzLmNkciA9IGNkcjtcbiAgICAgICAgdGhpcy5kaWZmZXJzID0gZGlmZmVycztcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmhvc3RFbGVtZW50ID0gaG9zdEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgdGhpcy50b3VjaEVuYWJsZWQgPSB0b3VjaEVuYWJsZWQ7XG4gICAgICAgIHRoaXMubGlzdEJveElkID0gZ3VpZCgpO1xuICAgICAgICB0aGlzLnRhZ0xpc3RJZCA9IGd1aWQoKTtcbiAgICAgICAgdGhpcy50YWdQcmVmaXggPSBcInRhZy1cIiArIGd1aWQoKTtcbiAgICAgICAgdGhpcy5vcHRpb25QcmVmaXggPSBcIm9wdGlvbi1cIiArIGd1aWQoKTtcbiAgICAgICAgdGhpcy5mb2N1c2VkVGFnSW5kZXggPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvY3VzYWJsZUlkID0gYGstJHtndWlkKCl9YDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0byBjbG9zZSB0aGUgb3B0aW9ucyBsaXN0IG9mIHRoZSBNdWx0aVNlbGVjdCBhZnRlciB0aGUgaXRlbSBzZWxlY3Rpb24gaXMgZmluaXNoZWRcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBvcGVuc3RhdGVfbXVsdGlzZWxlY3QgJX0jdG9jLWtlZXBpbmctdGhlLW9wdGlvbnMtbGlzdC1vcGVuLXdoaWxlLW9uLWZvY3VzKSkuXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXV0b0Nsb3NlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgW2B0YWJpbmRleGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXgpIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGRpc2FibGVkIHN0YXRlIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSByZWFkLW9ubHkgc3RhdGUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhZG9ubHkgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZXMgdGhlIFtmaWx0ZXJpbmddKHslIHNsdWcgZmlsdGVyaW5nX211bHRpc2VsZWN0ICV9KSBmdW5jdGlvbmFsaXR5IG9mIHRoZSBNdWx0aVNlbGVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsdGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBzdWdnZXN0aW9ucyBsaXN0LiBCeSBkZWZhdWx0LCBgbGlzdEhlaWdodGAgaXMgMjAwcHguXG4gICAgICAgICAqXG4gICAgICAgICAqID4gVGhlIGBsaXN0SGVpZ2h0YCBwcm9wZXJ0eSBhZmZlY3RzIG9ubHkgdGhlIGxpc3Qgb2Ygc3VnZ2VzdGlvbnMgYW5kIG5vdCB0aGUgd2hvbGUgcG9wdXAgY29udGFpbmVyLlxuICAgICAgICAgKiA+IFRvIHNldCB0aGUgaGVpZ2h0IG9mIHRoZSBwb3B1cCBjb250YWluZXIsIHVzZSBgcG9wdXBTZXR0aW5ncy5oZWlnaHRgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0SGVpZ2h0ID0gMjAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc2V0IHRvIGB0cnVlYCwgcmVuZGVycyBhIGJ1dHRvbiBvbiBob3ZlcmluZyBvdmVyIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqIENsaWNraW5nIHRoaXMgYnV0dG9uIHJlc2V0cyB0aGUgdmFsdWUgb2YgdGhlIGNvbXBvbmVudCB0byBhbiBlbXB0eSBhcnJheSBhbmQgdHJpZ2dlcnMgdGhlIGBjaGFuZ2VgIGV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGVhckJ1dHRvbiA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHVzZXItZGVmaW5lZCBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCByZWNlaXZlcyBhbiBhcnJheSBvZiBzZWxlY3RlZCBkYXRhIGl0ZW1zIGFuZCBtYXBzIHRoZW0gdG8gYW4gYXJyYXkgb2YgdGFncy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHsgQW55W10gfSBkYXRhSXRlbXMgLSBUaGUgc2VsZWN0ZWQgZGF0YSBpdGVtcyBmcm9tIHRoZSBsaXN0LlxuICAgICAgICAgKiBAcmV0dXJucyB7IEFueVtdIH0gLSBUaGUgdGFncyB0aGF0IHdpbGwgYmUgcmVuZGVyZWQgYnkgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGFnTWFwcGVyID0gKHRhZ3MpID0+IHRhZ3MgfHwgW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB0aGUgTXVsdGlTZWxlY3QgYWxsb3dzIHVzZXItZGVmaW5lZCB2YWx1ZXMgdGhhdCBhcmUgbm90IHByZXNlbnQgaW4gdGhlIGRhdGFzZXRcbiAgICAgICAgICogKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlc10oeyUgc2x1ZyBjdXN0b21fdmFsdWVzX211bHRpc2VsZWN0ICV9KSkuXG4gICAgICAgICAqIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFsbG93Q3VzdG9tID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHVzZXItZGVmaW5lZCBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCByZXR1cm5zIG5vcm1hbGl6ZWQgY3VzdG9tIHZhbHVlcy5cbiAgICAgICAgICogVHlwaWNhbGx5IHVzZWQgd2hlbiB0aGUgZGF0YSBpdGVtcyBhcmUgZGlmZmVyZW50IGZyb20gdHlwZSBgc3RyaW5nYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHsgQW55IH0gdmFsdWUgLSBUaGUgY3VzdG9tIHZhbHVlIHRoYXQgaXMgZGVmaW5lZCBieSB0aGUgdXNlci5cbiAgICAgICAgICogQHJldHVybnMgeyBBbnkgfVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBpbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG4gICAgICAgICAqXG4gICAgICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAgICAgKiAgIDxrZW5kby1tdWx0aXNlbGVjdFxuICAgICAgICAgKiAgICAgICBbYWxsb3dDdXN0b21dPVwidHJ1ZVwiXG4gICAgICAgICAqICAgICAgIFtkYXRhXT1cImxpc3RJdGVtc1wiXG4gICAgICAgICAqICAgICAgIFt0ZXh0RmllbGRdPVwiJ3RleHQnXCJcbiAgICAgICAgICogICAgICAgW3ZhbHVlRmllbGRdPVwiJ3ZhbHVlJ1wiXG4gICAgICAgICAqICAgICAgIFt2YWx1ZU5vcm1hbGl6ZXJdPVwidmFsdWVOb3JtYWxpemVyXCJcbiAgICAgICAgICogICAgICAgKHZhbHVlQ2hhbmdlKT1cIm9uVmFsdWVDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAqICAgPlxuICAgICAgICAgKiAgIDwva2VuZG8tbXVsdGlzZWxlY3Q+XG4gICAgICAgICAqIGBcbiAgICAgICAgICogfSlcbiAgICAgICAgICpcbiAgICAgICAgICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgICAgICogICBwdWJsaWMgbGlzdEl0ZW1zOiBBcnJheTx7IHRleHQ6IHN0cmluZywgdmFsdWU6IG51bWJlciB9PiA9IFtcbiAgICAgICAgICogICAgICAgeyB0ZXh0OiBcIlNtYWxsXCIsIHZhbHVlOiAxIH0sXG4gICAgICAgICAqICAgICAgIHsgdGV4dDogXCJNZWRpdW1cIiwgdmFsdWU6IDIgfSxcbiAgICAgICAgICogICAgICAgeyB0ZXh0OiBcIkxhcmdlXCIsIHZhbHVlOiAzIH1cbiAgICAgICAgICogICBdO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgIHB1YmxpYyBvblZhbHVlQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgICAqICAgICAgIGNvbnNvbGUubG9nKFwidmFsdWVDaGFuZ2UgOiBcIiwgdmFsdWUpO1xuICAgICAgICAgKiAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICogICBwdWJsaWMgdmFsdWVOb3JtYWxpemVyID0gKHRleHQkOiBPYnNlcnZhYmxlPHN0cmluZz4pID0+IHRleHQkLnBpcGUobWFwKCh0ZXh0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICogICAgICByZXR1cm4ge1xuICAgICAgICAgKiAgICAgICAgIHZhbHVlOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoMTAwMCAtIDEwMCkgKyAxMDAwKSwgLy9nZW5lcmF0ZSB1bmlxdWUgdmFsdWVGaWVsZFxuICAgICAgICAgKiAgICAgICAgIHRleHQ6IHRleHQgfTtcbiAgICAgICAgICogICB9KSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlTm9ybWFsaXplciA9ICh0ZXh0KSA9PiB0ZXh0LnBpcGUobWFwKCh1c2VySW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBhcmVyID0gKGl0ZW0pID0+IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJyAmJiB1c2VySW5wdXQudG9Mb3dlckNhc2UoKSA9PT0gaXRlbS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmdWYWx1ZSA9IHRoaXMudmFsdWUuZmluZChjb21wYXJlcik7XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmdJdGVtID0gdGhpcy5kYXRhU2VydmljZS5maW5kKGNvbXBhcmVyKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ0l0ZW0gPyBtYXRjaGluZ0l0ZW0gOiB1c2VySW5wdXQ7XG4gICAgICAgIH0pKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdXNlciB0eXBlcyBpbiB0aGUgaW5wdXQgZmllbGQuXG4gICAgICAgICAqIFlvdSBjYW4gZmlsdGVyIHRoZSBzb3VyY2UgYmFzZWQgb24gdGhlIHBhc3NlZCBmaWx0cmF0aW9uIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWx0ZXJDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHZhbHVlIGlzIGNoYW5nZWQmbWRhc2g7XG4gICAgICAgICAqIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBibHVycmVkIG9yIHRoZSB2YWx1ZSBpcyBjbGVhcmVkIHRocm91Z2ggdGhlICoqQ2xlYXIqKiBidXR0b25cbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19tdWx0aXNlbGVjdCAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqIFdoZW4gdGhlIHZhbHVlIG9mIHRoZSBjb21wb25lbnQgaXMgcHJvZ3JhbW1hdGljYWxseSBjaGFuZ2VkIHRvIGBuZ01vZGVsYCBvciBgZm9ybUNvbnRyb2xgXG4gICAgICAgICAqIHRocm91Z2ggaXRzIEFQSSBvciBmb3JtIGJpbmRpbmcsIHRoZSBgdmFsdWVDaGFuZ2VgIGV2ZW50IGlzIG5vdCB0cmlnZ2VyZWQgYmVjYXVzZSBpdFxuICAgICAgICAgKiBtaWdodCBjYXVzZSBhIG1peC11cCB3aXRoIHRoZSBidWlsdC1pbiBgdmFsdWVDaGFuZ2VgIG1lY2hhbmlzbXMgb2YgdGhlIGBuZ01vZGVsYCBvciBgZm9ybUNvbnRyb2xgIGJpbmRpbmdzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgcG9wdXAgaXMgYWJvdXQgdG8gb3BlblxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIG9wZW5zdGF0ZV9tdWx0aXNlbGVjdCAlfSN0b2MtcHJldmVudGluZy1vcGVuaW5nLWFuZC1jbG9zaW5nKSkuXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgcHJldmVudGFibGUuIElmIHlvdSBjYW5jZWwgaXQsIHRoZSBwb3B1cCB3aWxsIHJlbWFpbiBjbG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wZW4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHBvcHVwIGlzIGFib3V0IHRvIGNsb3NlXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3BlbnN0YXRlX211bHRpc2VsZWN0ICV9I3RvYy1wcmV2ZW50aW5nLW9wZW5pbmctYW5kLWNsb3NpbmcpKS5cbiAgICAgICAgICogVGhpcyBldmVudCBpcyBwcmV2ZW50YWJsZS4gSWYgeW91IGNhbmNlbCBpdCwgdGhlIHBvcHVwIHdpbGwgcmVtYWluIG9wZW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIGZvY3VzZXMgdGhlIE11bHRpU2VsZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkZvY3VzID0gbmV3IEV2ZW50RW1pdHRlcigpOyAvL3RzbGludDpkaXNhYmxlLWxpbmU6bm8tb3V0cHV0LXJlbmFtZVxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBNdWx0aVNlbGVjdCBnZXRzIGJsdXJyZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQmx1ciA9IG5ldyBFdmVudEVtaXR0ZXIoKTsgLy90c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLW91dHB1dC1yZW5hbWVcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSBhIHRhZyBpcyBhYm91dCB0byBiZSByZW1vdmVkLlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIHByZXZlbnRhYmxlLiBJZiB5b3UgY2FuY2VsIGl0LCB0aGUgdGFnIHdpbGwgbm90IGJlIHJlbW92ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbW92ZVRhZyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy53aWRnZXRDbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gKF8pID0+IHsgfTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjayA9IChfKSA9PiB7IH07XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyID0gJyc7XG4gICAgICAgIHRoaXMuX29wZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBbXTtcbiAgICAgICAgdGhpcy5fcG9wdXBTZXR0aW5ncyA9IHsgYW5pbWF0ZTogdHJ1ZSB9O1xuICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlbGVjdGVkRGF0YUl0ZW1zID0gW107XG4gICAgICAgIHRoaXMuY3VzdG9tVmFsdWVTdWJqZWN0ID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlU3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdGhpcy5ob3N0RWxlbWVudCA9IGhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMucG9wdXBNb3VzZURvd25IYW5kbGVyID0gdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSB0aGlzLmxvY2FsaXphdGlvbi5ydGwgPyAncnRsJyA6ICdsdHInO1xuICAgICAgICB0aGlzLnN1YnNjcmliZUV2ZW50cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBNdWx0aVNlbGVjdC5cbiAgICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNlYXJjaGJhci5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvblNlYXJjaEJhckZvY3VzKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNGb2N1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm9uRm9jdXMuZW1pdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJsdXJzIHRoZSBNdWx0aVNlbGVjdC5cbiAgICAgKi9cbiAgICBibHVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoYmFyLmJsdXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25TZWFyY2hCYXJCbHVyKCkge1xuICAgICAgICBpZiAodGhpcy5pc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VQb3B1cCgpO1xuICAgICAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxvd0N1c3RvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJGaWx0ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub25CbHVyLmVtaXQoKTtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgd3JhcHBlck1vdXNlZG93bihldmVudCkge1xuICAgICAgICBjb25zdCBpbnB1dEVsZW1lbnQgPSB0aGlzLnNlYXJjaGJhci5pbnB1dC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0ZvY3VzZWQgJiYgdGhpcy5pc09wZW4gJiYgZXZlbnQudGFyZ2V0ID09PSBpbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMudG91Y2hFbmFibGVkIHx8ICh0aGlzLnRvdWNoRW5hYmxlZCAmJiBldmVudC50YXJnZXQudGFnTmFtZSAhPT0gJ1NQQU4nKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoYmFyLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVBvcHVwKCF0aGlzLmlzT3Blbik7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25SZXNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vcGVuKSB7XG4gICAgICAgICAgICBjb25zdCBwb3B1cFdyYXBwZXIgPSB0aGlzLnBvcHVwUmVmLnBvcHVwRWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IHsgbWluLCBtYXggfSA9IHRoaXMud2lkdGg7XG4gICAgICAgICAgICBwb3B1cFdyYXBwZXIuc3R5bGUubWluV2lkdGggPSBtaW47XG4gICAgICAgICAgICBwb3B1cFdyYXBwZXIuc3R5bGUud2lkdGggPSBtYXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGFwcGVuZFRvKCkge1xuICAgICAgICBjb25zdCB7IGFwcGVuZFRvIH0gPSB0aGlzLnBvcHVwU2V0dGluZ3M7XG4gICAgICAgIGlmICghYXBwZW5kVG8gfHwgYXBwZW5kVG8gPT09ICdyb290Jykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwZW5kVG8gPT09ICdjb21wb25lbnQnID8gdGhpcy5jb250YWluZXIgOiBhcHBlbmRUbztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGF0YSBvZiB0aGUgTXVsdGlTZWxlY3QuXG4gICAgICpcbiAgICAgKiA+IFRoZSBkYXRhIGhhcyB0byBiZSBwcm92aWRlZCBpbiBhbiBhcnJheS1saWtlIGxpc3Qgb2YgaXRlbXMuXG4gICAgICovXG4gICAgc2V0IGRhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGFTZXJ2aWNlLmRhdGEgPSBkYXRhIHx8IFtdO1xuICAgICAgICBpZiAodGhpcy52aXJ0dWFsKSB7XG4gICAgICAgICAgICB0aGlzLnZpcnR1YWwuc2tpcCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLnZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIGNvbnN0IHZpcnR1YWwgPSB0aGlzLnZpcnR1YWw7XG4gICAgICAgIGlmICh2aXJ0dWFsKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHZpcnR1YWwuc2tpcCB8fCAwO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gc3RhcnQgKyB2aXJ0dWFsLnBhZ2VTaXplO1xuICAgICAgICAgICAgLy9Vc2UgbGVuZ3RoIGluc3RlYWQgb2YgaXRlbXNDb3VudCBiZWNhdXNlIG9mIGdyb3VwaW5nXG4gICAgICAgICAgICB2aXJ0dWFsLnRvdGFsID0gdGhpcy5kYXRhU2VydmljZS5kYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTZXJ2aWNlLmRhdGEuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNlcnZpY2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIE11bHRpU2VsZWN0LiBJdCBjYW4gYmUgZWl0aGVyIG9mIHRoZSBwcmltaXRpdmUgKHN0cmluZywgbnVtYmVycykgb3Igb2YgdGhlIGNvbXBsZXggKG9iamVjdHMpIHR5cGUuXG4gICAgICogVG8gZGVmaW5lIHRoZSB0eXBlLCB1c2UgdGhlIGB2YWx1ZVByaW1pdGl2ZWAgb3B0aW9uLlxuICAgICAqXG4gICAgICogPiBBbGwgc2VsZWN0ZWQgdmFsdWVzIHdoaWNoIGFyZSBub3QgcHJlc2VudCBpbiB0aGUgc291cmNlIGFyZSBpZ25vcmVkLlxuICAgICAqL1xuICAgIHNldCB2YWx1ZSh2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZXMgPyB2YWx1ZXMgOiBbXTtcbiAgICAgICAgaWYgKCF0aGlzLmRpZmZlciAmJiB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmRpZmZlciA9IHRoaXMuZGlmZmVycy5maW5kKHRoaXMudmFsdWUpLmNyZWF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IHRhYkluZGV4KHRhYkluZGV4KSB7XG4gICAgICAgIHRoaXMudGFiaW5kZXggPSB0YWJJbmRleDtcbiAgICB9XG4gICAgZ2V0IHRhYkluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWJpbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGhpbnQgd2hpY2ggaXMgZGlzcGxheWVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBlbXB0eS5cbiAgICAgKiBXaGVuIHRoZSB2YWx1ZXMgYXJlIHNlbGVjdGVkLCBpdCBkaXNhcHBlYXJzLlxuICAgICAqL1xuICAgIHNldCBwbGFjZWhvbGRlcih0ZXh0KSB7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyID0gdGV4dCB8fCAnJztcbiAgICB9XG4gICAgZ2V0IHBsYWNlaG9sZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZERhdGFJdGVtcy5sZW5ndGggPyAnJyA6IHRoaXMuX3BsYWNlaG9sZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGEgQm9vbGVhbiBmdW5jdGlvbiB0aGF0IGlzIGV4ZWN1dGVkIGZvciBlYWNoIGRhdGEgaXRlbSBpbiB0aGUgY29tcG9uZW50XG4gICAgICogKFtzZWUgZXhhbXBsZXNdKHslIHNsdWcgZGlzYWJsZWRpdGVtc19tdWx0aXNlbGVjdCAlfSkpLiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGl0ZW0gd2lsbCBiZSBkaXNhYmxlZC5cbiAgICAgKi9cbiAgICBzZXQgaXRlbURpc2FibGVkKGZuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaXRlbURpc2FibGVkIG11c3QgYmUgYSBmdW5jdGlvbiwgYnV0IHJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkoZm4pfS5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc2FibGVkSXRlbXNTZXJ2aWNlLml0ZW1EaXNhYmxlZCA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRoZSBbdmlydHVhbGl6YXRpb25dKHslIHNsdWcgdmlydHVhbGl6YXRpb25fbXVsdGlzZWxlY3QgJX0pIGZ1bmN0aW9uYWxpdHkuXG4gICAgICovXG4gICAgc2V0IHZpcnR1YWwoc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5fdmlydHVhbFNldHRpbmdzID0gbm9ybWFsaXplVmlydHVhbGl6YXRpb25TZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgfVxuICAgIGdldCB2aXJ0dWFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlydHVhbFNldHRpbmdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIHRoZSBwb3B1cCBvZiB0aGUgTXVsdGlTZWxlY3QuXG4gICAgICpcbiAgICAgKiBUaGUgYXZhaWxhYmxlIG9wdGlvbnMgYXJlOlxuICAgICAqIC0gYGFuaW1hdGU6IEJvb2xlYW5gJm1kYXNoO0NvbnRyb2xzIHRoZSBwb3B1cCBhbmltYXRpb24uIEJ5IGRlZmF1bHQsIHRoZSBvcGVuIGFuZCBjbG9zZSBhbmltYXRpb25zIGFyZSBlbmFibGVkLlxuICAgICAqIC0gYHdpZHRoOiBOdW1iZXIgfCBTdHJpbmdgJm1kYXNoO1NldHMgdGhlIHdpZHRoIG9mIHRoZSBwb3B1cCBjb250YWluZXIuIEJ5IGRlZmF1bHQsIHRoZSB3aWR0aCBvZiB0aGUgaG9zdCBlbGVtZW50IGlzIHVzZWQuIElmIHNldCB0byBgYXV0b2AsIHRoZSBjb21wb25lbnQgYXV0b21hdGljYWxseSBhZGp1c3RzIHRoZSB3aWR0aCBvZiB0aGUgcG9wdXAgYW5kIG5vIGl0ZW0gbGFiZWxzIGFyZSB3cmFwcGVkLiBUaGUgYGF1dG9gIG1vZGUgaXMgbm90IHN1cHBvcnRlZCB3aGVuIHZpcnR1YWwgc2Nyb2xsaW5nIGlzIGVuYWJsZWQuXG4gICAgICogLSBgaGVpZ2h0OiBOdW1iZXJgJm1kYXNoO1NldHMgdGhlIGhlaWdodCBvZiB0aGUgcG9wdXAgY29udGFpbmVyLlxuICAgICAqIC0gYHBvcHVwQ2xhc3M6IFN0cmluZ2AmbWRhc2g7U3BlY2lmaWVzIGEgbGlzdCBvZiBDU1MgY2xhc3NlcyB0aGF0IGFyZSB1c2VkIHRvIHN0eWxlIHRoZSBwb3B1cC5cbiAgICAgKiAtIGBhcHBlbmRUbzogXCJyb290XCIgfCBcImNvbXBvbmVudFwiIHwgVmlld0NvbnRhaW5lclJlZmAmbWRhc2g7U3BlY2lmaWVzIHRoZSBjb21wb25lbnQgdG8gd2hpY2ggdGhlIHBvcHVwIHdpbGwgYmUgYXBwZW5kZWQuXG4gICAgICovXG4gICAgc2V0IHBvcHVwU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5fcG9wdXBTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oeyBhbmltYXRlOiB0cnVlIH0sIHNldHRpbmdzKTtcbiAgICB9XG4gICAgZ2V0IHBvcHVwU2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3B1cFNldHRpbmdzO1xuICAgIH1cbiAgICBnZXQgZGlyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb247XG4gICAgfVxuICAgIGdldCBmb2N1c2VkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRm9jdXNlZDtcbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkO1xuICAgIH1cbiAgICBnZXQgbGlzdENvbnRhaW5lckNsYXNzZXMoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lckNsYXNzZXMgPSBbJ2stbGlzdC1jb250YWluZXInLCAnay1yZXNldCddO1xuICAgICAgICBpZiAodGhpcy5wb3B1cFNldHRpbmdzLnBvcHVwQ2xhc3MpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lckNsYXNzZXMucHVzaCh0aGlzLnBvcHVwU2V0dGluZ3MucG9wdXBDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lckNsYXNzZXM7XG4gICAgfVxuICAgIGdldCB3aWR0aCgpIHtcbiAgICAgICAgbGV0IHdyYXBwZXJPZmZzZXRXaWR0aCA9IDA7XG4gICAgICAgIGlmIChpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHdyYXBwZXJPZmZzZXRXaWR0aCA9IHRoaXMud3JhcHBlci5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5wb3B1cFNldHRpbmdzLndpZHRoIHx8IHdyYXBwZXJPZmZzZXRXaWR0aDtcbiAgICAgICAgY29uc3QgbWluV2lkdGggPSBpc05hTih3cmFwcGVyT2Zmc2V0V2lkdGgpID8gd3JhcHBlck9mZnNldFdpZHRoIDogYCR7d3JhcHBlck9mZnNldFdpZHRofXB4YDtcbiAgICAgICAgY29uc3QgbWF4V2lkdGggPSBpc05hTih3aWR0aCkgPyB3aWR0aCA6IGAke3dpZHRofXB4YDtcbiAgICAgICAgcmV0dXJuIHsgbWluOiBtaW5XaWR0aCwgbWF4OiBtYXhXaWR0aCB9O1xuICAgIH1cbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICBjb25zdCBwb3B1cEhlaWdodCA9IHRoaXMucG9wdXBTZXR0aW5ncy5oZWlnaHQ7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQocG9wdXBIZWlnaHQpID8gYCR7cG9wdXBIZWlnaHR9cHhgIDogJ2F1dG8nO1xuICAgIH1cbiAgICBnZXQgYWN0aXZlRGVzY2VuZGFudCgpIHtcbiAgICAgICAgY29uc3QgZm9jdXNlZFRhZ0luZGV4ID0gdGhpcy5mb2N1c2VkVGFnSW5kZXg7XG4gICAgICAgIGNvbnN0IGZvY3VzZWRMaXN0SW5kZXggPSB0aGlzLnNlbGVjdGlvblNlcnZpY2UuZm9jdXNlZDtcbiAgICAgICAgbGV0IHByZWZpeDtcbiAgICAgICAgbGV0IGl0ZW07XG4gICAgICAgIGlmIChpc1ByZXNlbnQoZm9jdXNlZFRhZ0luZGV4KSAmJiAhdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLnRhZ3NbZm9jdXNlZFRhZ0luZGV4XTtcbiAgICAgICAgICAgIHByZWZpeCA9IHRoaXMudGFnUHJlZml4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudChmb2N1c2VkTGlzdEluZGV4KSAmJiBmb2N1c2VkTGlzdEluZGV4ICE9PSAtMSAmJiB0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgaXRlbSA9IHRoaXMuZGF0YVNlcnZpY2UuaXRlbUF0KGZvY3VzZWRMaXN0SW5kZXgpO1xuICAgICAgICAgICAgcHJlZml4ID0gdGhpcy5vcHRpb25QcmVmaXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJlZml4ICsgXCItXCIgKyB0aGlzLnByb3AodGhpcy52YWx1ZUZpZWxkLCB0aGlzLnZhbHVlUHJpbWl0aXZlKShpdGVtKTtcbiAgICB9XG4gICAgZ2V0IG5vRGF0YUxhYmVsKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhU2VydmljZS5pdGVtc0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub0RhdGFUZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjbGVhclRpdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb24uZ2V0KCdjbGVhclRpdGxlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB2ZXJpZnlTZXR0aW5ncygpIHtcbiAgICAgICAgY29uc3QgdmFsdWVPclRleHQgPSAhaXNQcmVzZW50KHRoaXMudmFsdWVGaWVsZCkgIT09ICFpc1ByZXNlbnQodGhpcy50ZXh0RmllbGQpO1xuICAgICAgICBpZiAoIWlzRGV2TW9kZSgpIHx8IHRoaXMudmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0FycmF5KHRoaXMudmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoTXVsdGlzZWxlY3RNZXNzYWdlcy5hcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmFsdWVQcmltaXRpdmUgPT09IHRydWUgJiYgaXNPYmplY3RBcnJheSh0aGlzLnZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKE11bHRpc2VsZWN0TWVzc2FnZXMucHJpbWl0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52YWx1ZVByaW1pdGl2ZSA9PT0gZmFsc2UgJiYgIWlzT2JqZWN0QXJyYXkodGhpcy52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihNdWx0aXNlbGVjdE1lc3NhZ2VzLm9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlT3JUZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoTXVsdGlzZWxlY3RNZXNzYWdlcy50ZXh0QW5kVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgaXNDdXN0b21JdGVtID0gKGlzUHJlc2VudChldmVudC5hZGRlZCkgfHwgaXNQcmVzZW50KGV2ZW50LnJlbW92ZWQpKSAmJiAoZXZlbnQuYWRkZWQgPT09IC0xIHx8IGV2ZW50LnJlbW92ZWQgPT09IC0xKTtcbiAgICAgICAgaWYgKGlzQ3VzdG9tSXRlbSkge1xuICAgICAgICAgICAgdGhpcy5hZGRDdXN0b21WYWx1ZSh0aGlzLnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBUaGUgY2hhbmdlIGlzIGVtaXRlZCBhc3luY2hyb25vc2x5LlxuICAgICAgICB9XG4gICAgICAgIC8vIEV4aXN0aW5nIGl0ZW1zLlxuICAgICAgICBpZiAoaXNQcmVzZW50KGV2ZW50LmFkZGVkKSkge1xuICAgICAgICAgICAgY29uc3QgZGF0YUl0ZW0gPSB0aGlzLmRhdGFTZXJ2aWNlLml0ZW1BdChldmVudC5hZGRlZCk7XG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtID0gKHRoaXMudmFsdWVQcmltaXRpdmUgJiYgaXNQcmVzZW50KGRhdGFJdGVtKSAmJiBpc1ByZXNlbnQoZGF0YUl0ZW1bdGhpcy52YWx1ZUZpZWxkXSkpID8gZGF0YUl0ZW1bdGhpcy52YWx1ZUZpZWxkXSA6IGRhdGFJdGVtO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFsuLi50aGlzLnZhbHVlLCBuZXdJdGVtXTtcbiAgICAgICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ByZXNlbnQoZXZlbnQucmVtb3ZlZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFJdGVtID0gdGhpcy5kYXRhU2VydmljZS5pdGVtQXQoZXZlbnQucmVtb3ZlZCk7XG4gICAgICAgICAgICBjb25zdCBwcm9wID0gdGhpcy5wcm9wKHRoaXMudmFsdWVGaWVsZCwgdGhpcy52YWx1ZVByaW1pdGl2ZSk7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXIkJDEgPSAoaXRlbSkgPT4gcHJvcChpdGVtKSAhPT0gcHJvcChkYXRhSXRlbSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZS5maWx0ZXIoZmlsdGVyJCQxKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWREYXRhSXRlbXMgPSB0aGlzLnNlbGVjdGVkRGF0YUl0ZW1zLmZpbHRlcihmaWx0ZXIkJDEpO1xuICAgICAgICAgICAgdGhpcy50YWdzID0gdGhpcy50YWdNYXBwZXIodGhpcy5zZWxlY3RlZERhdGFJdGVtcy5zbGljZSgpKTtcbiAgICAgICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXRWYWx1ZUNoYW5nZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0U3RhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgb2JqZWN0QXJyYXkgPSBpc09iamVjdEFycmF5KHZhbHVlKTtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGFTZXJ2aWNlLmRhdGE7XG4gICAgICAgIGlmICh0aGlzLmRhdGFTZXJ2aWNlLmdyb3VwZWQpIHtcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhLmZpbHRlcihpdGVtID0+ICFpdGVtLmhlYWRlcikubWFwKGl0ZW0gPT4gaXRlbS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gc2VsZWN0ZWRJbmRpY2VzKHRoaXMudmFsdWUsIGRhdGEsIHRoaXMudmFsdWVGaWVsZCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5yZXNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgICBpZiAodGhpcy5pc09wZW4gJiYgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmZvY3VzZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmZvY3VzZWQgPSB0aGlzLmRhdGFTZXJ2aWNlLml0ZW1zQ291bnQgPyB0aGlzLmZpcnN0Rm9jdXNhYmxlSW5kZXgoMCkgOiB0aGlzLmFsbG93Q3VzdG9tID8gLTEgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnRleHQpIHtcbiAgICAgICAgICAgIGlmICghKGlzUHJlc2VudCh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWREYXRhSXRlbXMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlUHJpbWl0aXZlICYmICF0aGlzLnZhbHVlRmllbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkRGF0YUl0ZW1zID0gdmFsdWUuc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3RBcnJheSB8fCB0aGlzLnZhbHVlUHJpbWl0aXZlICYmIHRoaXMudmFsdWVGaWVsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWREYXRhSXRlbXMgPSByZXNvbHZlQWxsVmFsdWVzKHZhbHVlLCBkYXRhLCB0aGlzLnZhbHVlRmllbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWREYXRhSXRlbXMubGVuZ3RoIDwgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcCA9IHRoaXMucHJvcCh0aGlzLnZhbHVlRmllbGQsIHRoaXMudmFsdWVQcmltaXRpdmUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFJdGVtcyA9IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoY3VycmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFJdGVtID0gdGhpcy5zZWxlY3RlZERhdGFJdGVtcy5maW5kKGl0ZW0gPT4gcHJvcChpdGVtKSA9PT0gcHJvcChjdXJyZW50KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQoZGF0YUl0ZW0pID8gZGF0YUl0ZW0gOiB0aGlzLnJlc29sdmVEYXRhSXRlbUZyb21UYWdzKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZGF0YUl0ZW0gPT4gaXNQcmVzZW50KGRhdGFJdGVtKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERhdGFJdGVtcyA9IGRhdGFJdGVtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ01hcHBlcih0aGlzLnNlbGVjdGVkRGF0YUl0ZW1zLnNsaWNlKDApKTtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVGaWx0ZXIodGV4dCkge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICBpZiAodGV4dCAmJiAhdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMub3BlblBvcHVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJDaGFuZ2UuZW1pdCh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoVGV4dEFuZEZvY3VzKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VhcmNoYmFyLnNldElucHV0U2l6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcGFnZUNoYW5nZShldmVudCkge1xuICAgICAgICBjb25zdCB2aXJ0dWFsID0gdGhpcy52aXJ0dWFsO1xuICAgICAgICB2aXJ0dWFsLnNraXAgPSBldmVudC5za2lwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY2xlYXJGaWx0ZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbHRlcmFibGUgJiYgdGhpcy50ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlckNoYW5nZS5lbWl0KFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgIC8qIENsZWFyaW5nIHRoZSB2YWx1ZSBmcm9tIHRoZSBpbnB1dCBhcyB0aGUgc2V0SW5wdXRTaXplIGNhbGN1bGF0aW9uIHdpbGwgYmUgaW5jb3JyZWN0IG90aGVyd2lzZS5cbiAgICAgICAgIENhbGxpbmcgY2RyLmRldGVjdENoYW5nZXMgdG8gY2xlYXIgdGhlIGlucHV0IHZhbHVlIGFzIGEgcmVzdWx0IG9mIHByb3BlcnR5IGJpbmRpbmdcbiAgICAgICAgIGNhdXNlcyBKQVdTIHRvIHJlYWQgb3V0ZGF0ZWQgdGFnIHZhbHVlcyBpbiBJRSB1cG9uIHRhZyBzZWxlY3Rpb24gZm9yIHNvbWUgcmVhc29uLiAqL1xuICAgICAgICB0aGlzLnNlYXJjaGJhci5pbnB1dC5uYXRpdmVFbGVtZW50LnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5zZWFyY2hiYXIuc2V0SW5wdXRTaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVOYXZpZ2F0ZShldmVudCkge1xuICAgICAgICBjb25zdCBuYXZpZ2F0ZUlucHV0ID0gdGhpcy50ZXh0ICYmIGV2ZW50LmtleUNvZGUgIT09IEtleXMuZG93biAmJiBldmVudC5rZXlDb2RlICE9PSBLZXlzLnVwO1xuICAgICAgICBjb25zdCBzZWxlY3RWYWx1ZSA9IHRoaXMudGV4dCAmJiBldmVudC5rZXlDb2RlID09PSBLZXlzLmVudGVyIHx8IGV2ZW50LmtleUNvZGUgPT09IEtleXMuZXNjO1xuICAgICAgICBjb25zdCBkZWxldGVUYWcgPSAhdGhpcy50ZXh0ICYmIGV2ZW50LmtleUNvZGUgPT09IEtleXMuYmFja3NwYWNlICYmIHRoaXMudGFncy5sZW5ndGggPiAwO1xuICAgICAgICBpZiAoZGVsZXRlVGFnKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUJhY2tzcGFjZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IG5hdmlnYXRlSW5wdXQgJiYgIXNlbGVjdFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZlbnREYXRhID0gZXZlbnQ7XG4gICAgICAgIGNvbnN0IGZvY3VzZWQgPSBpc05hTih0aGlzLnNlbGVjdGlvblNlcnZpY2UuZm9jdXNlZCkgPyAtMSA6IHRoaXMuc2VsZWN0aW9uU2VydmljZS5mb2N1c2VkO1xuICAgICAgICBjb25zdCBhY3Rpb24gPSB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnByb2Nlc3Moe1xuICAgICAgICAgICAgY3VycmVudDogZm9jdXNlZCxcbiAgICAgICAgICAgIG1heDogdGhpcy5kYXRhU2VydmljZS5pdGVtc0NvdW50IC0gMSxcbiAgICAgICAgICAgIG1pbjogdGhpcy5hbGxvd0N1c3RvbSAmJiB0aGlzLnRleHQgPyAtMSA6IDAsXG4gICAgICAgICAgICBvcGVuOiB0aGlzLmlzT3BlbixcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50RGF0YVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFjdGlvbiAhPT0gTmF2aWdhdGlvbkFjdGlvbi5VbmRlZmluZWQgJiZcbiAgICAgICAgICAgICgoYWN0aW9uID09PSBOYXZpZ2F0aW9uQWN0aW9uLkVudGVyICYmIHRoaXMuaXNPcGVuKSB8fCBhY3Rpb24gIT09IE5hdmlnYXRpb25BY3Rpb24uRW50ZXIpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVSZW1vdmVUYWcodGFnRGF0YSkge1xuICAgICAgICBjb25zdCBldmVudEFyZ3MgPSBuZXcgUmVtb3ZlVGFnRXZlbnQodGFnRGF0YSk7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZG9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlVGFnLmVtaXQoZXZlbnRBcmdzKTtcbiAgICAgICAgaWYgKGV2ZW50QXJncy5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWdEYXRhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlR3JvdXBUYWcodGFnRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVNpbmdsZVRhZyh0YWdEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjbGVhckFsbChldmVudCkge1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy5jbGVhckZpbHRlcigpO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuZW1pdFZhbHVlQ2hhbmdlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBhZGRDdXN0b21WYWx1ZSh0ZXh0KSB7XG4gICAgICAgIHRoaXMuY3VzdG9tVmFsdWVTdWJqZWN0Lm5leHQodGV4dCk7XG4gICAgfVxuICAgIG5nQWZ0ZXJDb250ZW50Q2hlY2tlZCgpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlTZXR0aW5ncygpO1xuICAgIH1cbiAgICBuZ0RvQ2hlY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmRpZmZlcikge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVDaGFuZ2VzID0gdGhpcy5kaWZmZXIuZGlmZih0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZUNoYW5nZXMgJiYgIXRoaXMudmFsdWVDaGFuZ2VEZXRlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWREYXRhSXRlbXMgPSB0aGlzLmdldFNlbGVjdGVkRGF0YUl0ZW1zKHZhbHVlQ2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy50YWdzID0gdGhpcy50YWdNYXBwZXIodGhpcy5zZWxlY3RlZERhdGFJdGVtcy5zbGljZSgwKSk7XG4gICAgICAgICAgICAgICAgaWYgKCEodGhpcy50YWdzICYmIHRoaXMuZGF0YVNlcnZpY2UuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpc1ZhbHVlQ3VzdG9tID0gKHZhbHVlKSA9PiB0aGlzLmRhdGFTZXJ2aWNlLmluZGV4T2YodmFsdWUpID09PSAtMTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1ZhbHVlU2VsZWN0ZWQgPSAodmFsdWUpID0+IHRoaXMuc2VsZWN0aW9uU2VydmljZS5pc1NlbGVjdGVkKHRoaXMuZGF0YVNlcnZpY2UuaW5kZXhPZih2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc2VsZWN0aW9uUmVxdWlyZWQgPSB0aGlzLnNlbGVjdGVkRGF0YUl0ZW1zLnNvbWUodmFsdWUgPT4gIShpc1ZhbHVlQ3VzdG9tKHZhbHVlKSB8fCBpc1ZhbHVlU2VsZWN0ZWQodmFsdWUpKSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc2VsZWN0aW9uUmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZURldGVjdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLmhvc3RFbGVtZW50LCBcInRhYmluZGV4XCIpO1xuICAgICAgICB0aGlzLmNyZWF0ZUN1c3RvbVZhbHVlU3RyZWFtKCk7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uID0gdGhpcy5sb2NhbGl6YXRpb25cbiAgICAgICAgICAgIC5jaGFuZ2VzLnN1YnNjcmliZSgoeyBydGwgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBydGwgPyAncnRsJyA6ICdsdHInO1xuICAgICAgICAgICAgdGhpcy5zZXRNZXNzYWdlcygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRNZXNzYWdlcygpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IHZpcnR1YWwgPSB0aGlzLnZpcnR1YWw7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJbml0aWFsRGF0YSA9IHZpcnR1YWwgJiYgY2hhbmdlcy5kYXRhICYmIGNoYW5nZXMuZGF0YS5pc0ZpcnN0Q2hhbmdlKCk7XG4gICAgICAgIGlmIChyZXF1ZXN0SW5pdGlhbERhdGEpIHtcbiAgICAgICAgICAgIHRoaXMucGFnZUNoYW5nZSh7IHNraXA6IDAsIHRha2U6IHZpcnR1YWwucGFnZVNpemUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmFsdWVQcmltaXRpdmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZVByaW1pdGl2ZSA9ICF0aGlzLnZhbHVlRmllbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2hhbmdlZChcInZhbHVlTm9ybWFsaXplclwiLCBjaGFuZ2VzKSkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVDdXN0b21WYWx1ZVN0cmVhbSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFNUQVRFX1BST1BTID0gLyhkYXRhfHRleHRGaWVsZHx2YWx1ZUZpZWxkfHZhbHVlUHJpbWl0aXZlfHZhbHVlKS9nO1xuICAgICAgICBpZiAoY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlRGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChTVEFURV9QUk9QUy50ZXN0KE9iamVjdC5rZXlzKGNoYW5nZXMpLmpvaW4oKSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUodGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLnNlYXJjaGJhci5zZXRJbnB1dFNpemUoKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZShmYWxzZSk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVFdmVudHMoKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubWVzc2FnZXNUaW1lb3V0KTtcbiAgICAgICAgaWYgKHRoaXMubG9jYWxpemF0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsaXphdGlvbkNoYW5nZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHBvcHVwXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBvcGVuc3RhdGVfbXVsdGlzZWxlY3QgJX0jdG9jLXNldHRpbmctdGhlLWluaXRpYWxseS1vcGVuZWQtY29tcG9uZW50KSkuXG4gICAgICogSWYgeW91IHVzZSB0aGUgYHRvZ2dsZWAgbWV0aG9kIHRvIG9wZW4gb3IgY2xvc2UgdGhlIHBvcHVwLCB0aGUgcmVzcGVjdGl2ZSBgb3BlbmAgYW5kIGBjbG9zZWAgZXZlbnRzIHdpbGwgbm90IGJlIGZpcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wZW4gLSBUaGUgc3RhdGUgb2YgdGhlIHBvcHVwLlxuICAgICAqL1xuICAgIHRvZ2dsZShvcGVuKSB7XG4gICAgICAgIC8vIFRoZSBQcm9taXNlIGlzIHJlcXVpcmVkIGZvciBvcGVuaW5nIHRoZSBwb3B1cCBvbiBsb2FkLlxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSBcIkV4cHJlc3Npb24gaGFzIGNoYW5nZWQuLi5cIiB0eXBlIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgICAgICBQcm9taXNlLnJlc29sdmUobnVsbCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGUoKG9wZW4gPT09IHVuZGVmaW5lZCkgPyAhdGhpcy5fb3BlbiA6IG9wZW4pO1xuICAgICAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG9wZW4gc3RhdGUgb2YgdGhlIHBvcHVwLlxuICAgICAqL1xuICAgIGdldCBpc09wZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcGVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIHZhbHVlIG9mIHRoZSBNdWx0aVNlbGVjdC5cbiAgICAgKiBJZiB5b3UgdXNlIHRoZSBgcmVzZXRgIG1ldGhvZCB0byBjbGVhciB0aGUgdmFsdWUgb2YgdGhlIGNvbXBvbmVudCxcbiAgICAgKiB0aGUgbW9kZWwgd2lsbCBub3QgdXBkYXRlIGF1dG9tYXRpY2FsbHkgYW5kIHRoZSBgc2VsZWN0aW9uQ2hhbmdlYCBhbmQgYHZhbHVlQ2hhbmdlYCBldmVudHMgd2lsbCBub3QgYmUgZmlyZWQuXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgIHRoaXMudmFsdWUgPSBbXTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZERhdGFJdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLnNldFN0YXRlKFtdKTtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICAgIC8vIE5HIE1PREVMIEJJTkRJTkdTXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlIHx8IFtdO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHRoaXMudmFsdWUpO1xuICAgICAgICB0aGlzLnZlcmlmeVNldHRpbmdzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm4pIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjayA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25UYWdNYXBwZXJDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMudGFncyA9IHRoaXMudGFnTWFwcGVyKHRoaXMuc2VsZWN0ZWREYXRhSXRlbXMuc2xpY2UoMCkpO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgcHJvcChmaWVsZCwgdXNlUHJpbWl0aXZlKSB7XG4gICAgICAgIHJldHVybiAoZGF0YUl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGF0YUl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVzZVByaW1pdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmllbGQgJiYgaXNPYmplY3QoZGF0YUl0ZW0pID8gZGF0YUl0ZW1bZmllbGRdIDogZGF0YUl0ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YUl0ZW1bZmllbGRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBzdWJzY3JpYmVFdmVudHMoKSB7XG4gICAgICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNPcGVuID0gKCkgPT4gdGhpcy5pc09wZW47XG4gICAgICAgIGNvbnN0IGlzQ2xvc2VkID0gKCkgPT4gIXRoaXMuaXNPcGVuO1xuICAgICAgICBjb25zdCBpc1RhZ0ZvY3VzZWQgPSAoKSA9PiAhdGhpcy5pc09wZW4gJiYgdGhpcy5mb2N1c2VkVGFnSW5kZXggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgW1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLm9uQ2hhbmdlLnN1YnNjcmliZSh0aGlzLmhhbmRsZUl0ZW1DaGFuZ2UuYmluZCh0aGlzKSksXG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmVzYy5zdWJzY3JpYmUodGhpcy5jbG9zZVBvcHVwLmJpbmQodGhpcykpLFxuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5lbnRlci5waXBlKGZpbHRlcihpc09wZW4pKS5zdWJzY3JpYmUodGhpcy5oYW5kbGVFbnRlci5iaW5kKHRoaXMpKSxcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2Uub3Blbi5zdWJzY3JpYmUodGhpcy5vcGVuUG9wdXAuYmluZCh0aGlzKSksXG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmNsb3NlLnN1YnNjcmliZSh0aGlzLmhhbmRsZUNsb3NlLmJpbmQodGhpcykpLFxuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS51cC5waXBlKGZpbHRlcihpc09wZW4pKS5zdWJzY3JpYmUoKGV2ZW50KSA9PiB0aGlzLmhhbmRsZVVwKGV2ZW50LmluZGV4KSksXG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmhvbWUucGlwZShmaWx0ZXIoKCkgPT4gaXNDbG9zZWQpKS5zdWJzY3JpYmUodGhpcy5oYW5kbGVIb21lLmJpbmQodGhpcykpLFxuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5lbmQucGlwZShmaWx0ZXIoKCkgPT4gaXNDbG9zZWQpKS5zdWJzY3JpYmUodGhpcy5oYW5kbGVFbmQuYmluZCh0aGlzKSksXG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmJhY2tzcGFjZS5waXBlKGZpbHRlcihpc1RhZ0ZvY3VzZWQpKS5zdWJzY3JpYmUodGhpcy5oYW5kbGVCYWNrc3BhY2UuYmluZCh0aGlzKSksXG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmRlbGV0ZS5waXBlKGZpbHRlcihpc1RhZ0ZvY3VzZWQpKS5zdWJzY3JpYmUodGhpcy5oYW5kbGVEZWxldGUuYmluZCh0aGlzKSksXG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmxlZnQuc3Vic2NyaWJlKHRoaXMuaGFuZGxlTGVmdEtleS5iaW5kKHRoaXMpKSxcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UucmlnaHQuc3Vic2NyaWJlKHRoaXMuaGFuZGxlUmlnaHRLZXkuYmluZCh0aGlzKSksXG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmRvd24uc3Vic2NyaWJlKChldmVudCkgPT4gdGhpcy5oYW5kbGVEb3duS2V5KGV2ZW50LmluZGV4KSlcbiAgICAgICAgXS5mb3JFYWNoKHMgPT4gdGhpcy5vYnNlcnZhYmxlU3Vic2NyaXB0aW9ucy5hZGQocykpO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZUV2ZW50cygpIHtcbiAgICAgICAgaWYgKCFpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmFibGVTdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGlmICh0aGlzLmN1c3RvbVZhbHVlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmN1c3RvbVZhbHVlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlR3JvdXBUYWcoZGF0YUl0ZW1zKSB7XG4gICAgICAgIGNvbnN0IHByb3AgPSB0aGlzLnByb3AodGhpcy52YWx1ZUZpZWxkLCB0aGlzLnZhbHVlUHJpbWl0aXZlKTtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGFTZXJ2aWNlLmRhdGE7XG4gICAgICAgIGlmICh0aGlzLmRhdGFTZXJ2aWNlLmdyb3VwZWQpIHtcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhLmZpbHRlcihpdGVtID0+ICFpdGVtLmhlYWRlcikubWFwKGl0ZW0gPT4gaXRlbS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YUl0ZW1WYWx1ZXMgPSBuZXcgU2V0KGRhdGFJdGVtcy5tYXAoaXRlbSA9PiBwcm9wKGl0ZW0pKSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlLmZpbHRlcih2YWx1ZSA9PiAhZGF0YUl0ZW1WYWx1ZXMuaGFzKHByb3AodmFsdWUpKSk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWREYXRhSXRlbXMgPSB0aGlzLnNlbGVjdGVkRGF0YUl0ZW1zLmZpbHRlcih2YWx1ZSA9PiAhZGF0YUl0ZW1WYWx1ZXMuaGFzKHByb3AodmFsdWUpKSk7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHNlbGVjdGVkSW5kaWNlcyh0aGlzLnZhbHVlLCBkYXRhLCB0aGlzLnZhbHVlRmllbGQpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UucmVzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICAgICAgdGhpcy50YWdzID0gdGhpcy50YWdNYXBwZXIodGhpcy5zZWxlY3RlZERhdGFJdGVtcy5zbGljZSgwKSk7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB0aGlzLmVtaXRWYWx1ZUNoYW5nZSgpO1xuICAgIH1cbiAgICByZW1vdmVTaW5nbGVUYWcoZGF0YUl0ZW0pIHtcbiAgICAgICAgY29uc3QgcHJvcCA9IHRoaXMucHJvcCh0aGlzLnZhbHVlRmllbGQsIHRoaXMudmFsdWVQcmltaXRpdmUpO1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YVNlcnZpY2UuZGF0YTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVNlcnZpY2UuZ3JvdXBlZCkge1xuICAgICAgICAgICAgZGF0YSA9IGRhdGEuZmlsdGVyKGl0ZW0gPT4gIWl0ZW0uaGVhZGVyKS5tYXAoaXRlbSA9PiBpdGVtLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IHNlbGVjdGVkSW5kaWNlcyhbZGF0YUl0ZW1dLCBkYXRhLCB0aGlzLnZhbHVlRmllbGQpWzBdO1xuICAgICAgICBpZiAoaXNOdW1iZXIoaW5kZXgpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UudW5zZWxlY3QoaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy50b2dnbGVQb3B1cChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIHRoZSBkZWxldGVkIGl0ZW0gaXMgbm90IHByZXNlbnQgaW4gdGhlIHNvdXJjZVxuICAgICAgICAgICAgY29uc3QgZmlsdGVyJCQxID0gaXRlbSA9PiBwcm9wKGl0ZW0pICE9PSBwcm9wKGRhdGFJdGVtKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlLmZpbHRlcihmaWx0ZXIkJDEpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERhdGFJdGVtcyA9IHRoaXMuc2VsZWN0ZWREYXRhSXRlbXMuZmlsdGVyKGZpbHRlciQkMSk7XG4gICAgICAgICAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ01hcHBlcih0aGlzLnNlbGVjdGVkRGF0YUl0ZW1zLnNsaWNlKDApKTtcbiAgICAgICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgdGhpcy5lbWl0VmFsdWVDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVDdXN0b21WYWx1ZVN0cmVhbSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tVmFsdWVTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tVmFsdWVTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1c3RvbVZhbHVlU3Vic2NyaXB0aW9uID0gdGhpcy5jdXN0b21WYWx1ZVN1YmplY3QucGlwZSh0YXAoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9KSwgdGhpcy52YWx1ZU5vcm1hbGl6ZXIsIGNhdGNoRXJyb3IoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNsZWFyRmlsdGVyKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZVBvcHVwKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hiYXIuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQ3VzdG9tVmFsdWVTdHJlYW0oKTtcbiAgICAgICAgICAgIHJldHVybiBvZihudWxsKTtcbiAgICAgICAgfSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChub3JtYWxpemVkVmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jbGVhckZpbHRlcigpO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChub3JtYWxpemVkVmFsdWUpKSB7IC8vaWYgdmFsdWVOb3JtYWxpemVyIHJldHVybnMgYG51bGxgIG9yIGB1bmRlZmluZWRgIGN1c3RvbSB2YWx1ZSBpcyBkaXNjYXJkZWRcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMudmFsdWVQcmltaXRpdmUgPyBnZXR0ZXIobm9ybWFsaXplZFZhbHVlLCB0aGlzLnZhbHVlRmllbGQpIDogbm9ybWFsaXplZFZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1JbmRleCA9IHRoaXMuZGF0YVNlcnZpY2UuaW5kZXhPZihuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VzdG9tSXRlbSA9IGl0ZW1JbmRleCA9PT0gLTE7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUuaW5kZXhPZihuZXdWYWx1ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VzdG9tSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmFkZChpdGVtSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFsuLi50aGlzLnZhbHVlLCBuZXdWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERhdGFJdGVtcyA9IFsuLi50aGlzLnNlbGVjdGVkRGF0YUl0ZW1zLCBub3JtYWxpemVkVmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXN0b21JdGVtICYmIHRoaXMuc2VsZWN0aW9uU2VydmljZS5pc1NlbGVjdGVkKGl0ZW1JbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS51bnNlbGVjdChpdGVtSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5zcGxpY2UodGhpcy52YWx1ZS5pbmRleE9mKG5ld1ZhbHVlKSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkRGF0YUl0ZW1zID0gdGhpcy5zZWxlY3RlZERhdGFJdGVtcy5maWx0ZXIoaXRlbSA9PiBnZXR0ZXIoaXRlbSwgdGhpcy52YWx1ZUZpZWxkKSAhPT0gbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudGFncyA9IHRoaXMudGFnTWFwcGVyKHRoaXMuc2VsZWN0ZWREYXRhSXRlbXMuc2xpY2UoMCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdFZhbHVlQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZVBvcHVwKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hiYXIuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZUl0ZW1DaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2UoZXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5hdXRvQ2xvc2UpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlUG9wdXAoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ByZXNlbnQoZXZlbnQuYWRkZWQpICYmIGV2ZW50LmFkZGVkICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5jbGVhckZpbHRlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUVudGVyKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHNlcnZpY2UgPSB0aGlzLnNlbGVjdGlvblNlcnZpY2U7XG4gICAgICAgIGNvbnN0IGZvY3VzZWRJbmRleCA9IHRoaXMuc2VsZWN0aW9uU2VydmljZS5mb2N1c2VkO1xuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9jdXNlZEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dDdXN0b20gJiYgdGhpcy50ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXN0b21WYWx1ZSh0aGlzLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuOyAvLyBDbGVhciBmaWx0ZXIgJiBjbG9zZSBhcmUgZG9uZSBhdCBjdXN0b21WYWx1ZVN1YnNjcmlwdGlvbiBkdWUgdG8gcmFjZSBjb25kaXRpb25zLlxuICAgICAgICB9XG4gICAgICAgIGlmIChzZXJ2aWNlLmlzU2VsZWN0ZWQoZm9jdXNlZEluZGV4KSkge1xuICAgICAgICAgICAgc2VydmljZS51bnNlbGVjdChmb2N1c2VkSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VydmljZS5hZGQoZm9jdXNlZEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyRmlsdGVyKCk7XG4gICAgICAgIGlmICh0aGlzLmF1dG9DbG9zZSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVQb3B1cChmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VQb3B1cCgpO1xuICAgICAgICB0aGlzLnNlYXJjaGJhci5mb2N1cygpO1xuICAgIH1cbiAgICBoYW5kbGVFbmQoKSB7XG4gICAgICAgIHRoaXMuZm9jdXNlZFRhZ0luZGV4ID0gdGhpcy50YWdzLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIGhhbmRsZUhvbWUoKSB7XG4gICAgICAgIHRoaXMuZm9jdXNlZFRhZ0luZGV4ID0gMDtcbiAgICB9XG4gICAgaGFuZGxlVXAoaW5kZXgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmZvY3VzZWQgPSBpbmRleDtcbiAgICB9XG4gICAgaGFuZGxlQmFja3NwYWNlKCkge1xuICAgICAgICBpZiAodGhpcy5mb2N1c2VkVGFnSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEZWxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVtb3ZlVGFnKHRoaXMudGFnc1t0aGlzLnRhZ3MubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgdGhpcy5zZWFyY2hiYXIuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVEZWxldGUoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUmVtb3ZlVGFnKHRoaXMudGFnc1t0aGlzLmZvY3VzZWRUYWdJbmRleF0pO1xuICAgICAgICBpZiAodGhpcy5mb2N1c2VkVGFnSW5kZXggPT09IHRoaXMudGFncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNlZFRhZ0luZGV4ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUxlZnRLZXkoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvY3VzZWRUYWdJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNlZFRhZ0luZGV4ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZm9jdXNlZFRhZ0luZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZm9jdXNlZFRhZ0luZGV4ID09PSB1bmRlZmluZWQgfHwgdGhpcy5mb2N1c2VkVGFnSW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzZWRUYWdJbmRleCA9IHRoaXMudGFncy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZm9jdXNlZFRhZ0luZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzZWRUYWdJbmRleC0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZURvd25LZXkoaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuZm9jdXNlZCA9IGluZGV4IHx8IHRoaXMuZmlyc3RGb2N1c2FibGVJbmRleCgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3BlblBvcHVwKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlUmlnaHRLZXkoKSB7XG4gICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLnRhZ3MubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9jdXNlZFRhZ0luZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzZWRUYWdJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZm9jdXNlZFRhZ0luZGV4ID09PSBsYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZvY3VzZWRUYWdJbmRleCA9PT0gbGFzdCkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c2VkVGFnSW5kZXggPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5mb2N1c2VkVGFnSW5kZXggPCBsYXN0KSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzZWRUYWdJbmRleCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRJbmRleCh0ZXh0LCBzdGFydHNGcm9tID0gMCkge1xuICAgICAgICBsZXQgaXRlbVRleHQ7XG4gICAgICAgIHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuZGF0YVNlcnZpY2UuZmluZEluZGV4KGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVNlcnZpY2UuZ3JvdXBlZCkge1xuICAgICAgICAgICAgICAgIGl0ZW1UZXh0ID0gdGhpcy5wcm9wKHRoaXMudGV4dEZpZWxkLCB0aGlzLnZhbHVlUHJpbWl0aXZlKShpdGVtLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW1UZXh0ID0gdGhpcy5wcm9wKHRoaXMudGV4dEZpZWxkLCB0aGlzLnZhbHVlUHJpbWl0aXZlKShpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1UZXh0ID0gIWlzUHJlc2VudChpdGVtVGV4dCkgPyBcIlwiIDogaXRlbVRleHQudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRleHQgJiYgaXRlbVRleHQuc3RhcnRzV2l0aCh0ZXh0KTtcbiAgICAgICAgfSwgc3RhcnRzRnJvbSk7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkSXRlbXNTZXJ2aWNlLmlzSW5kZXhEaXNhYmxlZChpbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybiAoaW5kZXggKyAxID4gdGhpcy5kYXRhU2VydmljZS5pdGVtc0NvdW50KSA/IC0xIDogdGhpcy5maW5kSW5kZXgodGV4dCwgaW5kZXggKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWFyY2hUZXh0QW5kRm9jdXModGV4dCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZmluZEluZGV4KHRleHQpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuZm9jdXNlZCA9IGluZGV4O1xuICAgIH1cbiAgICBjbG9zZVBvcHVwKCkge1xuICAgICAgICB0aGlzLnRvZ2dsZVBvcHVwKGZhbHNlKTtcbiAgICAgICAgdGhpcy5mb2N1c2VkVGFnSW5kZXggPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG9wZW5Qb3B1cCgpIHtcbiAgICAgICAgdGhpcy50b2dnbGVQb3B1cCh0cnVlKTtcbiAgICAgICAgdGhpcy5mb2N1c2VkVGFnSW5kZXggPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRvZ2dsZVBvcHVwKG9wZW4pIHtcbiAgICAgICAgY29uc3QgaXNEaXNhYmxlZCA9IHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5yZWFkb25seTtcbiAgICAgICAgY29uc3Qgc2FtZVN0YXRlID0gdGhpcy5pc09wZW4gPT09IG9wZW47XG4gICAgICAgIGlmIChpc0Rpc2FibGVkIHx8IHNhbWVTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzRGVmYXVsdFByZXZlbnRlZCA9IHRoaXMudHJpZ2dlclBvcHVwRXZlbnRzKG9wZW4pO1xuICAgICAgICBpZiAoIWlzRGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlKG9wZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyaWdnZXJQb3B1cEV2ZW50cyhvcGVuKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50QXJncyA9IG5ldyBQcmV2ZW50YWJsZUV2ZW50KCk7XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4uZW1pdChldmVudEFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbG9zZS5lbWl0KGV2ZW50QXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50QXJncy5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcbiAgICB9XG4gICAgX3RvZ2dsZShvcGVuKSB7XG4gICAgICAgIHRoaXMuX29wZW4gPSAob3BlbiA9PT0gdW5kZWZpbmVkKSA/ICF0aGlzLl9vcGVuIDogb3BlbjtcbiAgICAgICAgdGhpcy5kZXN0cm95UG9wdXAoKTtcbiAgICAgICAgaWYgKHRoaXMuX29wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlUG9wdXAoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95UG9wdXAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcHVwUmVmKSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVwUmVmLnBvcHVwRWxlbWVudFxuICAgICAgICAgICAgICAgIC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLnBvcHVwTW91c2VEb3duSGFuZGxlcik7XG4gICAgICAgICAgICB0aGlzLnBvcHVwUmVmLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnBvcHVwUmVmID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVQb3B1cCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmlydHVhbCkge1xuICAgICAgICAgICAgdGhpcy52aXJ0dWFsLnNraXAgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvcml6b250YWxBbGlnbiA9IHRoaXMuZGlyZWN0aW9uID09PSBcInJ0bFwiID8gXCJyaWdodFwiIDogXCJsZWZ0XCI7XG4gICAgICAgIGNvbnN0IGFuY2hvclBvc2l0aW9uID0geyBob3Jpem9udGFsOiBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsOiBcImJvdHRvbVwiIH07XG4gICAgICAgIGNvbnN0IHBvcHVwUG9zaXRpb24gPSB7IGhvcml6b250YWw6IGhvcml6b250YWxBbGlnbiwgdmVydGljYWw6IFwidG9wXCIgfTtcbiAgICAgICAgdGhpcy5wb3B1cFJlZiA9IHRoaXMucG9wdXBTZXJ2aWNlLm9wZW4oe1xuICAgICAgICAgICAgYW5jaG9yOiB0aGlzLndyYXBwZXIsXG4gICAgICAgICAgICBhbmNob3JBbGlnbjogYW5jaG9yUG9zaXRpb24sXG4gICAgICAgICAgICBhbmltYXRlOiB0aGlzLnBvcHVwU2V0dGluZ3MuYW5pbWF0ZSxcbiAgICAgICAgICAgIGFwcGVuZFRvOiB0aGlzLmFwcGVuZFRvLFxuICAgICAgICAgICAgY29udGVudDogdGhpcy5wb3B1cFRlbXBsYXRlLFxuICAgICAgICAgICAgcG9wdXBBbGlnbjogcG9wdXBQb3NpdGlvbixcbiAgICAgICAgICAgIHBvcHVwQ2xhc3M6IHRoaXMubGlzdENvbnRhaW5lckNsYXNzZXMsXG4gICAgICAgICAgICBwb3NpdGlvbk1vZGU6ICdhYnNvbHV0ZSdcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHBvcHVwV3JhcHBlciA9IHRoaXMucG9wdXBSZWYucG9wdXBFbGVtZW50O1xuICAgICAgICBjb25zdCB7IG1pbiwgbWF4IH0gPSB0aGlzLndpZHRoO1xuICAgICAgICBwb3B1cFdyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5wb3B1cE1vdXNlRG93bkhhbmRsZXIpO1xuICAgICAgICBwb3B1cFdyYXBwZXIuc3R5bGUubWluV2lkdGggPSBtaW47XG4gICAgICAgIHBvcHVwV3JhcHBlci5zdHlsZS53aWR0aCA9IG1heDtcbiAgICAgICAgcG9wdXBXcmFwcGVyLnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICBwb3B1cFdyYXBwZXIuc2V0QXR0cmlidXRlKFwiZGlyXCIsIHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgICAgdGhpcy5wb3B1cFJlZi5wb3B1cE9wZW4uc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc0xpc3Quc2Nyb2xsVG9JdGVtKHRoaXMuc2VsZWN0aW9uU2VydmljZS5mb2N1c2VkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucG9wdXBSZWYucG9wdXBBbmNob3JWaWV3cG9ydExlYXZlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVBvcHVwKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVtaXRWYWx1ZUNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKHRoaXMudmFsdWUpO1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodGhpcy52YWx1ZSk7XG4gICAgfVxuICAgIGdldFNlbGVjdGVkRGF0YUl0ZW1zKHZhbHVlQ2hhbmdlcykge1xuICAgICAgICBjb25zdCBpc0JvdW5kVG9Db21wbGV4RGF0YSA9IGlzT2JqZWN0QXJyYXkodGhpcy5kYXRhKTtcbiAgICAgICAgY29uc3QgcHJvcCA9IHRoaXMucHJvcCh0aGlzLnZhbHVlRmllbGQsIHRoaXMudmFsdWVQcmltaXRpdmUpO1xuICAgICAgICBsZXQgY3VycmVudFZhbHVlO1xuICAgICAgICBsZXQgaW5kZXg7XG4gICAgICAgIGxldCBzZWxlY3RlZERhdGFJdGVtcyA9IFtdO1xuICAgICAgICB2YWx1ZUNoYW5nZXMuZm9yRWFjaEl0ZW0oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjdXJyZW50VmFsdWUgPSB2YWx1ZS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhU2VydmljZS5ncm91cGVkKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLmRhdGFTZXJ2aWNlLmZpbmRJbmRleCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcChpdGVtLnZhbHVlKSA9PT0gcHJvcChjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLmRhdGFTZXJ2aWNlLmZpbmRJbmRleCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcChpdGVtKSA9PT0gcHJvcChjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkRGF0YUl0ZW1zLnB1c2godGhpcy5kYXRhU2VydmljZS5pdGVtQXQoaW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudCh2YWx1ZSkgJiYgIShpc0JvdW5kVG9Db21wbGV4RGF0YSAmJiB0aGlzLnZhbHVlUHJpbWl0aXZlKSkgeyAvL3ZhbHVlIGlzIG5vdCBwcmVzZW50IGluIHRoZSBkYXRhXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWREYXRhSXRlbXMucHVzaChjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIHZhbHVlIGlzIHByaW1pdGl2ZSwgZGF0YUl0ZW0gaXMgYW4gb2JqZWN0LCBkYXRhSXRlbSBpcyBub3QgcHJlc2VudCBpbiB0aGUgY3VycmVudCBkYXRhIHNldFxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLnJlc29sdmVEYXRhSXRlbUZyb21UYWdzKGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZERhdGFJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZERhdGFJdGVtcztcbiAgICB9XG4gICAgcmVzb2x2ZURhdGFJdGVtRnJvbVRhZ3ModmFsdWUpIHtcbiAgICAgICAgaWYgKCEodGhpcy50YWdzICYmIHRoaXMudGFncy5sZW5ndGggJiYgaXNQcmVzZW50KHZhbHVlKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmxhdHRlbmluZyB0aGUgdGFncyBhcnJheSBpbiBjYXNlIG9mIGEgc3VtbWFyeSB0YWcgb2NjdXJyZW5jZS5cbiAgICAgICAgY29uc3QgdGFncyA9IHRoaXMudGFncy5yZWR1Y2UoKGFjYywgdGFnKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IGlzQXJyYXkodGFnKSA/IHRhZyA6IFt0YWddO1xuICAgICAgICAgICAgYWNjLnB1c2goLi4uaXRlbXMpO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgW10pO1xuICAgICAgICBjb25zdCBwcm9wID0gdGhpcy5wcm9wKHRoaXMudmFsdWVGaWVsZCwgdGhpcy52YWx1ZVByaW1pdGl2ZSk7XG4gICAgICAgIHJldHVybiB0YWdzLmZpbmQodGFnID0+IHByb3AodGFnKSA9PT0gcHJvcCh2YWx1ZSkpO1xuICAgIH1cbiAgICBmaXJzdEZvY3VzYWJsZUluZGV4KGluZGV4KSB7XG4gICAgICAgIGNvbnN0IG1heEluZGV4ID0gdGhpcy5kYXRhU2VydmljZS5pdGVtc0NvdW50O1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZEl0ZW1zU2VydmljZS5pc0luZGV4RGlzYWJsZWQoaW5kZXgpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgICAgICByZXR1cm4gKG5leHRJbmRleCA8IG1heEluZGV4KSA/IHRoaXMuZmlyc3RGb2N1c2FibGVJbmRleChuZXh0SW5kZXgpIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIG5leHRUaWNrKGYpIHtcbiAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAvLyBVc2UgYHNldFRpbWVvdXRgIGluc3RlYWQgb2YgYSByZXNvbHZlZCBwcm9taXNlXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBsYXR0ZXIgZG9lcyBub3Qgd2FpdCBsb25nIGVub3VnaC5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fem9uZS5ydW4oZikpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0TWVzc2FnZXMoKSB7XG4gICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubWVzc2FnZXNUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZXNUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub0RhdGFUZXh0ID0gdGhpcy5sb2NhbGl6YXRpb24uZ2V0KCdub0RhdGFUZXh0Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbk11bHRpU2VsZWN0Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdrZW5kb011bHRpU2VsZWN0JyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgTVVMVElTRUxFQ1RfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgICAgICAgICAgICAgIERhdGFTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBTZWxlY3Rpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBOYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAgRGlzYWJsZWRJdGVtc1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEwxME5fUFJFRklYLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlVmFsdWU6ICdrZW5kby5tdWx0aXNlbGVjdCdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogRmlsdGVyYWJsZURyb3BEb3duQ29tcG9uZW50QmFzZSwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTXVsdGlTZWxlY3RDb21wb25lbnQpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEtlbmRvSW5wdXQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE11bHRpU2VsZWN0Q29tcG9uZW50KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLW11bHRpc2VsZWN0JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyIGtlbmRvTXVsdGlTZWxlY3RMb2NhbGl6ZWRNZXNzYWdlc1xuICAgICAgICAgICAgaTE4bi1ub0RhdGFUZXh0PVwia2VuZG8ubXVsdGlzZWxlY3Qubm9EYXRhVGV4dHxUaGUgdGV4dCBkaXNwbGF5ZWQgaW4gdGhlIHBvcHVwIHdoZW4gdGhlcmUgYXJlIG5vIGl0ZW1zXCJcbiAgICAgICAgICAgIG5vRGF0YVRleHQ9XCJOTyBEQVRBIEZPVU5EXCJcblxuICAgICAgICAgICAgaTE4bi1jbGVhclRpdGxlPVwia2VuZG8uY29tYm9ib3guY2xlYXJUaXRsZXxUaGUgdGl0bGUgb2YgdGhlIGNsZWFyIGJ1dHRvblwiXG4gICAgICAgICAgICBjbGVhclRpdGxlPVwiY2xlYXJcIlxuICAgICAgICA+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiay1tdWx0aXNlbGVjdC13cmFwIGstZmxvYXR3cmFwXCJcbiAgICAgICAgICAgICN3cmFwcGVyXG4gICAgICAgICAgICAobW91c2Vkb3duKT1cIndyYXBwZXJNb3VzZWRvd24oJGV2ZW50KVwiXG4gICAgICAgID5cbiAgICAgICAgICAgIDxrZW5kby10YWdsaXN0XG4gICAgICAgICAgICAgICAgW2lkXT1cInRhZ0xpc3RJZFwiXG4gICAgICAgICAgICAgICAgW3RhZ3NdPVwidGFnc1wiXG4gICAgICAgICAgICAgICAgW3RleHRGaWVsZF09XCJ0ZXh0RmllbGRcIlxuICAgICAgICAgICAgICAgIFt2YWx1ZUZpZWxkXT1cInZhbHVlRmllbGRcIlxuICAgICAgICAgICAgICAgIFtmb2N1c2VkXT1cImZvY3VzZWRUYWdJbmRleFwiXG4gICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICBbdGVtcGxhdGVdPVwidGFnVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIFtncm91cFRlbXBsYXRlXT1cImdyb3VwVGFnVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIFt0YWdQcmVmaXhdPVwidGFnUHJlZml4XCJcbiAgICAgICAgICAgICAgICAocmVtb3ZlVGFnKT1cImhhbmRsZVJlbW92ZVRhZygkZXZlbnQpXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDwva2VuZG8tdGFnbGlzdD5cbiAgICAgICAgICAgIDxrZW5kby1zZWFyY2hiYXJcbiAgICAgICAgICAgICAgICAjc2VhcmNoYmFyXG4gICAgICAgICAgICAgICAgW2lkXT1cImZvY3VzYWJsZUlkXCJcbiAgICAgICAgICAgICAgICBbcm9sZV09XCInbGlzdGJveCdcIlxuICAgICAgICAgICAgICAgIFt0YWdMaXN0SWRdPVwidGFnTGlzdElkXCJcbiAgICAgICAgICAgICAgICBbYWN0aXZlRGVzY2VuZGFudF09XCJhY3RpdmVEZXNjZW5kYW50XCJcbiAgICAgICAgICAgICAgICBbbm9EYXRhTGFiZWxdPVwibm9EYXRhTGFiZWxcIlxuICAgICAgICAgICAgICAgIFt1c2VySW5wdXRdPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICBbcmVhZG9ubHldPVwicmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgIFt0YWJJbmRleF09XCJ0YWJJbmRleFwiXG4gICAgICAgICAgICAgICAgW3BvcHVwT3Blbl09XCJpc09wZW5cIlxuICAgICAgICAgICAgICAgIFtwbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiXG4gICAgICAgICAgICAgICAgKG9uTmF2aWdhdGUpPVwiaGFuZGxlTmF2aWdhdGUoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgKHZhbHVlQ2hhbmdlKT1cImhhbmRsZUZpbHRlcigkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAob25CbHVyKT1cIm9uU2VhcmNoQmFyQmx1cigpXCJcbiAgICAgICAgICAgICAgICAob25Gb2N1cyk9XCJvblNlYXJjaEJhckZvY3VzKClcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgPC9rZW5kby1zZWFyY2hiYXI+XG4gICAgICAgICAgICA8c3BhbiAqbmdJZj1cIiFsb2FkaW5nICYmICFyZWFkb25seSAmJiBjbGVhckJ1dHRvbiAmJiAodGFncz8ubGVuZ3RoIHx8IHRleHQ/Lmxlbmd0aClcIiBjbGFzcz1cImstaWNvbiBrLWNsZWFyLXZhbHVlIGstaS1jbG9zZVwiIFthdHRyLnRpdGxlXT1cImNsZWFyVGl0bGVcIiByb2xlPVwiYnV0dG9uXCIgdGFiaW5kZXg9XCItMVwiIChtb3VzZWRvd24pPVwiY2xlYXJBbGwoJGV2ZW50KVwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwibG9hZGluZ1wiIGNsYXNzPVwiay1pY29uIGstaS1sb2FkaW5nXCI+PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPG5nLXRlbXBsYXRlICNwb3B1cFRlbXBsYXRlPlxuICAgICAgICAgICAgPCEtLWhlYWRlciB0ZW1wbGF0ZS0tPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiaGVhZGVyVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIFt0ZW1wbGF0ZUNvbnRleHRdPVwie1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVJlZjogaGVhZGVyVGVtcGxhdGUudGVtcGxhdGVSZWZcbiAgICAgICAgICAgICAgICB9XCI+XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgPCEtLWN1c3RvbSBpdGVtIHRlbXBsYXRlLS0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiay1saXN0XCIgKm5nSWY9XCJhbGxvd0N1c3RvbSAmJiB0ZXh0XCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImstaXRlbSBrLWN1c3RvbS1pdGVtXCIga2VuZG9Ecm9wRG93bnNTZWxlY3RhYmxlIFttdWx0aXBsZVNlbGVjdGlvbl09XCJ0cnVlXCIgW2luZGV4XT1cIi0xXCI+XG4gICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cImN1c3RvbUl0ZW1UZW1wbGF0ZTtlbHNlIGRlZmF1bHRfY3VzdG9tX2l0ZW1fdGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW3RlbXBsYXRlQ29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVSZWY6IGN1c3RvbUl0ZW1UZW1wbGF0ZS50ZW1wbGF0ZVJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaW1wbGljaXQ6IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cIj5cbiAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNkZWZhdWx0X2N1c3RvbV9pdGVtX3RlbXBsYXRlPnt7IHRleHQgfX08L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstaWNvbiBrLWktcGx1c1wiIHN0eWxlPVwiZmxvYXQ6IHJpZ2h0XCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8IS0tbGlzdC0tPlxuICAgICAgICAgICAgPGtlbmRvLWxpc3RcbiAgICAgICAgICAgICAgICAjb3B0aW9uc0xpc3RcbiAgICAgICAgICAgICAgICBbaWRdPVwibGlzdEJveElkXCJcbiAgICAgICAgICAgICAgICBbb3B0aW9uUHJlZml4XT1cIm9wdGlvblByZWZpeFwiXG4gICAgICAgICAgICAgICAgW2RhdGFdPVwiZGF0YVwiXG4gICAgICAgICAgICAgICAgW3RleHRGaWVsZF09XCJ0ZXh0RmllbGRcIlxuICAgICAgICAgICAgICAgIFt2YWx1ZUZpZWxkXT1cInZhbHVlRmllbGRcIlxuICAgICAgICAgICAgICAgIFtoZWlnaHRdPVwibGlzdEhlaWdodFwiXG4gICAgICAgICAgICAgICAgW3RlbXBsYXRlXT1cInRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICBbZ3JvdXBUZW1wbGF0ZV09XCJncm91cFRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICBbZml4ZWRHcm91cFRlbXBsYXRlXT1cImZpeGVkR3JvdXBUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgW3Nob3ddPVwiaXNPcGVuXCJcbiAgICAgICAgICAgICAgICBbbXVsdGlwbGVTZWxlY3Rpb25dPVwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgW3ZpcnR1YWxdPVwidmlydHVhbFwiXG4gICAgICAgICAgICAgICAgKHBhZ2VDaGFuZ2UpPVwicGFnZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICA8L2tlbmRvLWxpc3Q+XG4gICAgICAgICAgICA8IS0tbm8gZGF0YSB0ZW1wbGF0ZS0tPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImstbm9kYXRhXCIgKm5nSWY9XCJkYXRhLmxlbmd0aCA9PT0gMFwiPlxuICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJub0RhdGFUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgIFt0ZW1wbGF0ZUNvbnRleHRdPVwie1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVSZWY6IG5vRGF0YVRlbXBsYXRlID8gbm9EYXRhVGVtcGxhdGUudGVtcGxhdGVSZWYgOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgfVwiPlxuICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFub0RhdGFUZW1wbGF0ZVwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2Pnt7IG5vRGF0YVRleHQgfX08L2Rpdj5cbiAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8IS0tZm9vdGVyIHRlbXBsYXRlLS0+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCJmb290ZXJUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgW3RlbXBsYXRlQ29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlUmVmOiBmb290ZXJUZW1wbGF0ZS50ZW1wbGF0ZVJlZlxuICAgICAgICAgICAgICAgIH1cIj5cbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJpc09wZW5cIj5cbiAgICAgICAgICAgIDxrZW5kby1yZXNpemUtc2Vuc29yIChyZXNpemUpPVwib25SZXNpemUoKVwiPjwva2VuZG8tcmVzaXplLXNlbnNvcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAjY29udGFpbmVyPjwvbmctY29udGFpbmVyPlxuICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbk11bHRpU2VsZWN0Q29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogUG9wdXBTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBEYXRhU2VydmljZSB9LFxuICAgIHsgdHlwZTogU2VsZWN0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmF2aWdhdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IERpc2FibGVkSXRlbXNTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgIHsgdHlwZTogS2V5VmFsdWVEaWZmZXJzIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogQm9vbGVhbiwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtUT1VDSF9FTkFCTEVELF0gfV0gfVxuXTtcbk11bHRpU2VsZWN0Q29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGZvY3VzYWJsZUlkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhdXRvQ2xvc2U6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGxvYWRpbmc6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRhdGE6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZhbHVlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB2YWx1ZUZpZWxkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0ZXh0RmllbGQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRhYmluZGV4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0YWJJbmRleDogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFtcInRhYkluZGV4XCIsXSB9XSxcbiAgICBwbGFjZWhvbGRlcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGlzYWJsZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGl0ZW1EaXNhYmxlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcmVhZG9ubHk6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlcmFibGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZpcnR1YWw6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBvcHVwU2V0dGluZ3M6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGxpc3RIZWlnaHQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZhbHVlUHJpbWl0aXZlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjbGVhckJ1dHRvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGFnTWFwcGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhbGxvd0N1c3RvbTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdmFsdWVOb3JtYWxpemVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXJDaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICB2YWx1ZUNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIG9wZW46IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBjbG9zZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIG9uRm9jdXM6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydmb2N1cycsXSB9XSxcbiAgICBvbkJsdXI6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydibHVyJyxdIH1dLFxuICAgIHJlbW92ZVRhZzogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGNvbnRhaW5lcjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ2NvbnRhaW5lcicsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiB9LF0gfV0sXG4gICAgc2VhcmNoYmFyOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFtTZWFyY2hCYXJDb21wb25lbnQsXSB9XSxcbiAgICBwb3B1cFRlbXBsYXRlOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsncG9wdXBUZW1wbGF0ZScsXSB9XSxcbiAgICB3cmFwcGVyOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsnd3JhcHBlcicsXSB9XSxcbiAgICBvcHRpb25zTGlzdDogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ29wdGlvbnNMaXN0JyxdIH1dLFxuICAgIHRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtJdGVtVGVtcGxhdGVEaXJlY3RpdmUsXSB9XSxcbiAgICBjdXN0b21JdGVtVGVtcGxhdGU6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW0N1c3RvbUl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSxdIH1dLFxuICAgIGdyb3VwVGVtcGxhdGU6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW0dyb3VwVGVtcGxhdGVEaXJlY3RpdmUsXSB9XSxcbiAgICBmaXhlZEdyb3VwVGVtcGxhdGU6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW0ZpeGVkR3JvdXBUZW1wbGF0ZURpcmVjdGl2ZSxdIH1dLFxuICAgIGhlYWRlclRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSxdIH1dLFxuICAgIGZvb3RlclRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSxdIH1dLFxuICAgIHRhZ1RlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtUYWdUZW1wbGF0ZURpcmVjdGl2ZSxdIH1dLFxuICAgIGdyb3VwVGFnVGVtcGxhdGU6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW0dyb3VwVGFnVGVtcGxhdGVEaXJlY3RpdmUsXSB9XSxcbiAgICBub0RhdGFUZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbTm9EYXRhVGVtcGxhdGVEaXJlY3RpdmUsXSB9XSxcbiAgICB3aWRnZXRDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXdpZGdldCcsXSB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstbXVsdGlzZWxlY3QnLF0gfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWhlYWRlcicsXSB9XSxcbiAgICBkaXI6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuZGlyJyxdIH1dLFxuICAgIGZvY3VzZWRDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1zdGF0ZS1mb2N1c2VkJyxdIH1dLFxuICAgIGRpc2FibGVkQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstc3RhdGUtZGlzYWJsZWQnLF0gfV1cbn07XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFRhZ0xpc3RDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnJlbW92ZVRhZyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgdGFnUHJvcCh0YWcsIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIHByb3AgJiYgaXNPYmplY3QodGFnKSA/IHRhZ1twcm9wXSA6IHRhZztcbiAgICB9XG4gICAgZGVsZXRlVGFnKGV2ZW50LCB0YWcpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCAmJiBldmVudC53aGljaCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVUYWcuZW1pdCh0YWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGl0ZW1JZCh0YWcpIHtcbiAgICAgICAgaWYgKHRhZykgeyAvL2JlY2F1c2Ugb2YgY3VzdG9tIHZhbHVlc1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFnUHJlZml4ICsgXCItXCIgKyB0aGlzLnRhZ1Byb3AodGFnLCB0aGlzLnZhbHVlRmllbGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzR3JvdXBUYWcodGFnKSB7XG4gICAgICAgIHJldHVybiB0YWcgaW5zdGFuY2VvZiBBcnJheTtcbiAgICB9XG59XG5UYWdMaXN0Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10YWdsaXN0JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8dWwgW2F0dHIuaWRdPVwiaWRcIiBjbGFzcz1cImstcmVzZXRcIj5cbiAgICAgICAgICAgIDxsaSByb2xlPVwib3B0aW9uXCIgKm5nRm9yPVwibGV0IHRhZyBvZiB0YWdzOyBsZXQgaSA9IGluZGV4O1wiIGFyaWEtc2VsZWN0ZWQ9XCJ0cnVlXCIgW2F0dHIuYXJpYS1zZXRzaXplXT1cInRhZ3M/Lmxlbmd0aFwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJrLWJ1dHRvblwiIFtuZ0NsYXNzXT1cInsgJ2stc3RhdGUtZm9jdXNlZCc6IGkgPT09IGZvY3VzZWQgfVwiIFthdHRyLmlkXT1cIml0ZW1JZCh0YWcpXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCJpc0dyb3VwVGFnKHRhZyk7IHRoZW4gZ3JvdXBUYWcgZWxzZSBzaW5nbGVUYWdcIj48L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgI2dyb3VwVGFnPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiZ3JvdXBUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0ZW1wbGF0ZUNvbnRleHRdPVwie1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVJlZjogZ3JvdXBUZW1wbGF0ZS50ZW1wbGF0ZVJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGltcGxpY2l0OiB0YWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWdyb3VwVGVtcGxhdGVcIj57eyB0YWcubGVuZ3RoIH19IHt7IHRhZy5sZW5ndGggPT09IDEgPyAnaXRlbScgOiAnaXRlbXMnIH19IHNlbGVjdGVkPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNzaW5nbGVUYWc+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cInRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3RlbXBsYXRlQ29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlUmVmOiB0ZW1wbGF0ZS50ZW1wbGF0ZVJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGltcGxpY2l0OiB0YWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIXRlbXBsYXRlXCI+e3sgdGFnUHJvcCh0YWcsIHRleHRGaWVsZCkgfX08L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgICAgICAgICAgICAgPHNwYW4gYXJpYS1sYWJlbD1cImRlbGV0ZVwiIFthdHRyLmFyaWEtaGlkZGVuXT1cImkgIT09IGZvY3VzZWRcIiBjbGFzcz1cImstc2VsZWN0XCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pY29uIGstaS1jbG9zZVwiIChtb3VzZWRvd24pPVwiZGVsZXRlVGFnKCRldmVudCwgdGFnKVwiPlxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgPC91bD5cbiAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuVGFnTGlzdENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICB0YWdzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0ZXh0RmllbGQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZhbHVlRmllbGQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZvY3VzZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRlbXBsYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBncm91cFRlbXBsYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkaXNhYmxlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGFnUHJlZml4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBpZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcmVtb3ZlVGFnOiBbeyB0eXBlOiBPdXRwdXQgfV1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBUZW1wbGF0ZUNvbnRleHREaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHZpZXdDb250YWluZXJSZWYpIHtcbiAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyUmVmID0gdmlld0NvbnRhaW5lclJlZjtcbiAgICB9XG4gICAgc2V0IHRlbXBsYXRlQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmluc2VydGVkVmlld1JlZikge1xuICAgICAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyUmVmLnJlbW92ZSh0aGlzLnZpZXdDb250YWluZXJSZWYuaW5kZXhPZih0aGlzLmluc2VydGVkVmlld1JlZikpO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRlZFZpZXdSZWYgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQudGVtcGxhdGVSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0ZWRWaWV3UmVmID0gdGhpcy52aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUVtYmVkZGVkVmlldyhjb250ZXh0LnRlbXBsYXRlUmVmLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblRlbXBsYXRlQ29udGV4dERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW3RlbXBsYXRlQ29udGV4dF0nIC8vIHRzbGludDpkaXNhYmxlLWxpbmVcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuVGVtcGxhdGVDb250ZXh0RGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogVmlld0NvbnRhaW5lclJlZiB9XG5dO1xuVGVtcGxhdGVDb250ZXh0RGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHRlbXBsYXRlQ29udGV4dDogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTZWxlY3RhYmxlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihzZWxlY3Rpb25TZXJ2aWNlKSB7XG4gICAgICAgIC8vIEBIb3N0QmluZGluZygnYXR0ci5vZmZzZXQtaW5kZXgnKVxuICAgICAgICAvLyBASW5wdXQoKSBwdWJsaWMgb2Zmc2V0SW5kZXg6IG51bWJlcjtcbiAgICAgICAgdGhpcy5tdWx0aXBsZVNlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UgPSBzZWxlY3Rpb25TZXJ2aWNlO1xuICAgIH1cbiAgICBnZXQgZm9jdXNlZENsYXNzTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uU2VydmljZS5pc0ZvY3VzZWQodGhpcy5pbmRleCk7XG4gICAgfVxuICAgIGdldCBzZWxlY3RlZENsYXNzTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uU2VydmljZS5pc1NlbGVjdGVkKHRoaXMuaW5kZXgpO1xuICAgIH1cbiAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5tdWx0aXBsZVNlbGVjdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU2VydmljZS5pc1NlbGVjdGVkKHRoaXMuaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnVuc2VsZWN0KHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmFkZCh0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5jaGFuZ2UodGhpcy5pbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5TZWxlY3RhYmxlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9Ecm9wRG93bnNTZWxlY3RhYmxlXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuU2VsZWN0YWJsZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFNlbGVjdGlvblNlcnZpY2UgfVxuXTtcblNlbGVjdGFibGVEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgaW5kZXg6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuaW5kZXgnLF0gfSwgeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBoZWlnaHQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ3N0eWxlLmhlaWdodC5weCcsXSB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ3N0eWxlLm1pbkhlaWdodC5weCcsXSB9LCB7IHR5cGU6IElucHV0IH1dLFxuICAgIG11bHRpcGxlU2VsZWN0aW9uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmb2N1c2VkQ2xhc3NOYW1lOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXN0YXRlLWZvY3VzZWQnLF0gfV0sXG4gICAgc2VsZWN0ZWRDbGFzc05hbWU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstc3RhdGUtc2VsZWN0ZWQnLF0gfV0sXG4gICAgb25DbGljazogW3sgdHlwZTogSG9zdExpc3RlbmVyLCBhcmdzOiBbJ2NsaWNrJywgWyckZXZlbnQnXSxdIH1dXG59O1xuXG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGNvbmZpZ3VyZXMgdGhlIE11bHRpU2VsZWN0IHRvIHNob3cgb25lIHNpbmdsZSBzdW1tYXJ5IHRhZyBmb3IgYWxsIHNlbGVjdGVkIGRhdGEgaXRlbXMuXG4gKiBXaGVuIGEgbnVtYmVyIGlzIHByb3ZpZGVkLCB0aGUgc3VtbWFyeSB0YWcgaXMgZGlzcGxheWVkIGFmdGVyIHRoZSBnaXZlbiBhbW91bnQgb2YgZGF0YSBpdGVtcyBhcmUgc2VsZWN0ZWRcbiAqIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZXNdKHslIHNsdWcgc3VtbWFyeXRhZ21vZGVfbXVsdGlzZWxlY3QgJX0pKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtbm8tcnVuXG4gKiA8a2VuZG8tbXVsdGlzZWxlY3Qga2VuZG9NdWx0aVNlbGVjdFN1bW1hcnlUYWcgW2RhdGFdPVwiZGF0YVwiPjwva2VuZG8tbXVsdGlzZWxlY3Q+XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtbm8tcnVuXG4gKiA8a2VuZG8tbXVsdGlzZWxlY3QgW2tlbmRvTXVsdGlTZWxlY3RTdW1tYXJ5VGFnXT1cIjJcIiBbZGF0YV09XCJkYXRhXCI+PC9rZW5kby1tdWx0aXNlbGVjdD5cbiAqIGBgYFxuICovXG5jbGFzcyBTdW1tYXJ5VGFnRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihtdWx0aVNlbGVjdENvbXBvbmVudCkge1xuICAgICAgICB0aGlzLm11bHRpU2VsZWN0Q29tcG9uZW50ID0gbXVsdGlTZWxlY3RDb21wb25lbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG51bWVyaWMgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgdGhlIG51bWJlciBvZiBzZWxlY3RlZCBkYXRhIGl0ZW1zIGFmdGVyIHdoaWNoIHRoZSBzdW1tYXJ5IHRhZyB3aWxsIGFwcGVhci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2hvd0FmdGVyID0gMDsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1pbnB1dC1yZW5hbWVcbiAgICAgICAgdGhpcy5jcmVhdGVUYWdNYXBwZXIoKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoaXNQcmVzZW50KGNoYW5nZXMuc2hvd0FmdGVyKSkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVUYWdNYXBwZXIoKTtcbiAgICAgICAgICAgIHRoaXMubXVsdGlTZWxlY3RDb21wb25lbnQub25UYWdNYXBwZXJDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVUYWdNYXBwZXIoKSB7XG4gICAgICAgIHRoaXMubXVsdGlTZWxlY3RDb21wb25lbnQudGFnTWFwcGVyID0gKHRhZ3MpID0+IHtcbiAgICAgICAgICAgIGlmICh0YWdzLmxlbmd0aCA+IHRoaXMuc2hvd0FmdGVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0YWdzLnNsaWNlKDAsIHRoaXMuc2hvd0FmdGVyKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0YWdzLnNsaWNlKHRoaXMuc2hvd0FmdGVyLCB0YWdzLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5TdW1tYXJ5VGFnRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9NdWx0aVNlbGVjdFN1bW1hcnlUYWddJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5TdW1tYXJ5VGFnRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTXVsdGlTZWxlY3RDb21wb25lbnQgfVxuXTtcblN1bW1hcnlUYWdEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgc2hvd0FmdGVyOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydrZW5kb011bHRpU2VsZWN0U3VtbWFyeVRhZycsXSB9XVxufTtcblxuY29uc3QgREVGQVVMVF9GSUxURVJfU0VUVElOR1MgPSB7XG4gICAgY2FzZVNlbnNpdGl2ZTogZmFsc2UsXG4gICAgb3BlcmF0b3I6ICdzdGFydHNXaXRoJ1xufTtcbi8qKlxuICogSW1wbGVtZW50cyBhbiBldmVudCBoYW5kbGVyIGZvciB0aGUgYGZpbHRlckNoYW5nZWAgZXZlbnQgb2YgYSBEcm9wRG93bnMgY29tcG9uZW50XG4gKiB3aGljaCBwZXJmb3JtcyBzaW1wbGUgZGF0YSBmaWx0ZXJpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBfQENvbXBvbmVudCh7XG4gKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiB0ZW1wbGF0ZTogYFxuICogIDxrZW5kby1hdXRvY29tcGxldGVcbiAqICAgICAgW2RhdGFdPVwiZGF0YVwiXG4gKiAgICAgIGtlbmRvRHJvcERvd25GaWx0ZXJcbiAqICAgICAgcGxhY2Vob2xkZXI9XCJlLmcuIEFuZG9ycmFcIj5cbiAqICA8L2tlbmRvLWF1dG9jb21wbGV0ZT5cbiAqIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICAgIHB1YmxpYyBkYXRhOiBBcnJheTxzdHJpbmc+ID0gW1wiQWxiYW5pYVwiLCBcIkFuZG9ycmFcIiwgXCJBcm1lbmlhXCIsIFwiQXVzdHJpYVwiLCBcIkF6ZXJiYWlqYW5cIl07XG4gKiB9XG4gKiBgYGBcbiAqL1xuY2xhc3MgRmlsdGVyRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wb25lbnQpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNldHMgd2hldGhlciB0aGUgZmlsdGVyaW5nIGZ1bmN0aW9uYWxpdHkgaXMgZW5hYmxlZCBvbiBjb21wb25lbnQgaW5pdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsdGVyYWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5fZmlsdGVyU2V0dGluZ3MgPSBERUZBVUxUX0ZJTFRFUl9TRVRUSU5HUztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGluaXRpYWwgZGF0YSB0aGF0IHdpbGwgYmUgdXNlZCBhcyBhIHNvdXJjZSBhcnJheSBmb3IgdGhlIGZpbHRlcmluZyBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIHNldCBkYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGEgfHwgW107XG4gICAgfVxuICAgIGdldCBkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHdoaWNoIHNldHMgdGhlIGJlaGF2aW9yIG9mIHRoZSBga2VuZG9Ecm9wRG93bkZpbHRlcmAgZGlyZWN0aXZlLlxuICAgICAqL1xuICAgIHNldCBmaWx0ZXJTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgICAgICB0aGlzLl9maWx0ZXJTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfRklMVEVSX1NFVFRJTkdTLCBzZXR0aW5ncyk7XG4gICAgfVxuICAgIGdldCBmaWx0ZXJTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlclNldHRpbmdzO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQuZmlsdGVyYWJsZSA9IHRoaXMuZmlsdGVyYWJsZTtcbiAgICAgICAgdGhpcy5maWx0ZXJDaGFuZ2VTdWJzY3JpcHRpb24gPSB0aGlzLmNvbXBvbmVudC5maWx0ZXJDaGFuZ2VcbiAgICAgICAgICAgIC5zdWJzY3JpYmUocXVlcnkgPT4gdGhpcy5jb21wb25lbnQuZGF0YSA9IHRoaXMuZ2V0RmlsdGVyZWREYXRhKHF1ZXJ5KSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmZpbHRlckNoYW5nZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBnZXRGaWx0ZXJlZERhdGEocXVlcnkpIHtcbiAgICAgICAgY29uc3QgZmllbGQgPSB0aGlzLmNvbXBvbmVudC50ZXh0RmllbGQgfHwgdGhpcy5jb21wb25lbnQudmFsdWVGaWVsZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5maWx0ZXIoaXRlbSA9PiB0aGlzLmNoZWNrSXRlbShnZXR0ZXIoaXRlbSwgZmllbGQpLCBxdWVyeSkpO1xuICAgIH1cbiAgICBjaGVja0l0ZW0odGFyZ2V0LCBxdWVyeSkge1xuICAgICAgICB0YXJnZXQgPSB0aGlzLm5vcm1hbGl6ZVZhbHVlKHRhcmdldCk7XG4gICAgICAgIHF1ZXJ5ID0gdGhpcy5ub3JtYWxpemVWYWx1ZShxdWVyeSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlclNldHRpbmdzLm9wZXJhdG9yID09PSAnY29udGFpbnMnID8gdGFyZ2V0LmluZGV4T2YocXVlcnkpICE9PSAtMSA6IHRhcmdldC5pbmRleE9mKHF1ZXJ5KSA9PT0gMDtcbiAgICB9XG4gICAgbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlID0gaXNQcmVzZW50KHZhbHVlKSA/IHZhbHVlLnRvU3RyaW5nKCkgOiAnJztcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyU2V0dGluZ3MuY2FzZVNlbnNpdGl2ZSA/IG5vcm1hbGl6ZWRWYWx1ZSA6IG5vcm1hbGl6ZWRWYWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbn1cbkZpbHRlckRpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRHJvcERvd25GaWx0ZXJdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5GaWx0ZXJEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBGaWx0ZXJhYmxlRHJvcERvd25Db21wb25lbnRCYXNlIH1cbl07XG5GaWx0ZXJEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZGF0YTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyU2V0dGluZ3M6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2tlbmRvRHJvcERvd25GaWx0ZXInLF0gfV0sXG4gICAgZmlsdGVyYWJsZTogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBNZXNzYWdlcyBleHRlbmRzIENvbXBvbmVudE1lc3NhZ2VzIHtcbn1cbk1lc3NhZ2VzLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIG5vRGF0YVRleHQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNsZWFyVGl0bGU6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUgZXh0ZW5kcyBNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbn1cbkxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUpIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6IGBcbiAgICBba2VuZG9Ecm9wRG93bkxpc3RMb2NhbGl6ZWRNZXNzYWdlc10sXG4gICAgW2tlbmRvQ29tYm9Cb3hMb2NhbGl6ZWRNZXNzYWdlc10sXG4gICAgW2tlbmRvQXV0b0NvbXBsZXRlTG9jYWxpemVkTWVzc2FnZXNdLFxuICAgIFtrZW5kb011bHRpU2VsZWN0TG9jYWxpemVkTWVzc2FnZXNdXG4gIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH1cbl07XG5cbi8qKlxuICogQ3VzdG9tIGNvbXBvbmVudCBtZXNzYWdlcyBvdmVycmlkZSBkZWZhdWx0IGNvbXBvbmVudCBtZXNzYWdlc1xuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBnbG9iYWxpemF0aW9uX2dyaWQgJX0jdG9jLWxvY2FsaXphdGlvbikpLlxuICovXG5jbGFzcyBDdXN0b21NZXNzYWdlc0NvbXBvbmVudCBleHRlbmRzIE1lc3NhZ2VzIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgfVxuICAgIGdldCBvdmVycmlkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDdXN0b21NZXNzYWdlc0NvbXBvbmVudCkgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWRyb3Bkb3dubGlzdC1tZXNzYWdlcywga2VuZG8tY29tYm9ib3gtbWVzc2FnZXMsIGtlbmRvLWF1dG9jb21wbGV0ZS1tZXNzYWdlcywga2VuZG8tbXVsdGlzZWxlY3QtbWVzc2FnZXMnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5DdXN0b21NZXNzYWdlc0NvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfVxuXTtcblxuY29uc3QgU0hBUkVEX0RJUkVDVElWRVMgPSBbXG4gICAgSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgSXRlbVRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIEdyb3VwVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgRml4ZWRHcm91cFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIE5vRGF0YVRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlLFxuICAgIEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LFxuICAgIEZpbHRlckRpcmVjdGl2ZVxuXTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFRoZSBleHBvcnRlZCBwYWNrYWdlIG1vZHVsZS5cbiAqXG4gKiBUaGUgcGFja2FnZSBleHBvcnRzOlxuICogLSBgSXRlbVRlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgaXRlbSB0ZW1wbGF0ZSBkaXJlY3RpdmUuXG4gKiAtIGBIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZWAmbWRhc2g7VGhlIGhlYWRlciB0ZW1wbGF0ZSBkaXJlY3RpdmUuXG4gKiAtIGBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZWAmbWRhc2g7VGhlIGZvb3RlciB0ZW1wbGF0ZSBkaXJlY3RpdmUuXG4gKiAtIGBOb0RhdGFUZW1wbGF0ZURpcmVjdGl2ZWAmbWRhc2g7VGhlIG5vRGF0YSB0ZW1wbGF0ZSBkaXJlY3RpdmUuXG4gKi9cbmNsYXNzIFNoYXJlZERpcmVjdGl2ZXNNb2R1bGUge1xufVxuU2hhcmVkRGlyZWN0aXZlc01vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbU0hBUkVEX0RJUkVDVElWRVNdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtTSEFSRURfRElSRUNUSVZFU11cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuY29uc3QgSU5URVJOQUxfRElSRUNUSVZFUyA9IFtcbiAgICBMaXN0Q29tcG9uZW50LFxuICAgIExpc3RJdGVtRGlyZWN0aXZlLFxuICAgIFNlbGVjdGFibGVEaXJlY3RpdmUsXG4gICAgU2VhcmNoQmFyQ29tcG9uZW50LFxuICAgIFRlbXBsYXRlQ29udGV4dERpcmVjdGl2ZVxuXTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTaGFyZWRNb2R1bGUge1xufVxuU2hhcmVkTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtJTlRFUk5BTF9ESVJFQ1RJVkVTXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbSU5URVJOQUxfRElSRUNUSVZFUywgQ29tbW9uTW9kdWxlLCBGb3Jtc01vZHVsZSwgUG9wdXBNb2R1bGUsIFJlc2l6ZVNlbnNvck1vZHVsZSwgU2hhcmVkRGlyZWN0aXZlc01vZHVsZV0sXG4gICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgRm9ybXNNb2R1bGUsIFBvcHVwTW9kdWxlLCBSZXNpemVTZW5zb3JNb2R1bGUsIFNoYXJlZERpcmVjdGl2ZXNNb2R1bGVdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5cbmNvbnN0IEFVVE9DT01QTEVURV9ESVJFQ1RJVkVTID0gW1xuICAgIEF1dG9Db21wbGV0ZUNvbXBvbmVudFxuXTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFRoZSBleHBvcnRlZCBwYWNrYWdlIG1vZHVsZS5cbiAqXG4gKiBUaGUgcGFja2FnZSBleHBvcnRzOlxuICogLSBgQXV0b0NvbXBsZXRlQ29tcG9uZW50YCZtZGFzaDtUaGUgQXV0b0NvbXBsZXRlIGNvbXBvbmVudCBjbGFzcy5cbiAqIC0gYEl0ZW1UZW1wbGF0ZURpcmVjdGl2ZWAmbWRhc2g7VGhlIGl0ZW0gdGVtcGxhdGUgZGlyZWN0aXZlLlxuICogLSBgSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmVgJm1kYXNoO1RoZSBoZWFkZXIgdGVtcGxhdGUgZGlyZWN0aXZlLlxuICogLSBgRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmVgJm1kYXNoO1RoZSBmb290ZXIgdGVtcGxhdGUgZGlyZWN0aXZlLlxuICovXG5jbGFzcyBBdXRvQ29tcGxldGVNb2R1bGUge1xufVxuQXV0b0NvbXBsZXRlTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtBVVRPQ09NUExFVEVfRElSRUNUSVZFU10sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW0FVVE9DT01QTEVURV9ESVJFQ1RJVkVTLCBTaGFyZWREaXJlY3RpdmVzTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbU2hhcmVkTW9kdWxlXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTpvYmplY3QtbGl0ZXJhbC1zb3J0LWtleXMgKi9cbmNvbnN0IGFnZW50UnhzID0ge1xuICAgIHdwOiAvKFdpbmRvd3MgUGhvbmUoPzogT1MpPylcXHMoXFxkKylcXC4oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICBmaXJlOiAvKFNpbGspXFwvKFxcZCspXFwuKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgYW5kcm9pZDogLyhBbmRyb2lkfEFuZHJvaWQuKig/Ok9wZXJhfEZpcmVmb3gpLio/XFwvKVxccyooXFxkKylcXC4oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICBpcGhvbmU6IC8oaVBob25lfGlQb2QpLipPU1xccysoXFxkKylbXFwuX10oW1xcZFxcLl9dKykvLFxuICAgIGlwYWQ6IC8oaVBhZCkuKk9TXFxzKyhcXGQrKVtcXC5fXShbXFxkX10rKS8sXG4gICAgbWVlZ286IC8oTWVlR28pLitOb2tpYUJyb3dzZXJcXC8oXFxkKylcXC4oW1xcZFxcLl9dKykvLFxuICAgIHdlYm9zOiAvKHdlYk9TKVxcLyhcXGQrKVxcLihcXGQrKFxcLlxcZCspPykvLFxuICAgIGJsYWNrYmVycnk6IC8oQmxhY2tCZXJyeXxCQjEwKS4qP1ZlcnNpb25cXC8oXFxkKylcXC4oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICBwbGF5Ym9vazogLyhQbGF5Qm9vaykuKj9UYWJsZXRcXHMqT1NcXHMqKFxcZCspXFwuKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgd2luZG93czogLyhNU0lFKVxccysoXFxkKylcXC4oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICB0aXplbjogLyh0aXplbikuKj9WZXJzaW9uXFwvKFxcZCspXFwuKFxcZCsoXFwuXFxkKyk/KS9pLFxuICAgIHNhaWxmaXNoOiAvKHNhaWxmaXNoKS4qcnY6KFxcZCspXFwuKFxcZCsoXFwuXFxkKyk/KS4qZmlyZWZveC9pLFxuICAgIGZmb3M6IC8oTW9iaWxlKS4qcnY6KFxcZCspXFwuKFxcZCsoXFwuXFxkKyk/KS4qRmlyZWZveC9cbn07XG5jb25zdCBvc1J4cyA9IHtcbiAgICBpb3M6IC9eaShwaG9uZXxwYWR8cG9kKSQvaSxcbiAgICBhbmRyb2lkOiAvXmFuZHJvaWR8ZmlyZSQvaSxcbiAgICBibGFja2JlcnJ5OiAvXmJsYWNrYmVycnl8cGxheWJvb2svaSxcbiAgICB3aW5kb3dzOiAvd2luZG93cy8sXG4gICAgd3A6IC93cC8sXG4gICAgZmxhdDogL3NhaWxmaXNofGZmb3N8dGl6ZW4vaSxcbiAgICBtZWVnbzogL21lZWdvL1xufTtcbmNvbnN0IGRlc2t0b3BCcm93c2VyUnhzID0ge1xuICAgIGVkZ2U6IC8oZWRnZSlbIFxcL10oW1xcdy5dKykvaSxcbiAgICB3ZWJraXQ6IC8oY2hyb21lKVsgXFwvXShbXFx3Ll0rKS9pLFxuICAgIHNhZmFyaTogLyh3ZWJraXQpWyBcXC9dKFtcXHcuXSspL2ksXG4gICAgb3BlcmE6IC8ob3BlcmEpKD86Lip2ZXJzaW9ufClbIFxcL10oW1xcdy5dKykvaSxcbiAgICBtc2llOiAvKG1zaWVcXHN8dHJpZGVudC4qPyBydjopKFtcXHcuXSspL2ksXG4gICAgbW96aWxsYTogLyhtb3ppbGxhKSg/Oi4qPyBydjooW1xcdy5dKyl8KS9pXG59O1xuY29uc3QgbW9iaWxlQnJvd3NlclJ4cyA9IHtcbiAgICBvbWluaTogL09wZXJhXFxzTWluaS9pLFxuICAgIG9tb2JpbGU6IC9PcGVyYVxcc01vYmkvaSxcbiAgICBmaXJlZm94OiAvRmlyZWZveHxGZW5uZWMvaSxcbiAgICBtb2JpbGVzYWZhcmk6IC92ZXJzaW9uXFwvLipzYWZhcmkvaSxcbiAgICBpZTogL01TSUV8V2luZG93c1xcc1Bob25lL2ksXG4gICAgY2hyb21lOiAvY2hyb21lfGNyaW9zL2ksXG4gICAgd2Via2l0OiAvd2Via2l0L2lcbn07XG5jb25zdCB0ZXN0UnggPSAoYWdlbnQsIHJ4cywgZGZsdCkgPT4ge1xuICAgIGZvciAobGV0IHJ4IGluIHJ4cykge1xuICAgICAgICBpZiAocnhzLmhhc093blByb3BlcnR5KHJ4KSAmJiByeHNbcnhdLnRlc3QoYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcng7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRmbHQgIT09IHVuZGVmaW5lZCA/IGRmbHQgOiBhZ2VudDtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZGV0ZWN0TW9iaWxlT1MgPSAodWEpID0+IHtcbiAgICBsZXQgbWlub3JWZXJzaW9uO1xuICAgIGxldCBtYXRjaCA9IFtdO1xuICAgIGZvciAobGV0IGFnZW50IGluIGFnZW50UnhzKSB7XG4gICAgICAgIGlmIChhZ2VudFJ4cy5oYXNPd25Qcm9wZXJ0eShhZ2VudCkpIHtcbiAgICAgICAgICAgIG1hdGNoID0gdWEubWF0Y2goYWdlbnRSeHNbYWdlbnRdKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZ2VudCA9PT0gJ3dpbmRvd3MnICYmICdwbHVnaW5zJyBpbiB3aW5kb3cubmF2aWdhdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IC8vIEJyZWFrIGlmIG5vdCBNZXRyby9Nb2JpbGUgV2luZG93c1xuICAgICAgICAgICAgY29uc3Qgb3MgPSB7fTtcbiAgICAgICAgICAgIG9zLmRldmljZSA9IGFnZW50O1xuICAgICAgICAgICAgb3MuYnJvd3NlciA9IHRlc3RSeCh1YSwgbW9iaWxlQnJvd3NlclJ4cywgJ2RlZmF1bHQnKTtcbiAgICAgICAgICAgIG9zLm5hbWUgPSB0ZXN0UngoYWdlbnQsIG9zUnhzKTtcbiAgICAgICAgICAgIG9zW29zLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIG9zLm1ham9yVmVyc2lvbiA9IG1hdGNoWzJdO1xuICAgICAgICAgICAgb3MubWlub3JWZXJzaW9uID0gbWF0Y2hbM10ucmVwbGFjZSgnXycsICcuJyk7XG4gICAgICAgICAgICBtaW5vclZlcnNpb24gPSBvcy5taW5vclZlcnNpb24ucmVwbGFjZSgnLicsICcnKS5zdWJzdHIoMCwgMik7XG4gICAgICAgICAgICBvcy5mbGF0VmVyc2lvbiA9IG9zLm1ham9yVmVyc2lvbiArIG1pbm9yVmVyc2lvbiArXG4gICAgICAgICAgICAgICAgKG5ldyBBcnJheSgzIC0gKG1pbm9yVmVyc2lvbi5sZW5ndGggPCAzID8gbWlub3JWZXJzaW9uLmxlbmd0aCA6IDIpKS5qb2luKCcwJykpO1xuICAgICAgICAgICAgb3MuY29yZG92YSA9IHR5cGVvZiB3aW5kb3cuUGhvbmVHYXAgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIHx8IHR5cGVvZiB3aW5kb3cuY29yZG92YSAhPT0gdW5kZWZpbmVkOyAvLyBVc2UgZmlsZSBwcm90b2NvbCB0byBkZXRlY3QgYXBwTW9kZXMuXG4gICAgICAgICAgICBvcy5hcHBNb2RlID0gd2luZG93Lm5hdmlnYXRvci5zdGFuZGFsb25lXG4gICAgICAgICAgICAgICAgfHwgKC9maWxlfGxvY2FsfHdtYXBwLykudGVzdCh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wpXG4gICAgICAgICAgICAgICAgfHwgb3MuY29yZG92YTsgLy8gVXNlIGZpbGUgcHJvdG9jb2wgdG8gZGV0ZWN0IGFwcE1vZGVzLlxuICAgICAgICAgICAgcmV0dXJuIG9zO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBkZXRlY3REZXNrdG9wQnJvd3NlciA9ICh1YSkgPT4ge1xuICAgIGxldCBicm93c2VySW5mbyA9IG51bGw7XG4gICAgbGV0IG1hdGNoID0gW107XG4gICAgZm9yIChsZXQgYWdlbnQgaW4gZGVza3RvcEJyb3dzZXJSeHMpIHtcbiAgICAgICAgaWYgKGRlc2t0b3BCcm93c2VyUnhzLmhhc093blByb3BlcnR5KGFnZW50KSkge1xuICAgICAgICAgICAgbWF0Y2ggPSB1YS5tYXRjaChkZXNrdG9wQnJvd3NlclJ4c1thZ2VudF0pO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgYnJvd3NlckluZm8gPSB7fTtcbiAgICAgICAgICAgICAgICBicm93c2VySW5mb1thZ2VudF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyb3dzZXJJbmZvW21hdGNoWzFdLnRvTG93ZXJDYXNlKCkuc3BsaXQoJyAnKVswXS5zcGxpdCgnLycpWzBdXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJvd3NlckluZm8udmVyc2lvbiA9IHBhcnNlSW50KGRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBtYXRjaFsyXSwgMTApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBicm93c2VySW5mbztcbn07XG5jb25zdCB1c2VyQWdlbnQgPSBpc1dpbmRvd0F2YWlsYWJsZSgpICYmIHdpbmRvdy5uYXZpZ2F0b3IgPyB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCA6IG51bGw7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgYnJvd3NlciA9IHVzZXJBZ2VudCA/IGRldGVjdERlc2t0b3BCcm93c2VyKHVzZXJBZ2VudCkgOiBudWxsO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG1vYmlsZU9TID0gdXNlckFnZW50ID8gZGV0ZWN0TW9iaWxlT1ModXNlckFnZW50KSA6IG51bGw7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgdG91Y2ggPSBpc1dpbmRvd0F2YWlsYWJsZSgpICYmICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdztcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBtc1BvaW50ZXJzID0gYnJvd3NlciAmJiAhYnJvd3Nlci5jaHJvbWUgJiYgd2luZG93Lk1TUG9pbnRlckV2ZW50O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHBvaW50ZXJzID0gYnJvd3NlciAmJiAhYnJvd3Nlci5jaHJvbWUgJiYgd2luZG93LlBvaW50ZXJFdmVudDtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCB0b3VjaEVuYWJsZWQgPSBtb2JpbGVPUyAmJiAodG91Y2ggfHwgbXNQb2ludGVycyB8fCBwb2ludGVycyk7XG5cbmNvbnN0IENPTUJPQk9YX0RJUkVDVElWRVMgPSBbXG4gICAgQ29tYm9Cb3hDb21wb25lbnRcbl07XG5jb25zdCDJtTAkMSA9IHRvdWNoRW5hYmxlZDtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFRoZSBleHBvcnRlZCBwYWNrYWdlIG1vZHVsZS5cbiAqXG4gKiBUaGUgcGFja2FnZSBleHBvcnRzOlxuICogLSBgQ29tYm9Cb3hDb21wb25lbnRgJm1kYXNoO1RoZSBDb21ib0JveCBjb21wb25lbnQgY2xhc3MuXG4gKiAtIGBJdGVtVGVtcGxhdGVEaXJlY3RpdmVgJm1kYXNoO1RoZSBpdGVtIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqIC0gYEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgaGVhZGVyIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqIC0gYEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgZm9vdGVyIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqL1xuY2xhc3MgQ29tYm9Cb3hNb2R1bGUge1xufVxuQ29tYm9Cb3hNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW0NPTUJPQk9YX0RJUkVDVElWRVNdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtDT01CT0JPWF9ESVJFQ1RJVkVTLCBTaGFyZWREaXJlY3RpdmVzTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbU2hhcmVkTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IFRPVUNIX0VOQUJMRUQsIHVzZVZhbHVlOiDJtTAkMSB9XVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRmlsdGVySW5wdXREaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHpvbmUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmZvY3VzZWQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dFRpY2soKCkgPT4gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dFRpY2soZm4pIHtcbiAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHNldFRpbWVvdXQoZm4pKTtcbiAgICB9XG59XG5GaWx0ZXJJbnB1dERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2ZpbHRlcklucHV0XScgLy8gdHNsaW50OmRpc2FibGUtbGluZVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5GaWx0ZXJJbnB1dERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9XG5dO1xuRmlsdGVySW5wdXREaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZm9jdXNlZDogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnZmlsdGVySW5wdXQnLF0gfV1cbn07XG5cbmNvbnN0IERST1BET1dOTElTVF9ESVJFQ1RJVkVTID0gW1xuICAgIERyb3BEb3duTGlzdENvbXBvbmVudCxcbiAgICBWYWx1ZVRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIEZpbHRlcklucHV0RGlyZWN0aXZlXG5dO1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogVGhlIGV4cG9ydGVkIHBhY2thZ2UgbW9kdWxlLlxuICpcbiAqIFRoZSBwYWNrYWdlIGV4cG9ydHM6XG4gKiAtIGBEcm9wRG93bkxpc3RDb21wb25lbnRgJm1kYXNoO1RoZSBEcm9wRG93bkxpc3QgY29tcG9uZW50IGNsYXNzLlxuICogLSBgSXRlbVRlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgaXRlbSB0ZW1wbGF0ZSBkaXJlY3RpdmUuXG4gKiAtIGBWYWx1ZVRlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgdmFsdWUgdGVtcGxhdGUgZGlyZWN0aXZlLlxuICogLSBgSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmVgJm1kYXNoO1RoZSBoZWFkZXIgdGVtcGxhdGUgZGlyZWN0aXZlLlxuICogLSBgRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmVgJm1kYXNoO1RoZSBmb290ZXIgdGVtcGxhdGUgZGlyZWN0aXZlLlxuICovXG5jbGFzcyBEcm9wRG93bkxpc3RNb2R1bGUge1xufVxuRHJvcERvd25MaXN0TW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtEUk9QRE9XTkxJU1RfRElSRUNUSVZFU10sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW0RST1BET1dOTElTVF9ESVJFQ1RJVkVTLCBTaGFyZWREaXJlY3RpdmVzTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbU2hhcmVkTW9kdWxlXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuXG5jb25zdCBNVUxUSVNFTEVDVF9ESVJFQ1RJVkVTID0gW1xuICAgIE11bHRpU2VsZWN0Q29tcG9uZW50LFxuICAgIFRhZ0xpc3RDb21wb25lbnQsXG4gICAgVGFnVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgR3JvdXBUYWdUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBTdW1tYXJ5VGFnRGlyZWN0aXZlLFxuICAgIEN1c3RvbUl0ZW1UZW1wbGF0ZURpcmVjdGl2ZVxuXTtcbmNvbnN0IMm1MCQyID0gdG91Y2hFbmFibGVkO1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogVGhlIGV4cG9ydGVkIHBhY2thZ2UgbW9kdWxlLlxuICpcbiAqIFRoZSBwYWNrYWdlIGV4cG9ydHM6XG4gKiAtIGBNdWx0aVNlbGVjdENvbXBvbmVudGAmbWRhc2g7VGhlIE11bHRpU2VsZWN0IGNvbXBvbmVudCBjbGFzcy5cbiAqIC0gYFN1bW1hcnlUYWdEaXJlY3RpdmVgJm1kYXNoO1RoZSBNdWx0aVNlbGVjdCBzdW1tYXJ5IHRhZyBkaXJlY3RpdmUuXG4gKiAtIGBJdGVtVGVtcGxhdGVEaXJlY3RpdmVgJm1kYXNoO1RoZSBpdGVtIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqIC0gYEN1c3RvbUl0ZW1UZW1wbGF0ZURpcmVjdGl2ZWAmbWRhc2g7VGhlIGN1c3RvbSBpdGVtIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqIC0gYFRhZ1RlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgdGFnIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqIC0gYFN1bW1hcnlUYWdUZW1wbGF0ZURpcmVjdGl2ZWAmbWRhc2g7VGhlIHN1bW1hcnkgdGFnIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqIC0gYEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgaGVhZGVyIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqIC0gYEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgZm9vdGVyIHRlbXBsYXRlIGRpcmVjdGl2ZS5cbiAqIC0gYE5vRGF0YVRlbXBsYXRlRGlyZWN0aXZlYCZtZGFzaDtUaGUgbm8tZGF0YSB0ZW1wbGF0ZSBkaXJlY3RpdmUuXG4gKi9cbmNsYXNzIE11bHRpU2VsZWN0TW9kdWxlIHtcbn1cbk11bHRpU2VsZWN0TW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNVUxUSVNFTEVDVF9ESVJFQ1RJVkVTXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbTVVMVElTRUxFQ1RfRElSRUNUSVZFUywgU2hhcmVkRGlyZWN0aXZlc01vZHVsZV0sXG4gICAgICAgICAgICAgICAgaW1wb3J0czogW1NoYXJlZE1vZHVsZV0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBUT1VDSF9FTkFCTEVELCB1c2VWYWx1ZTogybUwJDIgfV1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgRHJvcGRvd25zIGNvbXBvbmVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cy1uby1ydW5cbiAqIC8vIEltcG9ydCB0aGUgRHJvcGRvd25zIG1vZHVsZVxuICogaW1wb3J0IHsgRHJvcERvd25zTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItZHJvcGRvd25zJztcbiAqXG4gKiAvLyBUaGUgYnJvd3NlciBwbGF0Zm9ybSB3aXRoIGEgY29tcGlsZXJcbiAqIGltcG9ydCB7IHBsYXRmb3JtQnJvd3NlckR5bmFtaWMgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMnO1xuICpcbiAqIGltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogLy8gSW1wb3J0IHRoZSBhcHAgY29tcG9uZW50XG4gKiBpbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xuICpcbiAqIC8vIERlZmluZSB0aGUgYXBwIG1vZHVsZVxuICogX0BOZ01vZHVsZSh7XG4gKiAgICAgZGVjbGFyYXRpb25zOiBbQXBwQ29tcG9uZW50XSwgLy8gZGVjbGFyZSB0aGUgYXBwIGNvbXBvbmVudFxuICogICAgIGltcG9ydHM6ICAgICAgW0Jyb3dzZXJNb2R1bGUsIERyb3BEb3duc01vZHVsZV0sIC8vIGltcG9ydCB0aGUgRHJvcGRvd25zIG1vZHVsZVxuICogICAgIGJvb3RzdHJhcDogICAgW0FwcENvbXBvbmVudF1cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHt9XG4gKlxuICogLy8gQ29tcGlsZSBhbmQgbGF1bmNoIHRoZSBtb2R1bGVcbiAqIHBsYXRmb3JtQnJvd3NlckR5bmFtaWMoKS5ib290c3RyYXBNb2R1bGUoQXBwTW9kdWxlKTtcbiAqXG4gKiBgYGBcbiAqL1xuY2xhc3MgRHJvcERvd25zTW9kdWxlIHtcbn1cbkRyb3BEb3duc01vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZXhwb3J0czogW0F1dG9Db21wbGV0ZU1vZHVsZSwgQ29tYm9Cb3hNb2R1bGUsIERyb3BEb3duTGlzdE1vZHVsZSwgTXVsdGlTZWxlY3RNb2R1bGVdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgQVVUT0NPTVBMRVRFX1ZBTFVFX0FDQ0VTU09SLCBDT01CT0JPWF9WQUxVRV9BQ0NFU1NPUiwgRGF0YVNlcnZpY2UsIERpc2FibGVkSXRlbXNTZXJ2aWNlLCBEUk9QRE9XTkxJU1RfVkFMVUVfQUNDRVNTT1IsIEZpbHRlcklucHV0RGlyZWN0aXZlLCBGaWx0ZXJhYmxlRHJvcERvd25Db21wb25lbnRCYXNlLCBMaXN0SXRlbURpcmVjdGl2ZSwgQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQsIExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlLCBNZXNzYWdlcywgTmF2aWdhdGlvblNlcnZpY2UsIFNlYXJjaEJhckNvbXBvbmVudCwgU2VsZWN0aW9uU2VydmljZSwgYnJvd3NlciwgZGV0ZWN0RGVza3RvcEJyb3dzZXIsIGRldGVjdE1vYmlsZU9TLCBtb2JpbGVPUywgbXNQb2ludGVycywgcG9pbnRlcnMsIHRvdWNoLCB0b3VjaEVuYWJsZWQsIE5vRGF0YVRlbXBsYXRlRGlyZWN0aXZlLCBUYWdUZW1wbGF0ZURpcmVjdGl2ZSwgVE9VQ0hfRU5BQkxFRCwgaXNXaW5kb3dBdmFpbGFibGUsIEF1dG9Db21wbGV0ZUNvbXBvbmVudCwgQ29tYm9Cb3hDb21wb25lbnQsIERyb3BEb3duTGlzdENvbXBvbmVudCwgTXVsdGlTZWxlY3RDb21wb25lbnQsIFRhZ0xpc3RDb21wb25lbnQsIEl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSwgR3JvdXBUZW1wbGF0ZURpcmVjdGl2ZSwgRml4ZWRHcm91cFRlbXBsYXRlRGlyZWN0aXZlLCBDdXN0b21JdGVtVGVtcGxhdGVEaXJlY3RpdmUsIEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlLCBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSwgVmFsdWVUZW1wbGF0ZURpcmVjdGl2ZSwgVGVtcGxhdGVDb250ZXh0RGlyZWN0aXZlLCBHcm91cFRhZ1RlbXBsYXRlRGlyZWN0aXZlLCBTZWxlY3RhYmxlRGlyZWN0aXZlLCBTdW1tYXJ5VGFnRGlyZWN0aXZlLCBGaWx0ZXJEaXJlY3RpdmUsIERyb3BEb3duc01vZHVsZSwgTXVsdGlTZWxlY3RNb2R1bGUsIFNoYXJlZE1vZHVsZSwgQXV0b0NvbXBsZXRlTW9kdWxlLCBDb21ib0JveE1vZHVsZSwgRHJvcERvd25MaXN0TW9kdWxlLCBTaGFyZWREaXJlY3RpdmVzTW9kdWxlLCBMaXN0Q29tcG9uZW50LCBQcmV2ZW50YWJsZUV2ZW50IH07XG4iXX0=