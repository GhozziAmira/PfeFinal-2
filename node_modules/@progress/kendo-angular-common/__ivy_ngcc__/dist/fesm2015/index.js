/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { EventEmitter, Directive, ElementRef, NgZone, Input, Output, NgModule, Renderer2, Injectable, Component } from '@angular/core';
import Draggable from '@telerik/kendo-draggable';
import { CommonModule } from '@angular/common';
import { auditTime } from 'rxjs/operators';
import { merge, fromEvent, from } from 'rxjs';

import * as ɵngcc0 from '@angular/core';
const isDocumentAvailable = () => typeof document !== 'undefined';

const isChanged = (propertyName, changes, skipFirstChange = true) => (typeof changes[propertyName] !== 'undefined' &&
    (!changes[propertyName].isFirstChange() || !skipFirstChange) &&
    changes[propertyName].previousValue !== changes[propertyName].currentValue);

const anyChanged = (propertyNames, changes, skipFirstChange = true) => propertyNames.some(name => isChanged(name, changes, skipFirstChange));

const hasObservers = (emitter) => emitter && emitter.observers.length > 0;

const guid = () => {
    let id = "";
    for (let i = 0; i < 32; i++) {
        const random = Math.random() * 16 | 0; // tslint:disable-line:no-bitwise
        if (i === 8 || i === 12 || i === 16 || i === 20) {
            id += "-";
        }
        // tslint:disable-next-line:no-bitwise
        id += (i === 12 ? 4 : (i === 16 ? (random & 3 | 8) : random)).toString(16);
    }
    return id;
};

class DraggableDirective {
    constructor(element, ngZone) {
        this.element = element;
        this.ngZone = ngZone;
        this.enableDrag = true;
        this.kendoPress = new EventEmitter();
        this.kendoDrag = new EventEmitter();
        this.kendoRelease = new EventEmitter();
    }
    ngOnInit() {
        this.toggleDraggable();
    }
    ngOnChanges(changes) {
        if (isChanged('enableDrag', changes)) {
            this.toggleDraggable();
        }
    }
    ngOnDestroy() {
        this.destroyDraggable();
    }
    toggleDraggable() {
        if (isDocumentAvailable()) {
            this.destroyDraggable();
            if (this.enableDrag) {
                this.draggable = new Draggable({
                    drag: (e) => this.kendoDrag.next(e),
                    press: (e) => this.kendoPress.next(e),
                    release: (e) => this.kendoRelease.next(e)
                });
                this.ngZone.runOutsideAngular(() => this.draggable.bindTo(this.element.nativeElement));
            }
        }
    }
    destroyDraggable() {
        if (this.draggable) {
            this.draggable.destroy();
            this.draggable = null;
        }
    }
}
DraggableDirective.ɵfac = function DraggableDirective_Factory(t) { return new (t || DraggableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
DraggableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DraggableDirective, selectors: [["", "kendoDraggable", ""]], inputs: { enableDrag: "enableDrag" }, outputs: { kendoPress: "kendoPress", kendoDrag: "kendoDrag", kendoRelease: "kendoRelease" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()] });
/** @nocollapse */
DraggableDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
DraggableDirective.propDecorators = {
    enableDrag: [{ type: Input }],
    kendoPress: [{ type: Output }],
    kendoDrag: [{ type: Output }],
    kendoRelease: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DraggableDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDraggable]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { enableDrag: [{
            type: Input
        }], kendoPress: [{
            type: Output
        }], kendoDrag: [{
            type: Output
        }], kendoRelease: [{
            type: Output
        }] }); })();

/**
 * @hidden
 */
class DraggableModule {
}
DraggableModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: DraggableModule });
DraggableModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function DraggableModule_Factory(t) { return new (t || DraggableModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DraggableModule, { declarations: function () { return [DraggableDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [DraggableDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DraggableModule, [{
        type: NgModule,
        args: [{
                declarations: [DraggableDirective],
                exports: [DraggableDirective],
                imports: [CommonModule]
            }]
    }], null, null); })();

/* tslint:disable:no-input-rename */
/**
 * @hidden
 */
class EventsOutsideAngularDirective {
    constructor(element, ngZone, renderer) {
        this.element = element;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.events = {};
    }
    ngOnInit() {
        if (!this.element || !this.element.nativeElement) {
            return;
        }
        const events = this.events;
        this.subscriptions = [];
        this.ngZone.runOutsideAngular(() => {
            for (let name in events) {
                if (events.hasOwnProperty(name)) {
                    this.subscriptions.push(this.renderer.listen(this.element.nativeElement, name, this.scope ? events[name].bind(this.scope) : events[name]));
                }
            }
        });
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            for (let idx = 0; idx < this.subscriptions.length; idx++) {
                this.subscriptions[idx]();
            }
            this.subscriptions = null;
        }
    }
}
EventsOutsideAngularDirective.ɵfac = function EventsOutsideAngularDirective_Factory(t) { return new (t || EventsOutsideAngularDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
EventsOutsideAngularDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: EventsOutsideAngularDirective, selectors: [["", "kendoEventsOutsideAngular", ""]], inputs: { events: ["kendoEventsOutsideAngular", "events"], scope: "scope" } });
/** @nocollapse */
EventsOutsideAngularDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: Renderer2 }
];
EventsOutsideAngularDirective.propDecorators = {
    events: [{ type: Input, args: ['kendoEventsOutsideAngular',] }],
    scope: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EventsOutsideAngularDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoEventsOutsideAngular]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }]; }, { events: [{
            type: Input,
            args: ['kendoEventsOutsideAngular']
        }], scope: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class EventsModule {
}
EventsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: EventsModule });
EventsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function EventsModule_Factory(t) { return new (t || EventsModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(EventsModule, { declarations: [EventsOutsideAngularDirective], exports: [EventsOutsideAngularDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EventsModule, [{
        type: NgModule,
        args: [{
                declarations: [EventsOutsideAngularDirective],
                exports: [EventsOutsideAngularDirective]
            }]
    }], null, null); })();

class ResizeService {
    constructor(resizeBatchService) {
        this.resizeBatchService = resizeBatchService;
        this.resize = new EventEmitter();
        this.acceptedSize = false;
        this.state = 0 /* Initial */;
    }
    acceptSize(size = this.measure()) {
        this.lastWidth = size.width;
        this.lastHeight = size.height;
        this.acceptedSize = true;
    }
    checkChanges() {
        if (!isDocumentAvailable()) {
            return;
        }
        if (this.state === 0 /* Initial */) {
            this.state = 1 /* Initializing */;
            // batch initial measure
            this.resizeBatchService.schedule(this, this.init);
        }
    }
    destroy() {
        this.resizeBatchService.cancel(this);
    }
    checkSize() {
        if (!this.parentElement) {
            return;
        }
        const { width, height } = this.measure();
        const sameSize = width === this.lastWidth && height === this.lastHeight;
        if (sameSize) {
            return;
        }
        this.lastWidth = width;
        this.lastHeight = height;
        this.acceptedSize = false;
        this.resize.emit();
        return true;
    }
    initSize() {
        const size = this.measure();
        this.lastWidth = size.width;
        this.lastHeight = size.height;
    }
    measure() {
        let width = 0;
        let height = 0;
        if (this.parentElement) {
            height = this.parentElement.offsetHeight;
            width = this.parentElement.offsetWidth;
        }
        return { height, width };
    }
}

// tslint:disable:deprecation
const div = style => {
    const el = document.createElement('div');
    el.style.cssText = style;
    return el;
};
const computedProp = (elem, prop) => getComputedStyle(elem, null).getPropertyValue(prop);
const WRAP_STYLE = 'position: absolute; display: block; left: 0; top: 0; right: 0; bottom: 0; z-index: -1;' +
    'overflow: hidden; visibility: hidden;';
const EXPAND_CHILD_STYLE = 'position: absolute; left: 0; top: 0; transition: 0s;';
const SHRINK_CHILD_STYLE = EXPAND_CHILD_STYLE + 'width: 200%; height: 200%;';
class ResizeCompatService extends ResizeService {
    constructor(resizeBatchService, element, ngZone) {
        super(resizeBatchService);
        this.element = element;
        this.ngZone = ngZone;
    }
    checkChanges() {
        if (this.state === 2 /* Initialized */) {
            if (!this.resizeBatchService.isScheduled(this)) {
                this.resizeBatchService.schedule(this, this.checkSize);
            }
            return;
        }
        super.checkChanges();
    }
    destroy() {
        super.destroy();
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        if (this.expand) {
            const element = this.element.nativeElement;
            element.removeChild(this.expand);
            element.removeChild(this.shrink);
            this.expand.removeChild(this.expandChild);
            this.expand = this.expandChild = this.shrink = this.element = null;
        }
    }
    checkSize() {
        if (super.checkSize()) {
            this.reset();
            return true;
        }
    }
    init() {
        const parentElement = this.parentElement = this.element.nativeElement.parentElement;
        if (computedProp(parentElement, 'position') === 'static') {
            parentElement.style.position = 'relative';
        }
        this.state = 2 /* Initialized */;
        this.render();
        this.reset();
        this.initSize();
        this.subscribe();
    }
    render() {
        const element = this.element.nativeElement;
        element.style.cssText = WRAP_STYLE;
        element.setAttribute('dir', 'ltr');
        this.expand = div(WRAP_STYLE);
        this.expandChild = div(EXPAND_CHILD_STYLE);
        this.expand.appendChild(this.expandChild);
        element.appendChild(this.expand);
        this.shrink = div(WRAP_STYLE);
        const shrinkChild = div(SHRINK_CHILD_STYLE);
        this.shrink.appendChild(shrinkChild);
        element.appendChild(this.shrink);
    }
    reset() {
        const expandChild = this.expandChild;
        expandChild.style.width = 100000 + 'px';
        expandChild.style.height = 100000 + 'px';
        const expand = this.expand;
        expand.scrollLeft = 100000;
        expand.scrollTop = 100000;
        const shrink = this.shrink;
        shrink.scrollLeft = 100000;
        shrink.scrollTop = 100000;
    }
    subscribe() {
        this.ngZone.runOutsideAngular(() => {
            this.subscription = merge(fromEvent(this.shrink, 'scroll'), fromEvent(this.expand, 'scroll'))
                .subscribe(() => {
                this.checkSize();
            });
        });
    }
}

const HAS_OBSERVER = typeof ResizeObserver !== 'undefined';
/**
 * @hidden
 */
class ResizeObserverService extends ResizeService {
    constructor(resizeBatchService, element, ngZone) {
        super(resizeBatchService);
        this.element = element;
        this.ngZone = ngZone;
    }
    static supported() {
        return HAS_OBSERVER;
    }
    destroy() {
        super.destroy();
        if (this.resizeObserver) {
            this.resizeObserver.disconnect();
            this.resizeObserver = null;
        }
        this.parentElement = null;
    }
    init() {
        this.parentElement = this.element.nativeElement.parentElement;
        this.initSize();
        this.state = 2 /* Initialized */;
        this.ngZone.runOutsideAngular(() => {
            this.resizeObserver = new ResizeObserver(() => {
                this.checkSize();
            });
            this.resizeObserver.observe(this.parentElement);
        });
    }
}

/* tslint:disable:align */
/**
 * @hidden
 */
class ResizeBatchService {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.scheduled = [];
        this.resolvedPromise = Promise.resolve(null);
        this.flush = this.flush.bind(this);
    }
    schedule(instance, method) {
        this.scheduled.push({ instance, method });
        if (!this.subscription) {
            this.ngZone.runOutsideAngular(() => {
                this.subscription = from(this.resolvedPromise)
                    .subscribe(this.flush);
            });
        }
    }
    isScheduled(instance) {
        return Boolean(this.scheduled.find(item => item.instance === instance));
    }
    cancel(instance) {
        const scheduled = this.scheduled;
        const count = scheduled.length;
        for (let idx = 0; idx < count; idx++) {
            if (scheduled[idx].instance === instance) {
                scheduled.splice(idx, 1);
                if (!scheduled.length) {
                    this.unsubscribe();
                }
                return;
            }
        }
    }
    ngOnDestroy() {
        this.unsubscribe();
    }
    unsubscribe() {
        if (this.subscription) {
            this.subscription.unsubscribe();
            this.subscription = null;
        }
    }
    flush() {
        this.scheduled.forEach(item => {
            item.method.call(item.instance);
        });
        this.scheduled = [];
        this.unsubscribe();
    }
}
ResizeBatchService.ɵfac = function ResizeBatchService_Factory(t) { return new (t || ResizeBatchService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
ResizeBatchService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ResizeBatchService, factory: ResizeBatchService.ɵfac });
/** @nocollapse */
ResizeBatchService.ctorParameters = () => [
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ResizeBatchService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, null); })();

/**
 * Emit up to 10 resize events per second by default.
 * Chosen as a compromise between responsiveness and performance.
 */
const DEFAULT_RATE_LIMIT = 10;
/**
 * Resize Sensor Component
 *
 * Triggers a "resize" event whenever the parent DOM element size changes.
 */
class ResizeSensorComponent {
    constructor(resizeBatchService, element, ngZone) {
        /**
         * The maximum number of resize events to emit per second.
         *
         * Defaults to 10.
         */
        this.rateLimit = DEFAULT_RATE_LIMIT;
        /**
         * Fires when the parent DOM element has been resized.
         */
        this.resize = new EventEmitter();
        const serviceType = ResizeObserverService.supported() ? ResizeObserverService : ResizeCompatService;
        this.resizeService = new serviceType(resizeBatchService, element, ngZone);
        const throttleTime = 1000 / (this.rateLimit || DEFAULT_RATE_LIMIT);
        this.subscription = this.resizeService.resize
            .pipe(auditTime(throttleTime))
            .subscribe(() => {
            if (!this.resizeService.acceptedSize) {
                this.resize.emit();
            }
        });
    }
    ngAfterViewChecked() {
        this.resizeService.checkChanges();
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
        this.resizeService.destroy();
    }
    acceptSize(size) {
        this.resizeService.acceptSize(size);
    }
}
ResizeSensorComponent.ɵfac = function ResizeSensorComponent_Factory(t) { return new (t || ResizeSensorComponent)(ɵngcc0.ɵɵdirectiveInject(ResizeBatchService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ResizeSensorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ResizeSensorComponent, selectors: [["kendo-resize-sensor"]], inputs: { rateLimit: "rateLimit" }, outputs: { resize: "resize" }, decls: 0, vars: 0, template: function ResizeSensorComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
ResizeSensorComponent.ctorParameters = () => [
    { type: ResizeBatchService },
    { type: ElementRef },
    { type: NgZone }
];
ResizeSensorComponent.propDecorators = {
    rateLimit: [{ type: Input }],
    resize: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ResizeSensorComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-resize-sensor',
                template: ''
            }]
    }], function () { return [{ type: ResizeBatchService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { rateLimit: [{
            type: Input
        }], resize: [{
            type: Output
        }] }); })();

const COMPONENT_DIRECTIVES = [ResizeSensorComponent];
/**
 * Resize Sensor module
 */
class ResizeSensorModule {
}
ResizeSensorModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ResizeSensorModule });
ResizeSensorModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ResizeSensorModule_Factory(t) { return new (t || ResizeSensorModule)(); }, providers: [ResizeBatchService] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ResizeSensorModule, { declarations: [ResizeSensorComponent], exports: [ResizeSensorComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ResizeSensorModule, [{
        type: NgModule,
        args: [{
                declarations: [COMPONENT_DIRECTIVES],
                exports: [COMPONENT_DIRECTIVES],
                providers: [ResizeBatchService]
            }]
    }], null, null); })();

class KendoInput {
}

/**
 * Enum with key codes.
 */
var Keys;
(function (Keys) {
    Keys[Keys["Alt"] = 18] = "Alt";
    Keys[Keys["ArrowDown"] = 40] = "ArrowDown";
    Keys[Keys["ArrowLeft"] = 37] = "ArrowLeft";
    Keys[Keys["ArrowRight"] = 39] = "ArrowRight";
    Keys[Keys["ArrowUp"] = 38] = "ArrowUp";
    Keys[Keys["Backspace"] = 8] = "Backspace";
    Keys[Keys["Control"] = 17] = "Control";
    Keys[Keys["Delete"] = 46] = "Delete";
    Keys[Keys["Digit0"] = 48] = "Digit0";
    Keys[Keys["Digit1"] = 49] = "Digit1";
    Keys[Keys["Digit2"] = 50] = "Digit2";
    Keys[Keys["Digit3"] = 51] = "Digit3";
    Keys[Keys["Digit4"] = 52] = "Digit4";
    Keys[Keys["Digit5"] = 53] = "Digit5";
    Keys[Keys["Digit6"] = 54] = "Digit6";
    Keys[Keys["Digit7"] = 55] = "Digit7";
    Keys[Keys["Digit8"] = 56] = "Digit8";
    Keys[Keys["Digit9"] = 57] = "Digit9";
    Keys[Keys["End"] = 35] = "End";
    Keys[Keys["Enter"] = 13] = "Enter";
    Keys[Keys["Escape"] = 27] = "Escape";
    Keys[Keys["F1"] = 112] = "F1";
    Keys[Keys["F2"] = 113] = "F2";
    Keys[Keys["F10"] = 121] = "F10";
    Keys[Keys["Home"] = 36] = "Home";
    Keys[Keys["Insert"] = 45] = "Insert";
    Keys[Keys["KeyA"] = 65] = "KeyA";
    Keys[Keys["KeyB"] = 66] = "KeyB";
    Keys[Keys["KeyC"] = 67] = "KeyC";
    Keys[Keys["KeyD"] = 68] = "KeyD";
    Keys[Keys["KeyE"] = 69] = "KeyE";
    Keys[Keys["KeyF"] = 70] = "KeyF";
    Keys[Keys["KeyG"] = 71] = "KeyG";
    Keys[Keys["KeyH"] = 72] = "KeyH";
    Keys[Keys["KeyI"] = 73] = "KeyI";
    Keys[Keys["KeyJ"] = 74] = "KeyJ";
    Keys[Keys["KeyK"] = 75] = "KeyK";
    Keys[Keys["KeyL"] = 76] = "KeyL";
    Keys[Keys["KeyM"] = 77] = "KeyM";
    Keys[Keys["KeyN"] = 78] = "KeyN";
    Keys[Keys["KeyO"] = 79] = "KeyO";
    Keys[Keys["KeyP"] = 80] = "KeyP";
    Keys[Keys["KeyQ"] = 81] = "KeyQ";
    Keys[Keys["KeyR"] = 82] = "KeyR";
    Keys[Keys["KeyS"] = 83] = "KeyS";
    Keys[Keys["KeyT"] = 84] = "KeyT";
    Keys[Keys["KeyU"] = 85] = "KeyU";
    Keys[Keys["KeyV"] = 86] = "KeyV";
    Keys[Keys["KeyW"] = 87] = "KeyW";
    Keys[Keys["KeyX"] = 88] = "KeyX";
    Keys[Keys["KeyY"] = 89] = "KeyY";
    Keys[Keys["KeyZ"] = 90] = "KeyZ";
    Keys[Keys["NumpadDecimal"] = 110] = "NumpadDecimal";
    Keys[Keys["PageDown"] = 34] = "PageDown";
    Keys[Keys["PageUp"] = 33] = "PageUp";
    Keys[Keys["Shift"] = 16] = "Shift";
    Keys[Keys["Space"] = 32] = "Space";
    Keys[Keys["Tab"] = 9] = "Tab";
})(Keys || (Keys = {}));

/**
 * Generated bundle index. Do not edit.
 */

export { ResizeService, DraggableDirective, DraggableModule, EventsOutsideAngularDirective, EventsModule, ResizeSensorComponent, ResizeBatchService, ResizeCompatService, ResizeObserverService, ResizeSensorModule, KendoInput, isDocumentAvailable, isChanged, anyChanged, hasObservers, guid, Keys };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7OztBQVVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBOERDLHVTQUtDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQVdBOzs7Ozs7OztDQU1EOzs7Ozs7Ozs7MEJBT0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQ0QsdU9BS0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFVQTs7Ozs7Ozs7Q0FNRDs7Ozs7Ozs7MEJBTUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBME9ELHFIQUdDOzs7Ozs7O3VFQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTZDRCxvU0FNQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQVVBOzs7Ozs7Ozs7Q0FPRDs7Ozs7Ozs7OzBCQU9DIiwic291cmNlc0NvbnRlbnQiOlsiLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogQ29weXJpZ2h0IMKpIDIwMjAgUHJvZ3Jlc3MgU29mdHdhcmUgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qIExpY2Vuc2VkIHVuZGVyIGNvbW1lcmNpYWwgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbW9yZSBpbmZvcm1hdGlvblxuKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIE5nWm9uZSwgSW5wdXQsIE91dHB1dCwgTmdNb2R1bGUsIFJlbmRlcmVyMiwgSW5qZWN0YWJsZSwgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgRHJhZ2dhYmxlIGZyb20gJ0B0ZWxlcmlrL2tlbmRvLWRyYWdnYWJsZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgYXVkaXRUaW1lIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgbWVyZ2UsIGZyb21FdmVudCwgZnJvbSB9IGZyb20gJ3J4anMnO1xuXG5jb25zdCBpc0RvY3VtZW50QXZhaWxhYmxlID0gKCkgPT4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuY29uc3QgaXNDaGFuZ2VkID0gKHByb3BlcnR5TmFtZSwgY2hhbmdlcywgc2tpcEZpcnN0Q2hhbmdlID0gdHJ1ZSkgPT4gKHR5cGVvZiBjaGFuZ2VzW3Byb3BlcnR5TmFtZV0gIT09ICd1bmRlZmluZWQnICYmXG4gICAgKCFjaGFuZ2VzW3Byb3BlcnR5TmFtZV0uaXNGaXJzdENoYW5nZSgpIHx8ICFza2lwRmlyc3RDaGFuZ2UpICYmXG4gICAgY2hhbmdlc1twcm9wZXJ0eU5hbWVdLnByZXZpb3VzVmFsdWUgIT09IGNoYW5nZXNbcHJvcGVydHlOYW1lXS5jdXJyZW50VmFsdWUpO1xuXG5jb25zdCBhbnlDaGFuZ2VkID0gKHByb3BlcnR5TmFtZXMsIGNoYW5nZXMsIHNraXBGaXJzdENoYW5nZSA9IHRydWUpID0+IHByb3BlcnR5TmFtZXMuc29tZShuYW1lID0+IGlzQ2hhbmdlZChuYW1lLCBjaGFuZ2VzLCBza2lwRmlyc3RDaGFuZ2UpKTtcblxuY29uc3QgaGFzT2JzZXJ2ZXJzID0gKGVtaXR0ZXIpID0+IGVtaXR0ZXIgJiYgZW1pdHRlci5vYnNlcnZlcnMubGVuZ3RoID4gMDtcblxuY29uc3QgZ3VpZCA9ICgpID0+IHtcbiAgICBsZXQgaWQgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICBjb25zdCByYW5kb20gPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWJpdHdpc2VcbiAgICAgICAgaWYgKGkgPT09IDggfHwgaSA9PT0gMTIgfHwgaSA9PT0gMTYgfHwgaSA9PT0gMjApIHtcbiAgICAgICAgICAgIGlkICs9IFwiLVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXG4gICAgICAgIGlkICs9IChpID09PSAxMiA/IDQgOiAoaSA9PT0gMTYgPyAocmFuZG9tICYgMyB8IDgpIDogcmFuZG9tKSkudG9TdHJpbmcoMTYpO1xuICAgIH1cbiAgICByZXR1cm4gaWQ7XG59O1xuXG5jbGFzcyBEcmFnZ2FibGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG5nWm9uZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5lbmFibGVEcmFnID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5rZW5kb1ByZXNzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmtlbmRvRHJhZyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5rZW5kb1JlbGVhc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnRvZ2dsZURyYWdnYWJsZSgpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChpc0NoYW5nZWQoJ2VuYWJsZURyYWcnLCBjaGFuZ2VzKSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVEcmFnZ2FibGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95RHJhZ2dhYmxlKCk7XG4gICAgfVxuICAgIHRvZ2dsZURyYWdnYWJsZSgpIHtcbiAgICAgICAgaWYgKGlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95RHJhZ2dhYmxlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5lbmFibGVEcmFnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZzogKGUpID0+IHRoaXMua2VuZG9EcmFnLm5leHQoZSksXG4gICAgICAgICAgICAgICAgICAgIHByZXNzOiAoZSkgPT4gdGhpcy5rZW5kb1ByZXNzLm5leHQoZSksXG4gICAgICAgICAgICAgICAgICAgIHJlbGVhc2U6IChlKSA9PiB0aGlzLmtlbmRvUmVsZWFzZS5uZXh0KGUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gdGhpcy5kcmFnZ2FibGUuYmluZFRvKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveURyYWdnYWJsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnYWJsZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5EcmFnZ2FibGVEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0RyYWdnYWJsZV0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkRyYWdnYWJsZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9XG5dO1xuRHJhZ2dhYmxlRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGVuYWJsZURyYWc6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGtlbmRvUHJlc3M6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBrZW5kb0RyYWc6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBrZW5kb1JlbGVhc2U6IFt7IHR5cGU6IE91dHB1dCB9XVxufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIERyYWdnYWJsZU1vZHVsZSB7XG59XG5EcmFnZ2FibGVNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW0RyYWdnYWJsZURpcmVjdGl2ZV0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW0RyYWdnYWJsZURpcmVjdGl2ZV0sXG4gICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuLyogdHNsaW50OmRpc2FibGU6bm8taW5wdXQtcmVuYW1lICovXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRXZlbnRzT3V0c2lkZUFuZ3VsYXJEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG5nWm9uZSwgcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5ldmVudHMgPSB7fTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50IHx8ICF0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBldmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCBuYW1lLCB0aGlzLnNjb3BlID8gZXZlbnRzW25hbWVdLmJpbmQodGhpcy5zY29wZSkgOiBldmVudHNbbmFtZV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnNbaWR4XSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbkV2ZW50c091dHNpZGVBbmd1bGFyRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkV2ZW50c091dHNpZGVBbmd1bGFyRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogTmdab25lIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfVxuXTtcbkV2ZW50c091dHNpZGVBbmd1bGFyRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGV2ZW50czogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsna2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcicsXSB9XSxcbiAgICBzY29wZTogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBFdmVudHNNb2R1bGUge1xufVxuRXZlbnRzTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtFdmVudHNPdXRzaWRlQW5ndWxhckRpcmVjdGl2ZV0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW0V2ZW50c091dHNpZGVBbmd1bGFyRGlyZWN0aXZlXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuXG5jbGFzcyBSZXNpemVTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNpemVCYXRjaFNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5yZXNpemVCYXRjaFNlcnZpY2UgPSByZXNpemVCYXRjaFNlcnZpY2U7XG4gICAgICAgIHRoaXMucmVzaXplID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmFjY2VwdGVkU2l6ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXRlID0gMCAvKiBJbml0aWFsICovO1xuICAgIH1cbiAgICBhY2NlcHRTaXplKHNpemUgPSB0aGlzLm1lYXN1cmUoKSkge1xuICAgICAgICB0aGlzLmxhc3RXaWR0aCA9IHNpemUud2lkdGg7XG4gICAgICAgIHRoaXMubGFzdEhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICB0aGlzLmFjY2VwdGVkU2l6ZSA9IHRydWU7XG4gICAgfVxuICAgIGNoZWNrQ2hhbmdlcygpIHtcbiAgICAgICAgaWYgKCFpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gMCAvKiBJbml0aWFsICovKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMSAvKiBJbml0aWFsaXppbmcgKi87XG4gICAgICAgICAgICAvLyBiYXRjaCBpbml0aWFsIG1lYXN1cmVcbiAgICAgICAgICAgIHRoaXMucmVzaXplQmF0Y2hTZXJ2aWNlLnNjaGVkdWxlKHRoaXMsIHRoaXMuaW5pdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZXNpemVCYXRjaFNlcnZpY2UuY2FuY2VsKHRoaXMpO1xuICAgIH1cbiAgICBjaGVja1NpemUoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLm1lYXN1cmUoKTtcbiAgICAgICAgY29uc3Qgc2FtZVNpemUgPSB3aWR0aCA9PT0gdGhpcy5sYXN0V2lkdGggJiYgaGVpZ2h0ID09PSB0aGlzLmxhc3RIZWlnaHQ7XG4gICAgICAgIGlmIChzYW1lU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFdpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMubGFzdEhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5hY2NlcHRlZFNpemUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXNpemUuZW1pdCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaW5pdFNpemUoKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLm1lYXN1cmUoKTtcbiAgICAgICAgdGhpcy5sYXN0V2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgICB0aGlzLmxhc3RIZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICB9XG4gICAgbWVhc3VyZSgpIHtcbiAgICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgICAgbGV0IGhlaWdodCA9IDA7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMucGFyZW50RWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMucGFyZW50RWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBoZWlnaHQsIHdpZHRoIH07XG4gICAgfVxufVxuXG4vLyB0c2xpbnQ6ZGlzYWJsZTpkZXByZWNhdGlvblxuY29uc3QgZGl2ID0gc3R5bGUgPT4ge1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuc3R5bGUuY3NzVGV4dCA9IHN0eWxlO1xuICAgIHJldHVybiBlbDtcbn07XG5jb25zdCBjb21wdXRlZFByb3AgPSAoZWxlbSwgcHJvcCkgPT4gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApO1xuY29uc3QgV1JBUF9TVFlMRSA9ICdwb3NpdGlvbjogYWJzb2x1dGU7IGRpc3BsYXk6IGJsb2NrOyBsZWZ0OiAwOyB0b3A6IDA7IHJpZ2h0OiAwOyBib3R0b206IDA7IHotaW5kZXg6IC0xOycgK1xuICAgICdvdmVyZmxvdzogaGlkZGVuOyB2aXNpYmlsaXR5OiBoaWRkZW47JztcbmNvbnN0IEVYUEFORF9DSElMRF9TVFlMRSA9ICdwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IDA7IHRvcDogMDsgdHJhbnNpdGlvbjogMHM7JztcbmNvbnN0IFNIUklOS19DSElMRF9TVFlMRSA9IEVYUEFORF9DSElMRF9TVFlMRSArICd3aWR0aDogMjAwJTsgaGVpZ2h0OiAyMDAlOyc7XG5jbGFzcyBSZXNpemVDb21wYXRTZXJ2aWNlIGV4dGVuZHMgUmVzaXplU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IocmVzaXplQmF0Y2hTZXJ2aWNlLCBlbGVtZW50LCBuZ1pvbmUpIHtcbiAgICAgICAgc3VwZXIocmVzaXplQmF0Y2hTZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgfVxuICAgIGNoZWNrQ2hhbmdlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IDIgLyogSW5pdGlhbGl6ZWQgKi8pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZXNpemVCYXRjaFNlcnZpY2UuaXNTY2hlZHVsZWQodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZUJhdGNoU2VydmljZS5zY2hlZHVsZSh0aGlzLCB0aGlzLmNoZWNrU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuY2hlY2tDaGFuZ2VzKCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4cGFuZCkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLmV4cGFuZCk7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuc2hyaW5rKTtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kLnJlbW92ZUNoaWxkKHRoaXMuZXhwYW5kQ2hpbGQpO1xuICAgICAgICAgICAgdGhpcy5leHBhbmQgPSB0aGlzLmV4cGFuZENoaWxkID0gdGhpcy5zaHJpbmsgPSB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrU2l6ZSgpIHtcbiAgICAgICAgaWYgKHN1cGVyLmNoZWNrU2l6ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICBjb25zdCBwYXJlbnRFbGVtZW50ID0gdGhpcy5wYXJlbnRFbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgaWYgKGNvbXB1dGVkUHJvcChwYXJlbnRFbGVtZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICAgIHBhcmVudEVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSAyIC8qIEluaXRpYWxpemVkICovO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuaW5pdFNpemUoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFdSQVBfU1RZTEU7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkaXInLCAnbHRyJyk7XG4gICAgICAgIHRoaXMuZXhwYW5kID0gZGl2KFdSQVBfU1RZTEUpO1xuICAgICAgICB0aGlzLmV4cGFuZENoaWxkID0gZGl2KEVYUEFORF9DSElMRF9TVFlMRSk7XG4gICAgICAgIHRoaXMuZXhwYW5kLmFwcGVuZENoaWxkKHRoaXMuZXhwYW5kQ2hpbGQpO1xuICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuZXhwYW5kKTtcbiAgICAgICAgdGhpcy5zaHJpbmsgPSBkaXYoV1JBUF9TVFlMRSk7XG4gICAgICAgIGNvbnN0IHNocmlua0NoaWxkID0gZGl2KFNIUklOS19DSElMRF9TVFlMRSk7XG4gICAgICAgIHRoaXMuc2hyaW5rLmFwcGVuZENoaWxkKHNocmlua0NoaWxkKTtcbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNocmluayk7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICBjb25zdCBleHBhbmRDaGlsZCA9IHRoaXMuZXhwYW5kQ2hpbGQ7XG4gICAgICAgIGV4cGFuZENoaWxkLnN0eWxlLndpZHRoID0gMTAwMDAwICsgJ3B4JztcbiAgICAgICAgZXhwYW5kQ2hpbGQuc3R5bGUuaGVpZ2h0ID0gMTAwMDAwICsgJ3B4JztcbiAgICAgICAgY29uc3QgZXhwYW5kID0gdGhpcy5leHBhbmQ7XG4gICAgICAgIGV4cGFuZC5zY3JvbGxMZWZ0ID0gMTAwMDAwO1xuICAgICAgICBleHBhbmQuc2Nyb2xsVG9wID0gMTAwMDAwO1xuICAgICAgICBjb25zdCBzaHJpbmsgPSB0aGlzLnNocmluaztcbiAgICAgICAgc2hyaW5rLnNjcm9sbExlZnQgPSAxMDAwMDA7XG4gICAgICAgIHNocmluay5zY3JvbGxUb3AgPSAxMDAwMDA7XG4gICAgfVxuICAgIHN1YnNjcmliZSgpIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSBtZXJnZShmcm9tRXZlbnQodGhpcy5zaHJpbmssICdzY3JvbGwnKSwgZnJvbUV2ZW50KHRoaXMuZXhwYW5kLCAnc2Nyb2xsJykpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1NpemUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNvbnN0IEhBU19PQlNFUlZFUiA9IHR5cGVvZiBSZXNpemVPYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUmVzaXplT2JzZXJ2ZXJTZXJ2aWNlIGV4dGVuZHMgUmVzaXplU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IocmVzaXplQmF0Y2hTZXJ2aWNlLCBlbGVtZW50LCBuZ1pvbmUpIHtcbiAgICAgICAgc3VwZXIocmVzaXplQmF0Y2hTZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgfVxuICAgIHN0YXRpYyBzdXBwb3J0ZWQoKSB7XG4gICAgICAgIHJldHVybiBIQVNfT0JTRVJWRVI7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMucmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJlbnRFbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRFbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgdGhpcy5pbml0U2l6ZSgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gMiAvKiBJbml0aWFsaXplZCAqLztcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1NpemUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMucGFyZW50RWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyogdHNsaW50OmRpc2FibGU6YWxpZ24gKi9cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBSZXNpemVCYXRjaFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKG5nWm9uZSkge1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWQgPSBbXTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIHRoaXMuZmx1c2ggPSB0aGlzLmZsdXNoLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIHNjaGVkdWxlKGluc3RhbmNlLCBtZXRob2QpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWQucHVzaCh7IGluc3RhbmNlLCBtZXRob2QgfSk7XG4gICAgICAgIGlmICghdGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IGZyb20odGhpcy5yZXNvbHZlZFByb21pc2UpXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5mbHVzaCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1NjaGVkdWxlZChpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnNjaGVkdWxlZC5maW5kKGl0ZW0gPT4gaXRlbS5pbnN0YW5jZSA9PT0gaW5zdGFuY2UpKTtcbiAgICB9XG4gICAgY2FuY2VsKGluc3RhbmNlKSB7XG4gICAgICAgIGNvbnN0IHNjaGVkdWxlZCA9IHRoaXMuc2NoZWR1bGVkO1xuICAgICAgICBjb25zdCBjb3VudCA9IHNjaGVkdWxlZC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGNvdW50OyBpZHgrKykge1xuICAgICAgICAgICAgaWYgKHNjaGVkdWxlZFtpZHhdLmluc3RhbmNlID09PSBpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlZC5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNjaGVkdWxlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaCgpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWQuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGl0ZW0ubWV0aG9kLmNhbGwoaXRlbS5pbnN0YW5jZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNjaGVkdWxlZCA9IFtdO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxufVxuUmVzaXplQmF0Y2hTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5SZXNpemVCYXRjaFNlcnZpY2UuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOZ1pvbmUgfVxuXTtcblxuLyoqXG4gKiBFbWl0IHVwIHRvIDEwIHJlc2l6ZSBldmVudHMgcGVyIHNlY29uZCBieSBkZWZhdWx0LlxuICogQ2hvc2VuIGFzIGEgY29tcHJvbWlzZSBiZXR3ZWVuIHJlc3BvbnNpdmVuZXNzIGFuZCBwZXJmb3JtYW5jZS5cbiAqL1xuY29uc3QgREVGQVVMVF9SQVRFX0xJTUlUID0gMTA7XG4vKipcbiAqIFJlc2l6ZSBTZW5zb3IgQ29tcG9uZW50XG4gKlxuICogVHJpZ2dlcnMgYSBcInJlc2l6ZVwiIGV2ZW50IHdoZW5ldmVyIHRoZSBwYXJlbnQgRE9NIGVsZW1lbnQgc2l6ZSBjaGFuZ2VzLlxuICovXG5jbGFzcyBSZXNpemVTZW5zb3JDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHJlc2l6ZUJhdGNoU2VydmljZSwgZWxlbWVudCwgbmdab25lKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmVzaXplIGV2ZW50cyB0byBlbWl0IHBlciBzZWNvbmQuXG4gICAgICAgICAqXG4gICAgICAgICAqIERlZmF1bHRzIHRvIDEwLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYXRlTGltaXQgPSBERUZBVUxUX1JBVEVfTElNSVQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBwYXJlbnQgRE9NIGVsZW1lbnQgaGFzIGJlZW4gcmVzaXplZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzaXplID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBjb25zdCBzZXJ2aWNlVHlwZSA9IFJlc2l6ZU9ic2VydmVyU2VydmljZS5zdXBwb3J0ZWQoKSA/IFJlc2l6ZU9ic2VydmVyU2VydmljZSA6IFJlc2l6ZUNvbXBhdFNlcnZpY2U7XG4gICAgICAgIHRoaXMucmVzaXplU2VydmljZSA9IG5ldyBzZXJ2aWNlVHlwZShyZXNpemVCYXRjaFNlcnZpY2UsIGVsZW1lbnQsIG5nWm9uZSk7XG4gICAgICAgIGNvbnN0IHRocm90dGxlVGltZSA9IDEwMDAgLyAodGhpcy5yYXRlTGltaXQgfHwgREVGQVVMVF9SQVRFX0xJTUlUKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLnJlc2l6ZVNlcnZpY2UucmVzaXplXG4gICAgICAgICAgICAucGlwZShhdWRpdFRpbWUodGhyb3R0bGVUaW1lKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlc2l6ZVNlcnZpY2UuYWNjZXB0ZWRTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemUuZW1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCkge1xuICAgICAgICB0aGlzLnJlc2l6ZVNlcnZpY2UuY2hlY2tDaGFuZ2VzKCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnJlc2l6ZVNlcnZpY2UuZGVzdHJveSgpO1xuICAgIH1cbiAgICBhY2NlcHRTaXplKHNpemUpIHtcbiAgICAgICAgdGhpcy5yZXNpemVTZXJ2aWNlLmFjY2VwdFNpemUoc2l6ZSk7XG4gICAgfVxufVxuUmVzaXplU2Vuc29yQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1yZXNpemUtc2Vuc29yJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuUmVzaXplU2Vuc29yQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogUmVzaXplQmF0Y2hTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUgfVxuXTtcblJlc2l6ZVNlbnNvckNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICByYXRlTGltaXQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHJlc2l6ZTogW3sgdHlwZTogT3V0cHV0IH1dXG59O1xuXG5jb25zdCBDT01QT05FTlRfRElSRUNUSVZFUyA9IFtSZXNpemVTZW5zb3JDb21wb25lbnRdO1xuLyoqXG4gKiBSZXNpemUgU2Vuc29yIG1vZHVsZVxuICovXG5jbGFzcyBSZXNpemVTZW5zb3JNb2R1bGUge1xufVxuUmVzaXplU2Vuc29yTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtDT01QT05FTlRfRElSRUNUSVZFU10sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW0NPTVBPTkVOVF9ESVJFQ1RJVkVTXSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtSZXNpemVCYXRjaFNlcnZpY2VdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5cbmNsYXNzIEtlbmRvSW5wdXQge1xufVxuXG4vKipcbiAqIEVudW0gd2l0aCBrZXkgY29kZXMuXG4gKi9cbnZhciBLZXlzO1xuKGZ1bmN0aW9uIChLZXlzKSB7XG4gICAgS2V5c1tLZXlzW1wiQWx0XCJdID0gMThdID0gXCJBbHRcIjtcbiAgICBLZXlzW0tleXNbXCJBcnJvd0Rvd25cIl0gPSA0MF0gPSBcIkFycm93RG93blwiO1xuICAgIEtleXNbS2V5c1tcIkFycm93TGVmdFwiXSA9IDM3XSA9IFwiQXJyb3dMZWZ0XCI7XG4gICAgS2V5c1tLZXlzW1wiQXJyb3dSaWdodFwiXSA9IDM5XSA9IFwiQXJyb3dSaWdodFwiO1xuICAgIEtleXNbS2V5c1tcIkFycm93VXBcIl0gPSAzOF0gPSBcIkFycm93VXBcIjtcbiAgICBLZXlzW0tleXNbXCJCYWNrc3BhY2VcIl0gPSA4XSA9IFwiQmFja3NwYWNlXCI7XG4gICAgS2V5c1tLZXlzW1wiQ29udHJvbFwiXSA9IDE3XSA9IFwiQ29udHJvbFwiO1xuICAgIEtleXNbS2V5c1tcIkRlbGV0ZVwiXSA9IDQ2XSA9IFwiRGVsZXRlXCI7XG4gICAgS2V5c1tLZXlzW1wiRGlnaXQwXCJdID0gNDhdID0gXCJEaWdpdDBcIjtcbiAgICBLZXlzW0tleXNbXCJEaWdpdDFcIl0gPSA0OV0gPSBcIkRpZ2l0MVwiO1xuICAgIEtleXNbS2V5c1tcIkRpZ2l0MlwiXSA9IDUwXSA9IFwiRGlnaXQyXCI7XG4gICAgS2V5c1tLZXlzW1wiRGlnaXQzXCJdID0gNTFdID0gXCJEaWdpdDNcIjtcbiAgICBLZXlzW0tleXNbXCJEaWdpdDRcIl0gPSA1Ml0gPSBcIkRpZ2l0NFwiO1xuICAgIEtleXNbS2V5c1tcIkRpZ2l0NVwiXSA9IDUzXSA9IFwiRGlnaXQ1XCI7XG4gICAgS2V5c1tLZXlzW1wiRGlnaXQ2XCJdID0gNTRdID0gXCJEaWdpdDZcIjtcbiAgICBLZXlzW0tleXNbXCJEaWdpdDdcIl0gPSA1NV0gPSBcIkRpZ2l0N1wiO1xuICAgIEtleXNbS2V5c1tcIkRpZ2l0OFwiXSA9IDU2XSA9IFwiRGlnaXQ4XCI7XG4gICAgS2V5c1tLZXlzW1wiRGlnaXQ5XCJdID0gNTddID0gXCJEaWdpdDlcIjtcbiAgICBLZXlzW0tleXNbXCJFbmRcIl0gPSAzNV0gPSBcIkVuZFwiO1xuICAgIEtleXNbS2V5c1tcIkVudGVyXCJdID0gMTNdID0gXCJFbnRlclwiO1xuICAgIEtleXNbS2V5c1tcIkVzY2FwZVwiXSA9IDI3XSA9IFwiRXNjYXBlXCI7XG4gICAgS2V5c1tLZXlzW1wiRjFcIl0gPSAxMTJdID0gXCJGMVwiO1xuICAgIEtleXNbS2V5c1tcIkYyXCJdID0gMTEzXSA9IFwiRjJcIjtcbiAgICBLZXlzW0tleXNbXCJGMTBcIl0gPSAxMjFdID0gXCJGMTBcIjtcbiAgICBLZXlzW0tleXNbXCJIb21lXCJdID0gMzZdID0gXCJIb21lXCI7XG4gICAgS2V5c1tLZXlzW1wiSW5zZXJ0XCJdID0gNDVdID0gXCJJbnNlcnRcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlBXCJdID0gNjVdID0gXCJLZXlBXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5QlwiXSA9IDY2XSA9IFwiS2V5QlwiO1xuICAgIEtleXNbS2V5c1tcIktleUNcIl0gPSA2N10gPSBcIktleUNcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlEXCJdID0gNjhdID0gXCJLZXlEXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5RVwiXSA9IDY5XSA9IFwiS2V5RVwiO1xuICAgIEtleXNbS2V5c1tcIktleUZcIl0gPSA3MF0gPSBcIktleUZcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlHXCJdID0gNzFdID0gXCJLZXlHXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5SFwiXSA9IDcyXSA9IFwiS2V5SFwiO1xuICAgIEtleXNbS2V5c1tcIktleUlcIl0gPSA3M10gPSBcIktleUlcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlKXCJdID0gNzRdID0gXCJLZXlKXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5S1wiXSA9IDc1XSA9IFwiS2V5S1wiO1xuICAgIEtleXNbS2V5c1tcIktleUxcIl0gPSA3Nl0gPSBcIktleUxcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlNXCJdID0gNzddID0gXCJLZXlNXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5TlwiXSA9IDc4XSA9IFwiS2V5TlwiO1xuICAgIEtleXNbS2V5c1tcIktleU9cIl0gPSA3OV0gPSBcIktleU9cIjtcbiAgICBLZXlzW0tleXNbXCJLZXlQXCJdID0gODBdID0gXCJLZXlQXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5UVwiXSA9IDgxXSA9IFwiS2V5UVwiO1xuICAgIEtleXNbS2V5c1tcIktleVJcIl0gPSA4Ml0gPSBcIktleVJcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlTXCJdID0gODNdID0gXCJLZXlTXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5VFwiXSA9IDg0XSA9IFwiS2V5VFwiO1xuICAgIEtleXNbS2V5c1tcIktleVVcIl0gPSA4NV0gPSBcIktleVVcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlWXCJdID0gODZdID0gXCJLZXlWXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5V1wiXSA9IDg3XSA9IFwiS2V5V1wiO1xuICAgIEtleXNbS2V5c1tcIktleVhcIl0gPSA4OF0gPSBcIktleVhcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlZXCJdID0gODldID0gXCJLZXlZXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5WlwiXSA9IDkwXSA9IFwiS2V5WlwiO1xuICAgIEtleXNbS2V5c1tcIk51bXBhZERlY2ltYWxcIl0gPSAxMTBdID0gXCJOdW1wYWREZWNpbWFsXCI7XG4gICAgS2V5c1tLZXlzW1wiUGFnZURvd25cIl0gPSAzNF0gPSBcIlBhZ2VEb3duXCI7XG4gICAgS2V5c1tLZXlzW1wiUGFnZVVwXCJdID0gMzNdID0gXCJQYWdlVXBcIjtcbiAgICBLZXlzW0tleXNbXCJTaGlmdFwiXSA9IDE2XSA9IFwiU2hpZnRcIjtcbiAgICBLZXlzW0tleXNbXCJTcGFjZVwiXSA9IDMyXSA9IFwiU3BhY2VcIjtcbiAgICBLZXlzW0tleXNbXCJUYWJcIl0gPSA5XSA9IFwiVGFiXCI7XG59KShLZXlzIHx8IChLZXlzID0ge30pKTtcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBSZXNpemVTZXJ2aWNlLCBEcmFnZ2FibGVEaXJlY3RpdmUsIERyYWdnYWJsZU1vZHVsZSwgRXZlbnRzT3V0c2lkZUFuZ3VsYXJEaXJlY3RpdmUsIEV2ZW50c01vZHVsZSwgUmVzaXplU2Vuc29yQ29tcG9uZW50LCBSZXNpemVCYXRjaFNlcnZpY2UsIFJlc2l6ZUNvbXBhdFNlcnZpY2UsIFJlc2l6ZU9ic2VydmVyU2VydmljZSwgUmVzaXplU2Vuc29yTW9kdWxlLCBLZW5kb0lucHV0LCBpc0RvY3VtZW50QXZhaWxhYmxlLCBpc0NoYW5nZWQsIGFueUNoYW5nZWQsIGhhc09ic2VydmVycywgZ3VpZCwgS2V5cyB9O1xuIl19