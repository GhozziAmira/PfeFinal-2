/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Input, ContentChildren, QueryList, Component, NgZone, Directive, TemplateRef, Optional, forwardRef, SkipSelf, Host, ContentChild, NgModule } from '@angular/core';
import { saveAs } from '@progress/kendo-file-saver';
import { IntlService, ExcelExporter, Workbook } from '@progress/kendo-ooxml';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@progress/kendo-angular-l10n';
export * from '@progress/kendo-ooxml';
import { toString } from '@telerik/kendo-intl';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';

/* tslint:disable align */
/* tslint:disable:no-use-before-declare */
const compileTemplate = (templateRef, context, updateContext) => {
    let embeddedView = templateRef.createEmbeddedView(context);
    const result = (data) => {
        updateContext(context, data);
        embeddedView.detectChanges();
        return embeddedView.rootNodes.reduce((content, rootNode) => {
            return content + rootNode.textContent;
        }, '').trim();
    };
    result.destroy = () => {
        embeddedView.destroy();
        embeddedView = null;
    };
    return result;
};
const updateGroupHeaderContext = (context, data) => {
    context.$implicit = context.group = data;
    context.field = data.field;
    context.value = data.value;
    context.aggregates = data.aggregates;
};
const updateGroupFooterContext = (context, data) => {
    context.group = data.group;
    context.$implicit = context.aggregates = data;
};
const updateFooterContext = (context, data) => {
    context.aggregates = data.aggregates;
};
/**
 * @hidden
 */
const toExporterColumns = (sourceColumns) => {
    const exporterColumns = [];
    let columnIndex = 0;
    const addColumns = (columns, result, level) => {
        columns.forEach((column) => {
            if (column.level === level) {
                const exporterColumn = new ExporterColumn(column, columnIndex);
                result.push(exporterColumn);
                if (column.children && column.children.some(c => c !== column)) {
                    const children = exporterColumn.columns = [];
                    addColumns(column.children, children, level + 1);
                }
                else {
                    columnIndex++;
                }
            }
        });
    };
    addColumns(sourceColumns, exporterColumns, 0);
    return exporterColumns;
};
/**
 * @hidden
 */
const destroyColumns = (columns) => {
    if (columns) {
        columns.forEach(column => {
            column.destroy();
        });
    }
};
/**
 * @hidden
 */
class ExporterColumn {
    constructor(column, columnIndex) {
        this.title = column.title;
        this.field = column.field;
        this.hidden = column.hidden;
        this.locked = column.locked;
        this.width = column.width;
        this.headerCellOptions = column.headerCellOptions;
        this.cellOptions = column.cellOptions;
        this.groupHeaderCellOptions = column.groupHeaderCellOptions;
        this.groupFooterCellOptions = column.groupFooterCellOptions;
        this.footerCellOptions = column.footerCellOptions;
        if (column.footerTemplate) {
            this.footerTemplate = compileTemplate(column.footerTemplate.templateRef, {
                $implicit: column,
                column: column,
                columnIndex: columnIndex
            }, updateFooterContext);
        }
        if (column.groupFooterTemplate) {
            this.groupFooterTemplate = compileTemplate(column.groupFooterTemplate.templateRef, {
                column: column,
                field: column.field
            }, updateGroupFooterContext);
        }
        if (column.groupHeaderTemplate) {
            this.groupHeaderTemplate = compileTemplate(column.groupHeaderTemplate.templateRef, {}, updateGroupHeaderContext);
        }
        if (column.groupHeaderColumnTemplate) {
            this.groupHeaderColumnTemplate = compileTemplate(column.groupHeaderColumnTemplate.templateRef, {}, updateGroupHeaderContext);
        }
    }
    destroy() {
        if (this.footerTemplate) {
            this.footerTemplate.destroy();
        }
        if (this.groupFooterTemplate) {
            this.groupFooterTemplate.destroy();
        }
        if (this.groupHeaderTemplate) {
            this.groupHeaderTemplate.destroy();
        }
        if (this.groupHeaderColumnTemplate) {
            this.groupHeaderColumnTemplate.destroy();
        }
        destroyColumns(this.columns);
    }
}

IntlService.register({ toString });
/**
 *
 * @hidden
 */
const workbookOptions = (options) => {
    const columns = toExporterColumns(options.columns);
    const exporter = new ExcelExporter({
        columns: columns,
        data: options.data,
        filterable: options.filterable,
        groups: options.group,
        paddingCellOptions: options.paddingCellOptions,
        headerPaddingCellOptions: options.headerPaddingCellOptions,
        collapsible: options.collapsible,
        hierarchy: options.hierarchy,
        aggregates: options.aggregates
    });
    const result = exporter.workbook();
    result.creator = options.creator;
    result.date = options.date;
    result.rtl = options.rtl;
    destroyColumns(columns);
    return result;
};
/**
 * @hidden
 */
const toDataURL = (options) => {
    const workbook = new Workbook(options);
    return workbook.toDataURL();
};
/**
 * @hidden
 */
const isWorkbookOptions = (value) => {
    return value && value.sheets;
};

/**
 * @hidden
 */
class ColumnBase {
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * @hidden
     */
    get level() {
        return this.parent ? this.parent.level + 1 : 0;
    }
}
ColumnBase.ɵfac = function ColumnBase_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
ColumnBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ColumnBase, contentQueries: function ColumnBase_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnBase, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, inputs: { title: "title", width: "width", locked: "locked", hidden: "hidden", headerCellOptions: "headerCellOptions" } });
ColumnBase.propDecorators = {
    title: [{ type: Input }],
    width: [{ type: Input }],
    locked: [{ type: Input }],
    hidden: [{ type: Input }],
    headerCellOptions: [{ type: Input }],
    children: [{ type: ContentChildren, args: [ColumnBase,] }]
};


// tslint:disable:max-line-length
/**
 * Represents the [Kendo UI Excel Export component for Angular]({% slug overview_excelexport %}).
 * Configures the settings for the Excel export of the Kendo UI Grid.
 */
class ExcelExportComponent {
    constructor(localization, zone) {
        this.localization = localization;
        this.zone = zone;
        /**
         * Specifies the name of the file that is exported to Excel.
         * @default "Export.xlsx"
         */
        this.fileName = 'Export.xlsx';
        /**
         * @hidden
         */
        this.columns = new QueryList();
        this.saveFile = this.saveFile.bind(this);
    }
    /**
     * Saves the data to Excel.
     *
     * @param exportData - An optional parameter. Can be the data that will be exported or [`WorkbookOptions`]({% slug api_excel-export_workbookoptions %}).
     */
    save(exportData) {
        this.toDataURL(exportData).then(this.saveFile);
    }
    /**
     * Based on the specified columns and data, returns
     * [`WorkbookOptions`]({% slug api_excel-export_workbookoptions %})
     * ([see example]({% slug customrowsandcells_excelexport %})).
     *
     * @param exportData - The optional data to be exported.
     * @returns {WorkbookOptions} - The workbook options.
     */
    workbookOptions(exportData) {
        const currentData = this.getExportData(exportData);
        const options = workbookOptions({
            columns: this.columns,
            data: currentData.data,
            group: currentData.group,
            filterable: this.filterable,
            creator: this.creator,
            date: this.date,
            rtl: this.localization.rtl,
            paddingCellOptions: this.paddingCellOptions,
            headerPaddingCellOptions: this.headerPaddingCellOptions,
            collapsible: this.collapsible
        });
        return options;
    }
    /**
     * Returns a promise which will be resolved with the file data URI
     * ([see example]({% slug filesaving_excelexport %})).
     *
     * @param exportData - The optional data or [`WorkbookOptions`]({% slug api_excel-export_workbookoptions %}) that will be used to generate the data URI.
     * @returns {Promise<string>} - The promise that will be resolved by the file data URI.
     */
    toDataURL(exportData) {
        const options = isWorkbookOptions(exportData) ?
            exportData :
            this.workbookOptions(exportData);
        return this.zone.runOutsideAngular(() => toDataURL(options));
    }
    getExportData(exportData) {
        let result;
        if (exportData) {
            if (Array.isArray(exportData)) {
                result = {
                    data: exportData
                };
            }
            else {
                result = exportData;
            }
        }
        else {
            result = {
                data: this.data,
                group: this.group
            };
        }
        return result;
    }
    saveFile(dataURL) {
        saveAs(dataURL, this.fileName, {
            forceProxy: this.forceProxy,
            proxyURL: this.proxyURL
        });
    }
}
ExcelExportComponent.ɵfac = function ExcelExportComponent_Factory(t) { return new (t || ExcelExportComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ExcelExportComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ExcelExportComponent, selectors: [["kendo-excelexport"]], contentQueries: function ExcelExportComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnBase, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columns = _t);
    } }, inputs: { fileName: "fileName", filterable: "filterable", collapsible: "collapsible", creator: "creator", date: "date", forceProxy: "forceProxy", proxyURL: "proxyURL", data: "data", group: "group", paddingCellOptions: "paddingCellOptions", headerPaddingCellOptions: "headerPaddingCellOptions" }, exportAs: ["kendoExcelExport"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.excelexport'
            }
        ])], decls: 0, vars: 0, template: function ExcelExportComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
ExcelExportComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: NgZone }
];
ExcelExportComponent.propDecorators = {
    fileName: [{ type: Input }],
    filterable: [{ type: Input }],
    collapsible: [{ type: Input }],
    creator: [{ type: Input }],
    date: [{ type: Input }],
    forceProxy: [{ type: Input }],
    proxyURL: [{ type: Input }],
    data: [{ type: Input }],
    group: [{ type: Input }],
    paddingCellOptions: [{ type: Input }],
    headerPaddingCellOptions: [{ type: Input }],
    columns: [{ type: ContentChildren, args: [ColumnBase, { descendants: true },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ExcelExportComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoExcelExport',
                selector: 'kendo-excelexport',
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.excelexport'
                    }
                ],
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ɵngcc0.NgZone }]; }, { fileName: [{
            type: Input
        }], columns: [{
            type: ContentChildren,
            args: [ColumnBase, { descendants: true }]
        }], filterable: [{
            type: Input
        }], collapsible: [{
            type: Input
        }], creator: [{
            type: Input
        }], date: [{
            type: Input
        }], forceProxy: [{
            type: Input
        }], proxyURL: [{
            type: Input
        }], data: [{
            type: Input
        }], group: [{
            type: Input
        }], paddingCellOptions: [{
            type: Input
        }], headerPaddingCellOptions: [{
            type: Input
        }] }); })();

/**
 * Represents the group header cell template of the Excel Export column component
 * ([see example]({% slug columns_excel-export %}#toc-group-header-template)).
 * Enables you to customize the content of the group header item.
 */
class GroupHeaderTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
GroupHeaderTemplateDirective.ɵfac = function GroupHeaderTemplateDirective_Factory(t) { return new (t || GroupHeaderTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
GroupHeaderTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: GroupHeaderTemplateDirective, selectors: [["", "kendoExcelExportGroupHeaderTemplate", ""]] });
/** @nocollapse */
GroupHeaderTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GroupHeaderTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoExcelExportGroupHeaderTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents the group header column template of the Excel Export column component
 * ([see example]({% slug columns_excel-export %}#toc-group-header-column-template)).
 */
class GroupHeaderColumnTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
GroupHeaderColumnTemplateDirective.ɵfac = function GroupHeaderColumnTemplateDirective_Factory(t) { return new (t || GroupHeaderColumnTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
GroupHeaderColumnTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: GroupHeaderColumnTemplateDirective, selectors: [["", "kendoExcelExportGroupHeaderColumnTemplate", ""]] });
/** @nocollapse */
GroupHeaderColumnTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GroupHeaderColumnTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoExcelExportGroupHeaderColumnTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents the group footer cell template of the Excel Export column component
 * ([see example]({% slug columns_excel-export %}#toc-group-footer-template)).
 * Enables you to customize the group footer cell of the column.
 */
class GroupFooterTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
GroupFooterTemplateDirective.ɵfac = function GroupFooterTemplateDirective_Factory(t) { return new (t || GroupFooterTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
GroupFooterTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: GroupFooterTemplateDirective, selectors: [["", "kendoExcelExportGroupFooterTemplate", ""]] });
/** @nocollapse */
GroupFooterTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GroupFooterTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoExcelExportGroupFooterTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents the footer cell template of the Excel Export column component
 * ([see example]({% slug columns_excel-export %}#toc-footer-template)).
 * Enables you to customize the footer cell of the column.
 */
class FooterTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
FooterTemplateDirective.ɵfac = function FooterTemplateDirective_Factory(t) { return new (t || FooterTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
FooterTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FooterTemplateDirective, selectors: [["", "kendoExcelExportFooterTemplate", ""]] });
/** @nocollapse */
FooterTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FooterTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoExcelExportFooterTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents the columns of the Kendo UI Excel Export component for Angular.
 */
class ColumnComponent extends ColumnBase {
    constructor(parent) {
        super(parent);
    }
}
ColumnComponent.ɵfac = function ColumnComponent_Factory(t) { return new (t || ColumnComponent)(ɵngcc0.ɵɵdirectiveInject(ColumnBase, 13)); };
ColumnComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColumnComponent, selectors: [["kendo-excelexport-column"]], contentQueries: function ColumnComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, GroupHeaderTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, GroupHeaderColumnTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, GroupFooterTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupHeaderTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupHeaderColumnTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupFooterTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
    } }, inputs: { field: "field", cellOptions: "cellOptions", groupHeaderCellOptions: "groupHeaderCellOptions", groupFooterCellOptions: "groupFooterCellOptions", footerCellOptions: "footerCellOptions" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: ColumnBase,
                useExisting: forwardRef(() => ColumnComponent) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ColumnComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
ColumnComponent.ctorParameters = () => [
    { type: ColumnBase, decorators: [{ type: SkipSelf }, { type: Host }, { type: Optional }] }
];
ColumnComponent.propDecorators = {
    field: [{ type: Input }],
    cellOptions: [{ type: Input }],
    groupHeaderCellOptions: [{ type: Input }],
    groupFooterCellOptions: [{ type: Input }],
    footerCellOptions: [{ type: Input }],
    groupHeaderTemplate: [{ type: ContentChild, args: [GroupHeaderTemplateDirective,] }],
    groupHeaderColumnTemplate: [{ type: ContentChild, args: [GroupHeaderColumnTemplateDirective,] }],
    groupFooterTemplate: [{ type: ContentChild, args: [GroupFooterTemplateDirective,] }],
    footerTemplate: [{ type: ContentChild, args: [FooterTemplateDirective,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: ColumnBase,
                        useExisting: forwardRef(() => ColumnComponent) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-excelexport-column',
                template: ``
            }]
    }], function () { return [{ type: ColumnBase, decorators: [{
                type: SkipSelf
            }, {
                type: Host
            }, {
                type: Optional
            }] }]; }, { field: [{
            type: Input
        }], cellOptions: [{
            type: Input
        }], groupHeaderCellOptions: [{
            type: Input
        }], groupFooterCellOptions: [{
            type: Input
        }], footerCellOptions: [{
            type: Input
        }], groupHeaderTemplate: [{
            type: ContentChild,
            args: [GroupHeaderTemplateDirective]
        }], groupHeaderColumnTemplate: [{
            type: ContentChild,
            args: [GroupHeaderColumnTemplateDirective]
        }], groupFooterTemplate: [{
            type: ContentChild,
            args: [GroupFooterTemplateDirective]
        }], footerTemplate: [{
            type: ContentChild,
            args: [FooterTemplateDirective]
        }] }); })();

/**
 * Represents the column group component of the Kendo UI Excel Export component.
 */
class ColumnGroupComponent extends ColumnBase {
    constructor(parent) {
        super(parent);
        this.parent = parent;
    }
}
ColumnGroupComponent.ɵfac = function ColumnGroupComponent_Factory(t) { return new (t || ColumnGroupComponent)(ɵngcc0.ɵɵdirectiveInject(ColumnBase, 13)); };
ColumnGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColumnGroupComponent, selectors: [["kendo-excelexport-column-group"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: ColumnBase,
                useExisting: forwardRef(() => ColumnGroupComponent) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ColumnGroupComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
ColumnGroupComponent.ctorParameters = () => [
    { type: ColumnBase, decorators: [{ type: SkipSelf }, { type: Host }, { type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnGroupComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: ColumnBase,
                        useExisting: forwardRef(() => ColumnGroupComponent) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-excelexport-column-group',
                template: ``
            }]
    }], function () { return [{ type: ColumnBase, decorators: [{
                type: SkipSelf
            }, {
                type: Host
            }, {
                type: Optional
            }] }]; }, null); })();

const declarations = [
    ExcelExportComponent,
    ColumnComponent,
    ColumnGroupComponent,
    FooterTemplateDirective,
    GroupFooterTemplateDirective,
    GroupHeaderTemplateDirective,
    GroupHeaderColumnTemplateDirective
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Excel Export component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the ExcelExportModule module
 * import { ExcelExportModule } from '@progress/kendo-angular-excel-export';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, ExcelExportModule], // import ExcelExportModule module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class ExcelExportModule {
}
ExcelExportModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ExcelExportModule });
ExcelExportModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ExcelExportModule_Factory(t) { return new (t || ExcelExportModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ExcelExportModule, { declarations: [ExcelExportComponent,
        ColumnComponent,
        ColumnGroupComponent,
        FooterTemplateDirective,
        GroupFooterTemplateDirective,
        GroupHeaderTemplateDirective,
        GroupHeaderColumnTemplateDirective], exports: [ExcelExportComponent,
        ColumnComponent,
        ColumnGroupComponent,
        FooterTemplateDirective,
        GroupFooterTemplateDirective,
        GroupHeaderTemplateDirective,
        GroupHeaderColumnTemplateDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ExcelExportModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations],
                exports: [declarations]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { GroupHeaderColumnTemplateDirective, ExcelExportComponent, ExcelExportModule, ColumnBase, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective, GroupFooterTemplateDirective, GroupHeaderTemplateDirective, workbookOptions, toDataURL, isWorkbookOptions };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7QUFPQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUlBNEtDOzs7Ozs7Ozs7QUFRQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTZGRCxrSEFjQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBbUJBOzs7Ozs7Ozs7Ozs7O0NBV0Qsa0tBS0M7Ozs7Ozs7Ozs7OztrQ0FJQTs7Ozs7Ozs7Ozs7O0NBVUQsb0xBS0M7Ozs7Ozs7Ozs7OztrQ0FJQTs7Ozs7Ozs7Ozs7OztDQVdELGtLQUtDOzs7Ozs7Ozs7Ozs7a0NBSUE7Ozs7Ozs7Ozs7Ozs7Q0FXRCxtSkFLQzs7Ozs7Ozs7Ozs7O2tDQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FTRCxnSkFZQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBZUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBVUQscUpBWUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EyQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQU1DIiwic291cmNlc0NvbnRlbnQiOlsiLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogQ29weXJpZ2h0IMKpIDIwMjAgUHJvZ3Jlc3MgU29mdHdhcmUgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qIExpY2Vuc2VkIHVuZGVyIGNvbW1lcmNpYWwgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbW9yZSBpbmZvcm1hdGlvblxuKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgSW5wdXQsIENvbnRlbnRDaGlsZHJlbiwgUXVlcnlMaXN0LCBDb21wb25lbnQsIE5nWm9uZSwgRGlyZWN0aXZlLCBUZW1wbGF0ZVJlZiwgT3B0aW9uYWwsIGZvcndhcmRSZWYsIFNraXBTZWxmLCBIb3N0LCBDb250ZW50Q2hpbGQsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBzYXZlQXMgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tZmlsZS1zYXZlcic7XG5pbXBvcnQgeyBJbnRsU2VydmljZSwgRXhjZWxFeHBvcnRlciwgV29ya2Jvb2sgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tb294bWwnO1xuZXhwb3J0ICogZnJvbSAnQHByb2dyZXNzL2tlbmRvLW9veG1sJztcbmltcG9ydCB7IHRvU3RyaW5nIH0gZnJvbSAnQHRlbGVyaWsva2VuZG8taW50bCc7XG5pbXBvcnQgeyBMb2NhbGl6YXRpb25TZXJ2aWNlLCBMMTBOX1BSRUZJWCB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWwxMG4nO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZSBhbGlnbiAqL1xuLyogdHNsaW50OmRpc2FibGU6bm8tdXNlLWJlZm9yZS1kZWNsYXJlICovXG5jb25zdCBjb21waWxlVGVtcGxhdGUgPSAodGVtcGxhdGVSZWYsIGNvbnRleHQsIHVwZGF0ZUNvbnRleHQpID0+IHtcbiAgICBsZXQgZW1iZWRkZWRWaWV3ID0gdGVtcGxhdGVSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KGNvbnRleHQpO1xuICAgIGNvbnN0IHJlc3VsdCA9IChkYXRhKSA9PiB7XG4gICAgICAgIHVwZGF0ZUNvbnRleHQoY29udGV4dCwgZGF0YSk7XG4gICAgICAgIGVtYmVkZGVkVmlldy5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIHJldHVybiBlbWJlZGRlZFZpZXcucm9vdE5vZGVzLnJlZHVjZSgoY29udGVudCwgcm9vdE5vZGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50ICsgcm9vdE5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgIH0sICcnKS50cmltKCk7XG4gICAgfTtcbiAgICByZXN1bHQuZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgZW1iZWRkZWRWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgZW1iZWRkZWRWaWV3ID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuY29uc3QgdXBkYXRlR3JvdXBIZWFkZXJDb250ZXh0ID0gKGNvbnRleHQsIGRhdGEpID0+IHtcbiAgICBjb250ZXh0LiRpbXBsaWNpdCA9IGNvbnRleHQuZ3JvdXAgPSBkYXRhO1xuICAgIGNvbnRleHQuZmllbGQgPSBkYXRhLmZpZWxkO1xuICAgIGNvbnRleHQudmFsdWUgPSBkYXRhLnZhbHVlO1xuICAgIGNvbnRleHQuYWdncmVnYXRlcyA9IGRhdGEuYWdncmVnYXRlcztcbn07XG5jb25zdCB1cGRhdGVHcm91cEZvb3RlckNvbnRleHQgPSAoY29udGV4dCwgZGF0YSkgPT4ge1xuICAgIGNvbnRleHQuZ3JvdXAgPSBkYXRhLmdyb3VwO1xuICAgIGNvbnRleHQuJGltcGxpY2l0ID0gY29udGV4dC5hZ2dyZWdhdGVzID0gZGF0YTtcbn07XG5jb25zdCB1cGRhdGVGb290ZXJDb250ZXh0ID0gKGNvbnRleHQsIGRhdGEpID0+IHtcbiAgICBjb250ZXh0LmFnZ3JlZ2F0ZXMgPSBkYXRhLmFnZ3JlZ2F0ZXM7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHRvRXhwb3J0ZXJDb2x1bW5zID0gKHNvdXJjZUNvbHVtbnMpID0+IHtcbiAgICBjb25zdCBleHBvcnRlckNvbHVtbnMgPSBbXTtcbiAgICBsZXQgY29sdW1uSW5kZXggPSAwO1xuICAgIGNvbnN0IGFkZENvbHVtbnMgPSAoY29sdW1ucywgcmVzdWx0LCBsZXZlbCkgPT4ge1xuICAgICAgICBjb2x1bW5zLmZvckVhY2goKGNvbHVtbikgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbHVtbi5sZXZlbCA9PT0gbGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBvcnRlckNvbHVtbiA9IG5ldyBFeHBvcnRlckNvbHVtbihjb2x1bW4sIGNvbHVtbkluZGV4KTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChleHBvcnRlckNvbHVtbik7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5jaGlsZHJlbiAmJiBjb2x1bW4uY2hpbGRyZW4uc29tZShjID0+IGMgIT09IGNvbHVtbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBleHBvcnRlckNvbHVtbi5jb2x1bW5zID0gW107XG4gICAgICAgICAgICAgICAgICAgIGFkZENvbHVtbnMoY29sdW1uLmNoaWxkcmVuLCBjaGlsZHJlbiwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbkluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFkZENvbHVtbnMoc291cmNlQ29sdW1ucywgZXhwb3J0ZXJDb2x1bW5zLCAwKTtcbiAgICByZXR1cm4gZXhwb3J0ZXJDb2x1bW5zO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBkZXN0cm95Q29sdW1ucyA9IChjb2x1bW5zKSA9PiB7XG4gICAgaWYgKGNvbHVtbnMpIHtcbiAgICAgICAgY29sdW1ucy5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICAgICAgICBjb2x1bW4uZGVzdHJveSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEV4cG9ydGVyQ29sdW1uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2x1bW4sIGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHRoaXMudGl0bGUgPSBjb2x1bW4udGl0bGU7XG4gICAgICAgIHRoaXMuZmllbGQgPSBjb2x1bW4uZmllbGQ7XG4gICAgICAgIHRoaXMuaGlkZGVuID0gY29sdW1uLmhpZGRlbjtcbiAgICAgICAgdGhpcy5sb2NrZWQgPSBjb2x1bW4ubG9ja2VkO1xuICAgICAgICB0aGlzLndpZHRoID0gY29sdW1uLndpZHRoO1xuICAgICAgICB0aGlzLmhlYWRlckNlbGxPcHRpb25zID0gY29sdW1uLmhlYWRlckNlbGxPcHRpb25zO1xuICAgICAgICB0aGlzLmNlbGxPcHRpb25zID0gY29sdW1uLmNlbGxPcHRpb25zO1xuICAgICAgICB0aGlzLmdyb3VwSGVhZGVyQ2VsbE9wdGlvbnMgPSBjb2x1bW4uZ3JvdXBIZWFkZXJDZWxsT3B0aW9ucztcbiAgICAgICAgdGhpcy5ncm91cEZvb3RlckNlbGxPcHRpb25zID0gY29sdW1uLmdyb3VwRm9vdGVyQ2VsbE9wdGlvbnM7XG4gICAgICAgIHRoaXMuZm9vdGVyQ2VsbE9wdGlvbnMgPSBjb2x1bW4uZm9vdGVyQ2VsbE9wdGlvbnM7XG4gICAgICAgIGlmIChjb2x1bW4uZm9vdGVyVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZm9vdGVyVGVtcGxhdGUgPSBjb21waWxlVGVtcGxhdGUoY29sdW1uLmZvb3RlclRlbXBsYXRlLnRlbXBsYXRlUmVmLCB7XG4gICAgICAgICAgICAgICAgJGltcGxpY2l0OiBjb2x1bW4sXG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICAgICAgY29sdW1uSW5kZXg6IGNvbHVtbkluZGV4XG4gICAgICAgICAgICB9LCB1cGRhdGVGb290ZXJDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sdW1uLmdyb3VwRm9vdGVyVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBGb290ZXJUZW1wbGF0ZSA9IGNvbXBpbGVUZW1wbGF0ZShjb2x1bW4uZ3JvdXBGb290ZXJUZW1wbGF0ZS50ZW1wbGF0ZVJlZiwge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgICAgIGZpZWxkOiBjb2x1bW4uZmllbGRcbiAgICAgICAgICAgIH0sIHVwZGF0ZUdyb3VwRm9vdGVyQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbHVtbi5ncm91cEhlYWRlclRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwSGVhZGVyVGVtcGxhdGUgPSBjb21waWxlVGVtcGxhdGUoY29sdW1uLmdyb3VwSGVhZGVyVGVtcGxhdGUudGVtcGxhdGVSZWYsIHt9LCB1cGRhdGVHcm91cEhlYWRlckNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2x1bW4uZ3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5ncm91cEhlYWRlckNvbHVtblRlbXBsYXRlID0gY29tcGlsZVRlbXBsYXRlKGNvbHVtbi5ncm91cEhlYWRlckNvbHVtblRlbXBsYXRlLnRlbXBsYXRlUmVmLCB7fSwgdXBkYXRlR3JvdXBIZWFkZXJDb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5mb290ZXJUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5mb290ZXJUZW1wbGF0ZS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBGb290ZXJUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5ncm91cEZvb3RlclRlbXBsYXRlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ncm91cEhlYWRlclRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwSGVhZGVyVGVtcGxhdGUuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdHJveUNvbHVtbnModGhpcy5jb2x1bW5zKTtcbiAgICB9XG59XG5cbkludGxTZXJ2aWNlLnJlZ2lzdGVyKHsgdG9TdHJpbmcgfSk7XG4vKipcbiAqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHdvcmtib29rT3B0aW9ucyA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgY29sdW1ucyA9IHRvRXhwb3J0ZXJDb2x1bW5zKG9wdGlvbnMuY29sdW1ucyk7XG4gICAgY29uc3QgZXhwb3J0ZXIgPSBuZXcgRXhjZWxFeHBvcnRlcih7XG4gICAgICAgIGNvbHVtbnM6IGNvbHVtbnMsXG4gICAgICAgIGRhdGE6IG9wdGlvbnMuZGF0YSxcbiAgICAgICAgZmlsdGVyYWJsZTogb3B0aW9ucy5maWx0ZXJhYmxlLFxuICAgICAgICBncm91cHM6IG9wdGlvbnMuZ3JvdXAsXG4gICAgICAgIHBhZGRpbmdDZWxsT3B0aW9uczogb3B0aW9ucy5wYWRkaW5nQ2VsbE9wdGlvbnMsXG4gICAgICAgIGhlYWRlclBhZGRpbmdDZWxsT3B0aW9uczogb3B0aW9ucy5oZWFkZXJQYWRkaW5nQ2VsbE9wdGlvbnMsXG4gICAgICAgIGNvbGxhcHNpYmxlOiBvcHRpb25zLmNvbGxhcHNpYmxlLFxuICAgICAgICBoaWVyYXJjaHk6IG9wdGlvbnMuaGllcmFyY2h5LFxuICAgICAgICBhZ2dyZWdhdGVzOiBvcHRpb25zLmFnZ3JlZ2F0ZXNcbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSBleHBvcnRlci53b3JrYm9vaygpO1xuICAgIHJlc3VsdC5jcmVhdG9yID0gb3B0aW9ucy5jcmVhdG9yO1xuICAgIHJlc3VsdC5kYXRlID0gb3B0aW9ucy5kYXRlO1xuICAgIHJlc3VsdC5ydGwgPSBvcHRpb25zLnJ0bDtcbiAgICBkZXN0cm95Q29sdW1ucyhjb2x1bW5zKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCB0b0RhdGFVUkwgPSAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHdvcmtib29rID0gbmV3IFdvcmtib29rKG9wdGlvbnMpO1xuICAgIHJldHVybiB3b3JrYm9vay50b0RhdGFVUkwoKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNXb3JrYm9va09wdGlvbnMgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuc2hlZXRzO1xufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIENvbHVtbkJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBsZXZlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQubGV2ZWwgKyAxIDogMDtcbiAgICB9XG59XG5Db2x1bW5CYXNlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHRpdGxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB3aWR0aDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbG9ja2VkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBoaWRkZW46IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGhlYWRlckNlbGxPcHRpb25zOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjaGlsZHJlbjogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbQ29sdW1uQmFzZSxdIH1dXG59O1xuXG4vLyB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGhcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIEV4Y2VsIEV4cG9ydCBjb21wb25lbnQgZm9yIEFuZ3VsYXJdKHslIHNsdWcgb3ZlcnZpZXdfZXhjZWxleHBvcnQgJX0pLlxuICogQ29uZmlndXJlcyB0aGUgc2V0dGluZ3MgZm9yIHRoZSBFeGNlbCBleHBvcnQgb2YgdGhlIEtlbmRvIFVJIEdyaWQuXG4gKi9cbmNsYXNzIEV4Y2VsRXhwb3J0Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24sIHpvbmUpIHtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIG5hbWUgb2YgdGhlIGZpbGUgdGhhdCBpcyBleHBvcnRlZCB0byBFeGNlbC5cbiAgICAgICAgICogQGRlZmF1bHQgXCJFeHBvcnQueGxzeFwiXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbGVOYW1lID0gJ0V4cG9ydC54bHN4JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sdW1ucyA9IG5ldyBRdWVyeUxpc3QoKTtcbiAgICAgICAgdGhpcy5zYXZlRmlsZSA9IHRoaXMuc2F2ZUZpbGUuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2F2ZXMgdGhlIGRhdGEgdG8gRXhjZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXhwb3J0RGF0YSAtIEFuIG9wdGlvbmFsIHBhcmFtZXRlci4gQ2FuIGJlIHRoZSBkYXRhIHRoYXQgd2lsbCBiZSBleHBvcnRlZCBvciBbYFdvcmtib29rT3B0aW9uc2BdKHslIHNsdWcgYXBpX2V4Y2VsLWV4cG9ydF93b3JrYm9va29wdGlvbnMgJX0pLlxuICAgICAqL1xuICAgIHNhdmUoZXhwb3J0RGF0YSkge1xuICAgICAgICB0aGlzLnRvRGF0YVVSTChleHBvcnREYXRhKS50aGVuKHRoaXMuc2F2ZUZpbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGNvbHVtbnMgYW5kIGRhdGEsIHJldHVybnNcbiAgICAgKiBbYFdvcmtib29rT3B0aW9uc2BdKHslIHNsdWcgYXBpX2V4Y2VsLWV4cG9ydF93b3JrYm9va29wdGlvbnMgJX0pXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBjdXN0b21yb3dzYW5kY2VsbHNfZXhjZWxleHBvcnQgJX0pKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBleHBvcnREYXRhIC0gVGhlIG9wdGlvbmFsIGRhdGEgdG8gYmUgZXhwb3J0ZWQuXG4gICAgICogQHJldHVybnMge1dvcmtib29rT3B0aW9uc30gLSBUaGUgd29ya2Jvb2sgb3B0aW9ucy5cbiAgICAgKi9cbiAgICB3b3JrYm9va09wdGlvbnMoZXhwb3J0RGF0YSkge1xuICAgICAgICBjb25zdCBjdXJyZW50RGF0YSA9IHRoaXMuZ2V0RXhwb3J0RGF0YShleHBvcnREYXRhKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHdvcmtib29rT3B0aW9ucyh7XG4gICAgICAgICAgICBjb2x1bW5zOiB0aGlzLmNvbHVtbnMsXG4gICAgICAgICAgICBkYXRhOiBjdXJyZW50RGF0YS5kYXRhLFxuICAgICAgICAgICAgZ3JvdXA6IGN1cnJlbnREYXRhLmdyb3VwLFxuICAgICAgICAgICAgZmlsdGVyYWJsZTogdGhpcy5maWx0ZXJhYmxlLFxuICAgICAgICAgICAgY3JlYXRvcjogdGhpcy5jcmVhdG9yLFxuICAgICAgICAgICAgZGF0ZTogdGhpcy5kYXRlLFxuICAgICAgICAgICAgcnRsOiB0aGlzLmxvY2FsaXphdGlvbi5ydGwsXG4gICAgICAgICAgICBwYWRkaW5nQ2VsbE9wdGlvbnM6IHRoaXMucGFkZGluZ0NlbGxPcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyUGFkZGluZ0NlbGxPcHRpb25zOiB0aGlzLmhlYWRlclBhZGRpbmdDZWxsT3B0aW9ucyxcbiAgICAgICAgICAgIGNvbGxhcHNpYmxlOiB0aGlzLmNvbGxhcHNpYmxlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2Ugd2hpY2ggd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSBmaWxlIGRhdGEgVVJJXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBmaWxlc2F2aW5nX2V4Y2VsZXhwb3J0ICV9KSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXhwb3J0RGF0YSAtIFRoZSBvcHRpb25hbCBkYXRhIG9yIFtgV29ya2Jvb2tPcHRpb25zYF0oeyUgc2x1ZyBhcGlfZXhjZWwtZXhwb3J0X3dvcmtib29rb3B0aW9ucyAlfSkgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGRhdGEgVVJJLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IC0gVGhlIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIGJ5IHRoZSBmaWxlIGRhdGEgVVJJLlxuICAgICAqL1xuICAgIHRvRGF0YVVSTChleHBvcnREYXRhKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBpc1dvcmtib29rT3B0aW9ucyhleHBvcnREYXRhKSA/XG4gICAgICAgICAgICBleHBvcnREYXRhIDpcbiAgICAgICAgICAgIHRoaXMud29ya2Jvb2tPcHRpb25zKGV4cG9ydERhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHRvRGF0YVVSTChvcHRpb25zKSk7XG4gICAgfVxuICAgIGdldEV4cG9ydERhdGEoZXhwb3J0RGF0YSkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoZXhwb3J0RGF0YSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXhwb3J0RGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGV4cG9ydERhdGFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXhwb3J0RGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgICAgICAgICAgZ3JvdXA6IHRoaXMuZ3JvdXBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc2F2ZUZpbGUoZGF0YVVSTCkge1xuICAgICAgICBzYXZlQXMoZGF0YVVSTCwgdGhpcy5maWxlTmFtZSwge1xuICAgICAgICAgICAgZm9yY2VQcm94eTogdGhpcy5mb3JjZVByb3h5LFxuICAgICAgICAgICAgcHJveHlVUkw6IHRoaXMucHJveHlVUkxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuRXhjZWxFeHBvcnRDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ2tlbmRvRXhjZWxFeHBvcnQnLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZXhjZWxleHBvcnQnLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZVZhbHVlOiAna2VuZG8uZXhjZWxleHBvcnQnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5FeGNlbEV4cG9ydENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9XG5dO1xuRXhjZWxFeHBvcnRDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZmlsZU5hbWU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlcmFibGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNvbGxhcHNpYmxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjcmVhdG9yOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmb3JjZVByb3h5OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBwcm94eVVSTDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGF0YTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZ3JvdXA6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBhZGRpbmdDZWxsT3B0aW9uczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaGVhZGVyUGFkZGluZ0NlbGxPcHRpb25zOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjb2x1bW5zOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtDb2x1bW5CYXNlLCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0sXSB9XVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBncm91cCBoZWFkZXIgY2VsbCB0ZW1wbGF0ZSBvZiB0aGUgRXhjZWwgRXhwb3J0IGNvbHVtbiBjb21wb25lbnRcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY29sdW1uc19leGNlbC1leHBvcnQgJX0jdG9jLWdyb3VwLWhlYWRlci10ZW1wbGF0ZSkpLlxuICogRW5hYmxlcyB5b3UgdG8gY3VzdG9taXplIHRoZSBjb250ZW50IG9mIHRoZSBncm91cCBoZWFkZXIgaXRlbS5cbiAqL1xuY2xhc3MgR3JvdXBIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn1cbkdyb3VwSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0V4Y2VsRXhwb3J0R3JvdXBIZWFkZXJUZW1wbGF0ZV0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkdyb3VwSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfV0gfVxuXTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBncm91cCBoZWFkZXIgY29sdW1uIHRlbXBsYXRlIG9mIHRoZSBFeGNlbCBFeHBvcnQgY29sdW1uIGNvbXBvbmVudFxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBjb2x1bW5zX2V4Y2VsLWV4cG9ydCAlfSN0b2MtZ3JvdXAtaGVhZGVyLWNvbHVtbi10ZW1wbGF0ZSkpLlxuICovXG5jbGFzcyBHcm91cEhlYWRlckNvbHVtblRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufVxuR3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRXhjZWxFeHBvcnRHcm91cEhlYWRlckNvbHVtblRlbXBsYXRlXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuR3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9XSB9XG5dO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGdyb3VwIGZvb3RlciBjZWxsIHRlbXBsYXRlIG9mIHRoZSBFeGNlbCBFeHBvcnQgY29sdW1uIGNvbXBvbmVudFxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBjb2x1bW5zX2V4Y2VsLWV4cG9ydCAlfSN0b2MtZ3JvdXAtZm9vdGVyLXRlbXBsYXRlKSkuXG4gKiBFbmFibGVzIHlvdSB0byBjdXN0b21pemUgdGhlIGdyb3VwIGZvb3RlciBjZWxsIG9mIHRoZSBjb2x1bW4uXG4gKi9cbmNsYXNzIEdyb3VwRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59XG5Hcm91cEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9FeGNlbEV4cG9ydEdyb3VwRm9vdGVyVGVtcGxhdGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Hcm91cEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogVGVtcGxhdGVSZWYsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbl07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZm9vdGVyIGNlbGwgdGVtcGxhdGUgb2YgdGhlIEV4Y2VsIEV4cG9ydCBjb2x1bW4gY29tcG9uZW50XG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGNvbHVtbnNfZXhjZWwtZXhwb3J0ICV9I3RvYy1mb290ZXItdGVtcGxhdGUpKS5cbiAqIEVuYWJsZXMgeW91IHRvIGN1c3RvbWl6ZSB0aGUgZm9vdGVyIGNlbGwgb2YgdGhlIGNvbHVtbi5cbiAqL1xuY2xhc3MgRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59XG5Gb290ZXJUZW1wbGF0ZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRXhjZWxFeHBvcnRGb290ZXJUZW1wbGF0ZV0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkZvb3RlclRlbXBsYXRlRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogVGVtcGxhdGVSZWYsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbl07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgY29sdW1ucyBvZiB0aGUgS2VuZG8gVUkgRXhjZWwgRXhwb3J0IGNvbXBvbmVudCBmb3IgQW5ndWxhci5cbiAqL1xuY2xhc3MgQ29sdW1uQ29tcG9uZW50IGV4dGVuZHMgQ29sdW1uQmFzZSB7XG4gICAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCk7XG4gICAgfVxufVxuQ29sdW1uQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IENvbHVtbkJhc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDb2x1bW5Db21wb25lbnQpIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1leGNlbGV4cG9ydC1jb2x1bW4nLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Db2x1bW5Db21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBDb2x1bW5CYXNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBTa2lwU2VsZiB9LCB7IHR5cGU6IEhvc3QgfSwgeyB0eXBlOiBPcHRpb25hbCB9XSB9XG5dO1xuQ29sdW1uQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGZpZWxkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjZWxsT3B0aW9uczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZ3JvdXBIZWFkZXJDZWxsT3B0aW9uczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZ3JvdXBGb290ZXJDZWxsT3B0aW9uczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZm9vdGVyQ2VsbE9wdGlvbnM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGdyb3VwSGVhZGVyVGVtcGxhdGU6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW0dyb3VwSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUsXSB9XSxcbiAgICBncm91cEhlYWRlckNvbHVtblRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtHcm91cEhlYWRlckNvbHVtblRlbXBsYXRlRGlyZWN0aXZlLF0gfV0sXG4gICAgZ3JvdXBGb290ZXJUZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbR3JvdXBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSxdIH1dLFxuICAgIGZvb3RlclRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSxdIH1dXG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGNvbHVtbiBncm91cCBjb21wb25lbnQgb2YgdGhlIEtlbmRvIFVJIEV4Y2VsIEV4cG9ydCBjb21wb25lbnQuXG4gKi9cbmNsYXNzIENvbHVtbkdyb3VwQ29tcG9uZW50IGV4dGVuZHMgQ29sdW1uQmFzZSB7XG4gICAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbn1cbkNvbHVtbkdyb3VwQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IENvbHVtbkJhc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDb2x1bW5Hcm91cENvbXBvbmVudCkgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWV4Y2VsZXhwb3J0LWNvbHVtbi1ncm91cCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkNvbHVtbkdyb3VwQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogQ29sdW1uQmFzZSwgZGVjb3JhdG9yczogW3sgdHlwZTogU2tpcFNlbGYgfSwgeyB0eXBlOiBIb3N0IH0sIHsgdHlwZTogT3B0aW9uYWwgfV0gfVxuXTtcblxuY29uc3QgZGVjbGFyYXRpb25zID0gW1xuICAgIEV4Y2VsRXhwb3J0Q29tcG9uZW50LFxuICAgIENvbHVtbkNvbXBvbmVudCxcbiAgICBDb2x1bW5Hcm91cENvbXBvbmVudCxcbiAgICBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBHcm91cEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIEdyb3VwSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgR3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZURpcmVjdGl2ZVxuXTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIEV4Y2VsIEV4cG9ydCBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cy1uby1ydW5cbiAqIC8vIEltcG9ydCB0aGUgRXhjZWxFeHBvcnRNb2R1bGUgbW9kdWxlXG4gKiBpbXBvcnQgeyBFeGNlbEV4cG9ydE1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWV4Y2VsLWV4cG9ydCc7XG4gKlxuICogLy8gVGhlIGJyb3dzZXIgcGxhdGZvcm0gd2l0aCBhIGNvbXBpbGVyXG4gKiBpbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJztcbiAqXG4gKiBpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIC8vIEltcG9ydCB0aGUgYXBwIGNvbXBvbmVudFxuICogaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9hcHAuY29tcG9uZW50JztcbiAqXG4gKiAvLyBEZWZpbmUgdGhlIGFwcCBtb2R1bGVcbiAqIF9ATmdNb2R1bGUoe1xuICogICAgIGRlY2xhcmF0aW9uczogW0FwcENvbXBvbmVudF0sIC8vIGRlY2xhcmUgYXBwIGNvbXBvbmVudFxuICogICAgIGltcG9ydHM6ICAgICAgW0Jyb3dzZXJNb2R1bGUsIEV4Y2VsRXhwb3J0TW9kdWxlXSwgLy8gaW1wb3J0IEV4Y2VsRXhwb3J0TW9kdWxlIG1vZHVsZVxuICogICAgIGJvb3RzdHJhcDogICAgW0FwcENvbXBvbmVudF1cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHt9XG4gKlxuICogLy8gQ29tcGlsZSBhbmQgbGF1bmNoIHRoZSBtb2R1bGVcbiAqIHBsYXRmb3JtQnJvd3NlckR5bmFtaWMoKS5ib290c3RyYXBNb2R1bGUoQXBwTW9kdWxlKTtcbiAqXG4gKiBgYGBcbiAqL1xuY2xhc3MgRXhjZWxFeHBvcnRNb2R1bGUge1xufVxuRXhjZWxFeHBvcnRNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW2RlY2xhcmF0aW9uc10sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW2RlY2xhcmF0aW9uc11cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBHcm91cEhlYWRlckNvbHVtblRlbXBsYXRlRGlyZWN0aXZlLCBFeGNlbEV4cG9ydENvbXBvbmVudCwgRXhjZWxFeHBvcnRNb2R1bGUsIENvbHVtbkJhc2UsIENvbHVtbkNvbXBvbmVudCwgQ29sdW1uR3JvdXBDb21wb25lbnQsIEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlLCBHcm91cEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlLCBHcm91cEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlLCB3b3JrYm9va09wdGlvbnMsIHRvRGF0YVVSTCwgaXNXb3JrYm9va09wdGlvbnMgfTtcbiJdfQ==