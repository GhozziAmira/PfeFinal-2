/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { EventEmitter, OnDestroy, ViewContainerRef } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { PopupService } from '@progress/kendo-angular-popup';
import { PopupSettings, PreventableEvent, PaletteSettings, OutputFormat, ActiveColorClickEvent, ColorPickerView, GradientSettings } from './models';
import { LocalizationService } from '@progress/kendo-angular-l10n';
/**
 * Represents the [Kendo UI ColorPicker component for Angular]({% slug overview_colorpicker %}).
 * Designed to replace the `<input type="color">` HTML5 tag which is not widely supported in browsers.
 */
import * as ɵngcc0 from '@angular/core';
export declare class ColorPickerComponent implements OnDestroy, ControlValueAccessor {
    private popupService;
    /**
     * @hidden
     */
    hostClasses: boolean;
    /**
     * @hidden
     */
    direction: string;
    /**
     * Sets what view the ColorPicker will render in the popup.
     */
    view: ColorPickerView;
    /**
     * Sets the read-only state of the ColorPicker.
     */
    readonly: boolean;
    /**
     * Sets the disabled state of the ColorPicker.
     */
    disabled: boolean;
    /**
     * Specifies the output format of the ColorPicker.
     * The input value may be in a different format. However, it will be parsed into the output `format`
     * after the component processes it.
     *
     * If the `gradient` view is used with the `opacity` option set to true, this setting will be ignored and `rgba` will be used instead.
     *
     * The supported values are:
     * * `rgba` (default)
     * * `hex`
     * * [`name`](https://www.w3.org/wiki/CSS/Properties/color/keywords)
     */
    format: OutputFormat;
    /**
     * Specifies the value of the initially selected color.
     */
    value: string;
    /**
     * Configures the popup of the ColorPicker.
     */
    popupSettings: PopupSettings;
    /**
     * Configures the palette that is displayed in the ColorPicker popup.
     */
    paletteSettings: PaletteSettings;
    /**
     * Configures the gradient that is displayed in the ColorPicker popup.
     */
    gradientSettings: GradientSettings;
    /**
     * Defines the name of an [existing icon in the Kendo UI theme]({% slug icons %}).
     * Provide only the name of the icon without the `k-icon` or the `k-i-` prefixes.
     * For example, `edit-tools` will be parsed to `k-icon k-i-edit-tools`.
     */
    icon: string;
    /**
     * A CSS class name which displays an icon in the ColorPicker button.
     * `iconClass` is compatible with the `ngClass` syntax.
     *
     * Takes precedence over `icon` if both are defined.
     */
    iconClass: string | Array<string> | {
        [key: string]: boolean;
    };
    /**
     * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
     */
    tabindex: number;
    /**
     * Fires each time the value is changed.
     */
    valueChange: EventEmitter<any>;
    /**
     * Fires each time the popup is about to open.
     * This event is preventable. If you cancel it, the popup will remain closed.
     */
    open: EventEmitter<PreventableEvent>;
    /**
     * Fires each time the popup is about to close.
     * This event is preventable. If you cancel it, the popup will remain open.
     */
    close: EventEmitter<PreventableEvent>;
    /**
     * Fires each time ColorPicker is focused.
     */
    onFocus: EventEmitter<any>;
    /**
     * Fires each time the ColorPicker is blurred.
     */
    onBlur: EventEmitter<any>;
    /**
     * Fires each time the left side of the ColorPicker wrapper is clicked.
     * The event is triggered regardless of whether a ColorPicker icon is set or not.
     *
     * The [`ActiveColorClickEvent`]({% slug api_inputs_activecolorclickevent %}) event provides the option to prevent the popup opening.
     */
    activeColorClick: EventEmitter<ActiveColorClickEvent>;
    /**
     * Indicates whether the ColorPicker wrapper is focused.
     */
    isFocused: boolean;
    /**
     * Indicates whether the ColorPicker popup is open.
     */
    readonly isOpen: boolean;
    /**
     * @hidden
     */
    readonly iconStyles: string | string[] | {
        [key: string]: boolean;
    };
    /**
     * Provides a reference to a container element inside the component markup.
     * The container element references the location of the appended popup&mdash;
     * for example, inside the component markup.
     */
    container: ViewContainerRef;
    private wrapper;
    private popupTemplate;
    private palette;
    private popupRef;
    private _value;
    private _tabindex;
    private _popupSettings;
    private _paletteSettings;
    private _gradientSettings;
    private dynamicRTLSubscription;
    constructor(popupService: PopupService, localizationService: LocalizationService);
    ngOnInit(): void;
    ngOnChanges(changes: any): void;
    ngOnDestroy(): void;
    /**
     * @hidden
     */
    handleWrapperClick(): void;
    /**
     * @hidden
     */
    handleActiveColorClick(): void;
    /**
     * Focuses the wrapper of the ColorPicker.
     */
    focus(): void;
    /**
     * @hidden
     */
    handleWrapperFocus(): void;
    /**
     * Blurs the ColorPicker.
     */
    blur(): void;
    /**
     * @hidden
     */
    handleWrapperBlur(): void;
    /**
     * Clears the color value of the ColorPicker.
     */
    reset(): void;
    /**
     * Toggles the popup of the ColorPicker.
     * Does not trigger the `open` and `close` events of the component.
     *
     * @param open An optional parameter. Specifies whether the popup will be opened or closed.
     */
    toggle(open?: boolean): void;
    /**
     * @hidden
     */
    handleValueChange(color: string, closePopup: boolean): void;
    /**
     * @hidden
     */
    handlePopupBlur(event: FocusEvent): void;
    /**
     * @hidden
     */
    writeValue(value: string): void;
    /**
     * @hidden
     */
    registerOnChange(fn: any): void;
    /**
     * @hidden
     */
    registerOnTouched(fn: any): void;
    /**
     * @hidden
     */
    setDisabledState(isDisabled: boolean): void;
    /**
     * @hidden
     */
    handleWrapperKeyDown(event: any): void;
    /**
     * @hidden
     */
    handlePopupKeyDown(keyCode: number): void;
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty.
     */
    isEmpty(): boolean;
    private toggleWithEvents;
    private openPopup;
    private closePopup;
    private notifyNgTouched;
    private notifyNgChanged;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<ColorPickerComponent>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<ColorPickerComponent, "kendo-colorpicker", never, {
    "view": "view";
    "readonly": "readonly";
    "disabled": "disabled";
    "format": "format";
    "value": "value";
    "popupSettings": "popupSettings";
    "paletteSettings": "paletteSettings";
    "gradientSettings": "gradientSettings";
    "tabindex": "tabindex";
    "icon": "icon";
    "iconClass": "iconClass";
}, {
    "valueChange": "valueChange";
    "open": "open";
    "close": "close";
    "onFocus": "focus";
    "onBlur": "blur";
    "activeColorClick": "activeColorClick";
}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sb3JwaWNrZXIuY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbImNvbG9ycGlja2VyLmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7OztBQWFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrTkEiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIsIE9uRGVzdHJveSwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBQb3B1cFNlcnZpY2UgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1wb3B1cCc7XG5pbXBvcnQgeyBQb3B1cFNldHRpbmdzLCBQcmV2ZW50YWJsZUV2ZW50LCBQYWxldHRlU2V0dGluZ3MsIE91dHB1dEZvcm1hdCwgQWN0aXZlQ29sb3JDbGlja0V2ZW50LCBDb2xvclBpY2tlclZpZXcsIEdyYWRpZW50U2V0dGluZ3MgfSBmcm9tICcuL21vZGVscyc7XG5pbXBvcnQgeyBMb2NhbGl6YXRpb25TZXJ2aWNlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItbDEwbic7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBDb2xvclBpY2tlciBjb21wb25lbnQgZm9yIEFuZ3VsYXJdKHslIHNsdWcgb3ZlcnZpZXdfY29sb3JwaWNrZXIgJX0pLlxuICogRGVzaWduZWQgdG8gcmVwbGFjZSB0aGUgYDxpbnB1dCB0eXBlPVwiY29sb3JcIj5gIEhUTUw1IHRhZyB3aGljaCBpcyBub3Qgd2lkZWx5IHN1cHBvcnRlZCBpbiBicm93c2Vycy5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgQ29sb3JQaWNrZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcbiAgICBwcml2YXRlIHBvcHVwU2VydmljZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaG9zdENsYXNzZXM6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGRpcmVjdGlvbjogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFNldHMgd2hhdCB2aWV3IHRoZSBDb2xvclBpY2tlciB3aWxsIHJlbmRlciBpbiB0aGUgcG9wdXAuXG4gICAgICovXG4gICAgdmlldzogQ29sb3JQaWNrZXJWaWV3O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJlYWQtb25seSBzdGF0ZSBvZiB0aGUgQ29sb3JQaWNrZXIuXG4gICAgICovXG4gICAgcmVhZG9ubHk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGlzYWJsZWQgc3RhdGUgb2YgdGhlIENvbG9yUGlja2VyLlxuICAgICAqL1xuICAgIGRpc2FibGVkOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgb3V0cHV0IGZvcm1hdCBvZiB0aGUgQ29sb3JQaWNrZXIuXG4gICAgICogVGhlIGlucHV0IHZhbHVlIG1heSBiZSBpbiBhIGRpZmZlcmVudCBmb3JtYXQuIEhvd2V2ZXIsIGl0IHdpbGwgYmUgcGFyc2VkIGludG8gdGhlIG91dHB1dCBgZm9ybWF0YFxuICAgICAqIGFmdGVyIHRoZSBjb21wb25lbnQgcHJvY2Vzc2VzIGl0LlxuICAgICAqXG4gICAgICogSWYgdGhlIGBncmFkaWVudGAgdmlldyBpcyB1c2VkIHdpdGggdGhlIGBvcGFjaXR5YCBvcHRpb24gc2V0IHRvIHRydWUsIHRoaXMgc2V0dGluZyB3aWxsIGJlIGlnbm9yZWQgYW5kIGByZ2JhYCB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIFRoZSBzdXBwb3J0ZWQgdmFsdWVzIGFyZTpcbiAgICAgKiAqIGByZ2JhYCAoZGVmYXVsdClcbiAgICAgKiAqIGBoZXhgXG4gICAgICogKiBbYG5hbWVgXShodHRwczovL3d3dy53My5vcmcvd2lraS9DU1MvUHJvcGVydGllcy9jb2xvci9rZXl3b3JkcylcbiAgICAgKi9cbiAgICBmb3JtYXQ6IE91dHB1dEZvcm1hdDtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIHZhbHVlIG9mIHRoZSBpbml0aWFsbHkgc2VsZWN0ZWQgY29sb3IuXG4gICAgICovXG4gICAgdmFsdWU6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIHRoZSBwb3B1cCBvZiB0aGUgQ29sb3JQaWNrZXIuXG4gICAgICovXG4gICAgcG9wdXBTZXR0aW5nczogUG9wdXBTZXR0aW5ncztcbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIHRoZSBwYWxldHRlIHRoYXQgaXMgZGlzcGxheWVkIGluIHRoZSBDb2xvclBpY2tlciBwb3B1cC5cbiAgICAgKi9cbiAgICBwYWxldHRlU2V0dGluZ3M6IFBhbGV0dGVTZXR0aW5ncztcbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIHRoZSBncmFkaWVudCB0aGF0IGlzIGRpc3BsYXllZCBpbiB0aGUgQ29sb3JQaWNrZXIgcG9wdXAuXG4gICAgICovXG4gICAgZ3JhZGllbnRTZXR0aW5nczogR3JhZGllbnRTZXR0aW5ncztcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSBuYW1lIG9mIGFuIFtleGlzdGluZyBpY29uIGluIHRoZSBLZW5kbyBVSSB0aGVtZV0oeyUgc2x1ZyBpY29ucyAlfSkuXG4gICAgICogUHJvdmlkZSBvbmx5IHRoZSBuYW1lIG9mIHRoZSBpY29uIHdpdGhvdXQgdGhlIGBrLWljb25gIG9yIHRoZSBgay1pLWAgcHJlZml4ZXMuXG4gICAgICogRm9yIGV4YW1wbGUsIGBlZGl0LXRvb2xzYCB3aWxsIGJlIHBhcnNlZCB0byBgay1pY29uIGstaS1lZGl0LXRvb2xzYC5cbiAgICAgKi9cbiAgICBpY29uOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQSBDU1MgY2xhc3MgbmFtZSB3aGljaCBkaXNwbGF5cyBhbiBpY29uIGluIHRoZSBDb2xvclBpY2tlciBidXR0b24uXG4gICAgICogYGljb25DbGFzc2AgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBgbmdDbGFzc2Agc3ludGF4LlxuICAgICAqXG4gICAgICogVGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBpY29uYCBpZiBib3RoIGFyZSBkZWZpbmVkLlxuICAgICAqL1xuICAgIGljb25DbGFzczogc3RyaW5nIHwgQXJyYXk8c3RyaW5nPiB8IHtcbiAgICAgICAgW2tleTogc3RyaW5nXTogYm9vbGVhbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgW2B0YWJpbmRleGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXgpIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICovXG4gICAgdGFiaW5kZXg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHZhbHVlIGlzIGNoYW5nZWQuXG4gICAgICovXG4gICAgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgcG9wdXAgaXMgYWJvdXQgdG8gb3Blbi5cbiAgICAgKiBUaGlzIGV2ZW50IGlzIHByZXZlbnRhYmxlLiBJZiB5b3UgY2FuY2VsIGl0LCB0aGUgcG9wdXAgd2lsbCByZW1haW4gY2xvc2VkLlxuICAgICAqL1xuICAgIG9wZW46IEV2ZW50RW1pdHRlcjxQcmV2ZW50YWJsZUV2ZW50PjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHBvcHVwIGlzIGFib3V0IHRvIGNsb3NlLlxuICAgICAqIFRoaXMgZXZlbnQgaXMgcHJldmVudGFibGUuIElmIHlvdSBjYW5jZWwgaXQsIHRoZSBwb3B1cCB3aWxsIHJlbWFpbiBvcGVuLlxuICAgICAqL1xuICAgIGNsb3NlOiBFdmVudEVtaXR0ZXI8UHJldmVudGFibGVFdmVudD47XG4gICAgLyoqXG4gICAgICogRmlyZXMgZWFjaCB0aW1lIENvbG9yUGlja2VyIGlzIGZvY3VzZWQuXG4gICAgICovXG4gICAgb25Gb2N1czogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgLyoqXG4gICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBDb2xvclBpY2tlciBpcyBibHVycmVkLlxuICAgICAqL1xuICAgIG9uQmx1cjogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgLyoqXG4gICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIENvbG9yUGlja2VyIHdyYXBwZXIgaXMgY2xpY2tlZC5cbiAgICAgKiBUaGUgZXZlbnQgaXMgdHJpZ2dlcmVkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBhIENvbG9yUGlja2VyIGljb24gaXMgc2V0IG9yIG5vdC5cbiAgICAgKlxuICAgICAqIFRoZSBbYEFjdGl2ZUNvbG9yQ2xpY2tFdmVudGBdKHslIHNsdWcgYXBpX2lucHV0c19hY3RpdmVjb2xvcmNsaWNrZXZlbnQgJX0pIGV2ZW50IHByb3ZpZGVzIHRoZSBvcHRpb24gdG8gcHJldmVudCB0aGUgcG9wdXAgb3BlbmluZy5cbiAgICAgKi9cbiAgICBhY3RpdmVDb2xvckNsaWNrOiBFdmVudEVtaXR0ZXI8QWN0aXZlQ29sb3JDbGlja0V2ZW50PjtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgQ29sb3JQaWNrZXIgd3JhcHBlciBpcyBmb2N1c2VkLlxuICAgICAqL1xuICAgIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgQ29sb3JQaWNrZXIgcG9wdXAgaXMgb3Blbi5cbiAgICAgKi9cbiAgICByZWFkb25seSBpc09wZW46IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlYWRvbmx5IGljb25TdHlsZXM6IHN0cmluZyB8IHN0cmluZ1tdIHwge1xuICAgICAgICBba2V5OiBzdHJpbmddOiBib29sZWFuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSByZWZlcmVuY2UgdG8gYSBjb250YWluZXIgZWxlbWVudCBpbnNpZGUgdGhlIGNvbXBvbmVudCBtYXJrdXAuXG4gICAgICogVGhlIGNvbnRhaW5lciBlbGVtZW50IHJlZmVyZW5jZXMgdGhlIGxvY2F0aW9uIG9mIHRoZSBhcHBlbmRlZCBwb3B1cCZtZGFzaDtcbiAgICAgKiBmb3IgZXhhbXBsZSwgaW5zaWRlIHRoZSBjb21wb25lbnQgbWFya3VwLlxuICAgICAqL1xuICAgIGNvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZjtcbiAgICBwcml2YXRlIHdyYXBwZXI7XG4gICAgcHJpdmF0ZSBwb3B1cFRlbXBsYXRlO1xuICAgIHByaXZhdGUgcGFsZXR0ZTtcbiAgICBwcml2YXRlIHBvcHVwUmVmO1xuICAgIHByaXZhdGUgX3ZhbHVlO1xuICAgIHByaXZhdGUgX3RhYmluZGV4O1xuICAgIHByaXZhdGUgX3BvcHVwU2V0dGluZ3M7XG4gICAgcHJpdmF0ZSBfcGFsZXR0ZVNldHRpbmdzO1xuICAgIHByaXZhdGUgX2dyYWRpZW50U2V0dGluZ3M7XG4gICAgcHJpdmF0ZSBkeW5hbWljUlRMU3Vic2NyaXB0aW9uO1xuICAgIGNvbnN0cnVjdG9yKHBvcHVwU2VydmljZTogUG9wdXBTZXJ2aWNlLCBsb2NhbGl6YXRpb25TZXJ2aWNlOiBMb2NhbGl6YXRpb25TZXJ2aWNlKTtcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IGFueSk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlV3JhcHBlckNsaWNrKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUFjdGl2ZUNvbG9yQ2xpY2soKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSB3cmFwcGVyIG9mIHRoZSBDb2xvclBpY2tlci5cbiAgICAgKi9cbiAgICBmb2N1cygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVXcmFwcGVyRm9jdXMoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBCbHVycyB0aGUgQ29sb3JQaWNrZXIuXG4gICAgICovXG4gICAgYmx1cigpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVXcmFwcGVyQmx1cigpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgY29sb3IgdmFsdWUgb2YgdGhlIENvbG9yUGlja2VyLlxuICAgICAqL1xuICAgIHJlc2V0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgcG9wdXAgb2YgdGhlIENvbG9yUGlja2VyLlxuICAgICAqIERvZXMgbm90IHRyaWdnZXIgdGhlIGBvcGVuYCBhbmQgYGNsb3NlYCBldmVudHMgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcGVuIEFuIG9wdGlvbmFsIHBhcmFtZXRlci4gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIHBvcHVwIHdpbGwgYmUgb3BlbmVkIG9yIGNsb3NlZC5cbiAgICAgKi9cbiAgICB0b2dnbGUob3Blbj86IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVWYWx1ZUNoYW5nZShjb2xvcjogc3RyaW5nLCBjbG9zZVBvcHVwOiBib29sZWFuKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlUG9wdXBCbHVyKGV2ZW50OiBGb2N1c0V2ZW50KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogc3RyaW5nKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZVdyYXBwZXJLZXlEb3duKGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVQb3B1cEtleURvd24oa2V5Q29kZTogbnVtYmVyKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogVXNlZCBieSB0aGUgVGV4dEJveENvbnRhaW5lciB0byBkZXRlcm1pbmUgaWYgdGhlIGNvbXBvbmVudCBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBpc0VtcHR5KCk6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSB0b2dnbGVXaXRoRXZlbnRzO1xuICAgIHByaXZhdGUgb3BlblBvcHVwO1xuICAgIHByaXZhdGUgY2xvc2VQb3B1cDtcbiAgICBwcml2YXRlIG5vdGlmeU5nVG91Y2hlZDtcbiAgICBwcml2YXRlIG5vdGlmeU5nQ2hhbmdlZDtcbn1cbiJdfQ==