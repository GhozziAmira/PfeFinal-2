/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { AfterViewInit, Renderer2, ElementRef, EventEmitter, OnChanges, OnDestroy, NgZone, Injector, SimpleChanges } from '@angular/core';
import { ControlValueAccessor, NgControl } from '@angular/forms';
import { Subscription } from 'rxjs';
import { LocalizationService } from '@progress/kendo-angular-l10n';
import { LabelTemplateDirective } from './label-template.directive';
/**
 * Represents the [Kendo UI Slider component for Angular]({% slug overview_slider %}).
 */
import * as ɵngcc0 from '@angular/core';
export declare class SliderComponent implements AfterViewInit, ControlValueAccessor, OnChanges, OnDestroy {
    private localizationService;
    private injector;
    private renderer;
    private ngZone;
    private hostElement;
    /**
     * @hidden
     */
    focusableId: string;
    /**
     * Sets the title of the **Increase** button of the Slider ([see example]({% slug sidebuttons_slider %}#toc-titles)).
     */
    incrementTitle: string;
    /**
     * Determines if the animation will be played on value change.
     * Regardless of this setting, no animation will be played during the initial rendering.
     */
    animate: boolean;
    /**
     * Sets the title of the **Decrease** button of the Slider ([see example]({% slug sidebuttons_slider %}#toc-titles)).
     */
    decrementTitle: string;
    /**
     * Renders the arrow side buttons of the Slider ([see example]({% slug sidebuttons_slider %}#toc-hidden-state)).
     * When `showButtons` is set to `false`, the buttons are not displayed.
     */
    showButtons: boolean;
    /**
     * Denotes the location of the tick marks in the Slider ([see example]({% slug ticks_slider %}#toc-placement)).
     *
     * The available options are:
     * * `before`&mdash;The tick marks are located to the top side of the horizontal track or to the left side of a vertical track.
     * * `after`&mdash;The tick marks are located to the bottom side of the horizontal track or to the right side of the vertical track.
     * * `both`&mdash;The tick marks are located on both sides of the track.
     * * `none`&mdash;The tick marks are not visible. The actual elements are not added to the DOM tree.
     */
    tickPlacement: string;
    /**
     * Defines the title of the ticks ([see example]({% slug ticks_slider %}#toc-titles)). The default title
     * for each tick is its Slider value. If you use a callback function, the function accepts an argument
     * that holds the value of the component and returns a string with the new title.
     */
    title: (value: number) => string;
    /**
     * Changes the `title` attribute of the drag handle so that it can be localized.
     */
    dragHandleTitle: string;
    /**
     * If `vertical` is set to `true`, the orientation of the Slider changes from horizontal to vertical
     * ([see example]({% slug orientation_slider %})).
     */
    vertical: boolean;
    /**
     * The minimum value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).
     * The attribute accepts both integers and floating-point numbers.
     */
    min: number;
    /**
     * The maximum value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).
     * The attribute accepts both integers and floating-point numbers.
     */
    max: number;
    /**
     * The step value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).
     * Accepts positive values only. Can be an integer or a floating-point number.
     */
    smallStep: number;
    /**
     * Specifies that every n<sup>th</sup> tick will be large and will have a label
     * ([see example]({% slug predefinedsteps_slider %}#toc-large-steps)).
     * Accepts positive integer values only.
     */
    largeStep: number;
    /**
     * Sets the width between each two ticks along the track ([see example]({% slug ticks_slider %}#toc-width)). The value
     * has to be set in pixels. If no `fixedTickWidth` is provided, the Slider automatically adjusts the tick width to
     * accommodate the elements within the size of the component.
     */
    fixedTickWidth: number;
    /**
     * Determines whether the Slider is disabled ([see example]({% slug disabledstate_slider %})).
     */
    disabled: boolean;
    /**
     * Determines whether the Slider is in its read-only state ([see example]({% slug readonly_slider %})).
     */
    readonly: boolean;
    /**
     * The current value of the Slider when it is initially displayed.
     * The component can use either NgModel or the `value` binding but not both of them at the same time.
     */
    value: number;
    /**
     * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Slider.
     */
    tabindex: number;
    /**
     * @hidden
     */
    tabIndex: number;
    /**
     * Fires each time the user focuses the `input` element.
     */
    onFocus: EventEmitter<any>;
    /**
     * Fires each time the `input` element gets blurred.
     */
    onBlur: EventEmitter<any>;
    /**
     * Fires each time the user selects a new value.
     */
    valueChange: EventEmitter<any>;
    wrapper: ElementRef;
    track: ElementRef;
    draghandle: ElementRef;
    sliderSelection: ElementRef;
    ticksContainer: ElementRef;
    ticks: any;
    decreaseButton: ElementRef;
    increaseButton: ElementRef;
    labelTemplate: LabelTemplateDirective;
    direction: string;
    readonly horizontalClass: boolean;
    readonly verticalClass: boolean;
    sliderClass: boolean;
    widgetClass: boolean;
    stateDefaultClass: boolean;
    readonly disabledClass: boolean;
    readonly ariaDisabled: boolean;
    readonly ariaReadonly: boolean;
    readonly ariaMin: number;
    readonly ariaMax: number;
    readonly ariaValue: number;
    protected subscriptions: Subscription;
    protected isFocused: boolean;
    protected isDragged: boolean;
    protected control: NgControl;
    constructor(localizationService: LocalizationService, injector: Injector, renderer: Renderer2, ngZone: NgZone, hostElement: ElementRef);
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     *
     * @param isDisabled
     */
    setDisabledState(isDisabled: boolean): void;
    /**
     * @hidden
     */
    handleFocus: () => void;
    /**
     * @hidden
     */
    handleBlur: () => void;
    ngOnInit(): void;
    /**
     * Focuses the Slider.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="slider.focus()">Focus</button>
     *  <kendo-slider #slider></kendo-slider>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus(): void;
    /**
     * Blurs the Slider.
     */
    blur(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    /**
     * @hidden
     */
    readonly incrementMessage: string;
    /**
     * @hidden
     */
    readonly decrementMessage: string;
    /**
     * @hidden
     */
    readonly dragHandleMessage: string;
    /**
     * @hidden
     */
    onWrapClick: (args: any) => void;
    /**
     * @hidden
     */
    ifEnabled: Function;
    /**
     * @hidden
     */
    handleDragPress(args: any): void;
    /**
     * @hidden
     */
    onHandleDrag(args: any): void;
    /**
     * @hidden
     */
    onKeyDown: (e: any) => void;
    /**
     * @hidden
     */
    onHandleRelease(): void;
    /**
     * @hidden
     */
    writeValue(value: number): void;
    /**
     * @hidden
     */
    registerOnChange(fn: () => any): void;
    /**
     * @hidden
     */
    registerOnTouched(fn: () => any): void;
    /**
     * @hidden
     */
    changeValue(value: number): void;
    /**
     * @hidden
     */
    sizeComponent(animate: boolean): void;
    /**
     * @hidden
     */
    readonly isDisabled: boolean;
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty.
     */
    isEmpty(): boolean;
    private readonly reverse;
    private readonly keyBinding;
    private focused;
    private dragging;
    private setValueChangeInterval;
    private ngChange;
    private ngTouched;
    private decreaseValue;
    private increaseValue;
    private getProps;
    private resetStyles;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<SliderComponent>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<SliderComponent, "kendo-slider", ["kendoSlider"], {
    "focusableId": "focusableId";
    "animate": "animate";
    "showButtons": "showButtons";
    "tickPlacement": "tickPlacement";
    "title": "title";
    "vertical": "vertical";
    "min": "min";
    "max": "max";
    "smallStep": "smallStep";
    "largeStep": "largeStep";
    "disabled": "disabled";
    "readonly": "readonly";
    "value": "value";
    "tabindex": "tabindex";
    "tabIndex": "tabIndex";
    "incrementTitle": "incrementTitle";
    "decrementTitle": "decrementTitle";
    "dragHandleTitle": "dragHandleTitle";
    "fixedTickWidth": "fixedTickWidth";
}, {
    "onFocus": "focus";
    "onBlur": "blur";
    "valueChange": "valueChange";
}, ["labelTemplate"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLmNvbXBvbmVudC5kLnRzIiwic291cmNlcyI6WyJzbGlkZXIuY29tcG9uZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7QUFZQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErUEEiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBBZnRlclZpZXdJbml0LCBSZW5kZXJlcjIsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE5nWm9uZSwgSW5qZWN0b3IsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IExvY2FsaXphdGlvblNlcnZpY2UgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1sMTBuJztcbmltcG9ydCB7IExhYmVsVGVtcGxhdGVEaXJlY3RpdmUgfSBmcm9tICcuL2xhYmVsLXRlbXBsYXRlLmRpcmVjdGl2ZSc7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBTbGlkZXIgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X3NsaWRlciAlfSkuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIFNsaWRlckNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBsb2NhbGl6YXRpb25TZXJ2aWNlO1xuICAgIHByaXZhdGUgaW5qZWN0b3I7XG4gICAgcHJpdmF0ZSByZW5kZXJlcjtcbiAgICBwcml2YXRlIG5nWm9uZTtcbiAgICBwcml2YXRlIGhvc3RFbGVtZW50O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBmb2N1c2FibGVJZDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRpdGxlIG9mIHRoZSAqKkluY3JlYXNlKiogYnV0dG9uIG9mIHRoZSBTbGlkZXIgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBzaWRlYnV0dG9uc19zbGlkZXIgJX0jdG9jLXRpdGxlcykpLlxuICAgICAqL1xuICAgIGluY3JlbWVudFRpdGxlOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgYW5pbWF0aW9uIHdpbGwgYmUgcGxheWVkIG9uIHZhbHVlIGNoYW5nZS5cbiAgICAgKiBSZWdhcmRsZXNzIG9mIHRoaXMgc2V0dGluZywgbm8gYW5pbWF0aW9uIHdpbGwgYmUgcGxheWVkIGR1cmluZyB0aGUgaW5pdGlhbCByZW5kZXJpbmcuXG4gICAgICovXG4gICAgYW5pbWF0ZTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0aXRsZSBvZiB0aGUgKipEZWNyZWFzZSoqIGJ1dHRvbiBvZiB0aGUgU2xpZGVyIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgc2lkZWJ1dHRvbnNfc2xpZGVyICV9I3RvYy10aXRsZXMpKS5cbiAgICAgKi9cbiAgICBkZWNyZW1lbnRUaXRsZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGFycm93IHNpZGUgYnV0dG9ucyBvZiB0aGUgU2xpZGVyIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgc2lkZWJ1dHRvbnNfc2xpZGVyICV9I3RvYy1oaWRkZW4tc3RhdGUpKS5cbiAgICAgKiBXaGVuIGBzaG93QnV0dG9uc2AgaXMgc2V0IHRvIGBmYWxzZWAsIHRoZSBidXR0b25zIGFyZSBub3QgZGlzcGxheWVkLlxuICAgICAqL1xuICAgIHNob3dCdXR0b25zOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIERlbm90ZXMgdGhlIGxvY2F0aW9uIG9mIHRoZSB0aWNrIG1hcmtzIGluIHRoZSBTbGlkZXIgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyB0aWNrc19zbGlkZXIgJX0jdG9jLXBsYWNlbWVudCkpLlxuICAgICAqXG4gICAgICogVGhlIGF2YWlsYWJsZSBvcHRpb25zIGFyZTpcbiAgICAgKiAqIGBiZWZvcmVgJm1kYXNoO1RoZSB0aWNrIG1hcmtzIGFyZSBsb2NhdGVkIHRvIHRoZSB0b3Agc2lkZSBvZiB0aGUgaG9yaXpvbnRhbCB0cmFjayBvciB0byB0aGUgbGVmdCBzaWRlIG9mIGEgdmVydGljYWwgdHJhY2suXG4gICAgICogKiBgYWZ0ZXJgJm1kYXNoO1RoZSB0aWNrIG1hcmtzIGFyZSBsb2NhdGVkIHRvIHRoZSBib3R0b20gc2lkZSBvZiB0aGUgaG9yaXpvbnRhbCB0cmFjayBvciB0byB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgdmVydGljYWwgdHJhY2suXG4gICAgICogKiBgYm90aGAmbWRhc2g7VGhlIHRpY2sgbWFya3MgYXJlIGxvY2F0ZWQgb24gYm90aCBzaWRlcyBvZiB0aGUgdHJhY2suXG4gICAgICogKiBgbm9uZWAmbWRhc2g7VGhlIHRpY2sgbWFya3MgYXJlIG5vdCB2aXNpYmxlLiBUaGUgYWN0dWFsIGVsZW1lbnRzIGFyZSBub3QgYWRkZWQgdG8gdGhlIERPTSB0cmVlLlxuICAgICAqL1xuICAgIHRpY2tQbGFjZW1lbnQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSB0aXRsZSBvZiB0aGUgdGlja3MgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyB0aWNrc19zbGlkZXIgJX0jdG9jLXRpdGxlcykpLiBUaGUgZGVmYXVsdCB0aXRsZVxuICAgICAqIGZvciBlYWNoIHRpY2sgaXMgaXRzIFNsaWRlciB2YWx1ZS4gSWYgeW91IHVzZSBhIGNhbGxiYWNrIGZ1bmN0aW9uLCB0aGUgZnVuY3Rpb24gYWNjZXB0cyBhbiBhcmd1bWVudFxuICAgICAqIHRoYXQgaG9sZHMgdGhlIHZhbHVlIG9mIHRoZSBjb21wb25lbnQgYW5kIHJldHVybnMgYSBzdHJpbmcgd2l0aCB0aGUgbmV3IHRpdGxlLlxuICAgICAqL1xuICAgIHRpdGxlOiAodmFsdWU6IG51bWJlcikgPT4gc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGB0aXRsZWAgYXR0cmlidXRlIG9mIHRoZSBkcmFnIGhhbmRsZSBzbyB0aGF0IGl0IGNhbiBiZSBsb2NhbGl6ZWQuXG4gICAgICovXG4gICAgZHJhZ0hhbmRsZVRpdGxlOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogSWYgYHZlcnRpY2FsYCBpcyBzZXQgdG8gYHRydWVgLCB0aGUgb3JpZW50YXRpb24gb2YgdGhlIFNsaWRlciBjaGFuZ2VzIGZyb20gaG9yaXpvbnRhbCB0byB2ZXJ0aWNhbFxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3JpZW50YXRpb25fc2xpZGVyICV9KSkuXG4gICAgICovXG4gICAgdmVydGljYWw6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVGhlIG1pbmltdW0gdmFsdWUgb2YgdGhlIFNsaWRlciAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHByZWRlZmluZWRzdGVwc19zbGlkZXIgJX0jdG9jLXNtYWxsLXN0ZXBzKSkuXG4gICAgICogVGhlIGF0dHJpYnV0ZSBhY2NlcHRzIGJvdGggaW50ZWdlcnMgYW5kIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gICAgICovXG4gICAgbWluOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gdmFsdWUgb2YgdGhlIFNsaWRlciAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHByZWRlZmluZWRzdGVwc19zbGlkZXIgJX0jdG9jLXNtYWxsLXN0ZXBzKSkuXG4gICAgICogVGhlIGF0dHJpYnV0ZSBhY2NlcHRzIGJvdGggaW50ZWdlcnMgYW5kIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gICAgICovXG4gICAgbWF4OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIHN0ZXAgdmFsdWUgb2YgdGhlIFNsaWRlciAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHByZWRlZmluZWRzdGVwc19zbGlkZXIgJX0jdG9jLXNtYWxsLXN0ZXBzKSkuXG4gICAgICogQWNjZXB0cyBwb3NpdGl2ZSB2YWx1ZXMgb25seS4gQ2FuIGJlIGFuIGludGVnZXIgb3IgYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4gICAgICovXG4gICAgc21hbGxTdGVwOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoYXQgZXZlcnkgbjxzdXA+dGg8L3N1cD4gdGljayB3aWxsIGJlIGxhcmdlIGFuZCB3aWxsIGhhdmUgYSBsYWJlbFxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcHJlZGVmaW5lZHN0ZXBzX3NsaWRlciAlfSN0b2MtbGFyZ2Utc3RlcHMpKS5cbiAgICAgKiBBY2NlcHRzIHBvc2l0aXZlIGludGVnZXIgdmFsdWVzIG9ubHkuXG4gICAgICovXG4gICAgbGFyZ2VTdGVwOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgd2lkdGggYmV0d2VlbiBlYWNoIHR3byB0aWNrcyBhbG9uZyB0aGUgdHJhY2sgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyB0aWNrc19zbGlkZXIgJX0jdG9jLXdpZHRoKSkuIFRoZSB2YWx1ZVxuICAgICAqIGhhcyB0byBiZSBzZXQgaW4gcGl4ZWxzLiBJZiBubyBgZml4ZWRUaWNrV2lkdGhgIGlzIHByb3ZpZGVkLCB0aGUgU2xpZGVyIGF1dG9tYXRpY2FsbHkgYWRqdXN0cyB0aGUgdGljayB3aWR0aCB0b1xuICAgICAqIGFjY29tbW9kYXRlIHRoZSBlbGVtZW50cyB3aXRoaW4gdGhlIHNpemUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBmaXhlZFRpY2tXaWR0aDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgU2xpZGVyIGlzIGRpc2FibGVkIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGlzYWJsZWRzdGF0ZV9zbGlkZXIgJX0pKS5cbiAgICAgKi9cbiAgICBkaXNhYmxlZDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIFNsaWRlciBpcyBpbiBpdHMgcmVhZC1vbmx5IHN0YXRlIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcmVhZG9ubHlfc2xpZGVyICV9KSkuXG4gICAgICovXG4gICAgcmVhZG9ubHk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIFNsaWRlciB3aGVuIGl0IGlzIGluaXRpYWxseSBkaXNwbGF5ZWQuXG4gICAgICogVGhlIGNvbXBvbmVudCBjYW4gdXNlIGVpdGhlciBOZ01vZGVsIG9yIHRoZSBgdmFsdWVgIGJpbmRpbmcgYnV0IG5vdCBib3RoIG9mIHRoZW0gYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgKi9cbiAgICB2YWx1ZTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgW2B0YWJpbmRleGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXgpIG9mIHRoZSBTbGlkZXIuXG4gICAgICovXG4gICAgdGFiaW5kZXg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdGFiSW5kZXg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHVzZXIgZm9jdXNlcyB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgICAqL1xuICAgIG9uRm9jdXM6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgYGlucHV0YCBlbGVtZW50IGdldHMgYmx1cnJlZC5cbiAgICAgKi9cbiAgICBvbkJsdXI6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdXNlciBzZWxlY3RzIGEgbmV3IHZhbHVlLlxuICAgICAqL1xuICAgIHZhbHVlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICB3cmFwcGVyOiBFbGVtZW50UmVmO1xuICAgIHRyYWNrOiBFbGVtZW50UmVmO1xuICAgIGRyYWdoYW5kbGU6IEVsZW1lbnRSZWY7XG4gICAgc2xpZGVyU2VsZWN0aW9uOiBFbGVtZW50UmVmO1xuICAgIHRpY2tzQ29udGFpbmVyOiBFbGVtZW50UmVmO1xuICAgIHRpY2tzOiBhbnk7XG4gICAgZGVjcmVhc2VCdXR0b246IEVsZW1lbnRSZWY7XG4gICAgaW5jcmVhc2VCdXR0b246IEVsZW1lbnRSZWY7XG4gICAgbGFiZWxUZW1wbGF0ZTogTGFiZWxUZW1wbGF0ZURpcmVjdGl2ZTtcbiAgICBkaXJlY3Rpb246IHN0cmluZztcbiAgICByZWFkb25seSBob3Jpem9udGFsQ2xhc3M6IGJvb2xlYW47XG4gICAgcmVhZG9ubHkgdmVydGljYWxDbGFzczogYm9vbGVhbjtcbiAgICBzbGlkZXJDbGFzczogYm9vbGVhbjtcbiAgICB3aWRnZXRDbGFzczogYm9vbGVhbjtcbiAgICBzdGF0ZURlZmF1bHRDbGFzczogYm9vbGVhbjtcbiAgICByZWFkb25seSBkaXNhYmxlZENsYXNzOiBib29sZWFuO1xuICAgIHJlYWRvbmx5IGFyaWFEaXNhYmxlZDogYm9vbGVhbjtcbiAgICByZWFkb25seSBhcmlhUmVhZG9ubHk6IGJvb2xlYW47XG4gICAgcmVhZG9ubHkgYXJpYU1pbjogbnVtYmVyO1xuICAgIHJlYWRvbmx5IGFyaWFNYXg6IG51bWJlcjtcbiAgICByZWFkb25seSBhcmlhVmFsdWU6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uO1xuICAgIHByb3RlY3RlZCBpc0ZvY3VzZWQ6IGJvb2xlYW47XG4gICAgcHJvdGVjdGVkIGlzRHJhZ2dlZDogYm9vbGVhbjtcbiAgICBwcm90ZWN0ZWQgY29udHJvbDogTmdDb250cm9sO1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvblNlcnZpY2U6IExvY2FsaXphdGlvblNlcnZpY2UsIGluamVjdG9yOiBJbmplY3RvciwgcmVuZGVyZXI6IFJlbmRlcmVyMiwgbmdab25lOiBOZ1pvbmUsIGhvc3RFbGVtZW50OiBFbGVtZW50UmVmKTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHN0YXR1cyBvZiB0aGUgY29tcG9uZW50IGNoYW5nZXMgdG8gb3IgZnJvbSBgZGlzYWJsZWRgLlxuICAgICAqIERlcGVuZGluZyBvbiB0aGUgdmFsdWUsIGl0IGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGFwcHJvcHJpYXRlIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlzRGlzYWJsZWRcbiAgICAgKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVGb2N1czogKCkgPT4gdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlQmx1cjogKCkgPT4gdm9pZDtcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIFNsaWRlci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICogIDxidXR0b24gKGNsaWNrKT1cInNsaWRlci5mb2N1cygpXCI+Rm9jdXM8L2J1dHRvbj5cbiAgICAgKiAgPGtlbmRvLXNsaWRlciAjc2xpZGVyPjwva2VuZG8tc2xpZGVyPlxuICAgICAqIGBcbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIEFwcENvbXBvbmVudCB7IH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmb2N1cygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEJsdXJzIHRoZSBTbGlkZXIuXG4gICAgICovXG4gICAgYmx1cigpOiB2b2lkO1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkO1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkO1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlYWRvbmx5IGluY3JlbWVudE1lc3NhZ2U6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVhZG9ubHkgZGVjcmVtZW50TWVzc2FnZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWFkb25seSBkcmFnSGFuZGxlTWVzc2FnZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbldyYXBDbGljazogKGFyZ3M6IGFueSkgPT4gdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaWZFbmFibGVkOiBGdW5jdGlvbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlRHJhZ1ByZXNzKGFyZ3M6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uSGFuZGxlRHJhZyhhcmdzOiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbktleURvd246IChlOiBhbnkpID0+IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uSGFuZGxlUmVsZWFzZSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBudW1iZXIpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiAoKSA9PiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogKCkgPT4gYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY2hhbmdlVmFsdWUodmFsdWU6IG51bWJlcik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNpemVDb21wb25lbnQoYW5pbWF0ZTogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlYWRvbmx5IGlzRGlzYWJsZWQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFVzZWQgYnkgdGhlIFRleHRCb3hDb250YWluZXIgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjb21wb25lbnQgaXMgZW1wdHkuXG4gICAgICovXG4gICAgaXNFbXB0eSgpOiBib29sZWFuO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgcmV2ZXJzZTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGtleUJpbmRpbmc7XG4gICAgcHJpdmF0ZSBmb2N1c2VkO1xuICAgIHByaXZhdGUgZHJhZ2dpbmc7XG4gICAgcHJpdmF0ZSBzZXRWYWx1ZUNoYW5nZUludGVydmFsO1xuICAgIHByaXZhdGUgbmdDaGFuZ2U7XG4gICAgcHJpdmF0ZSBuZ1RvdWNoZWQ7XG4gICAgcHJpdmF0ZSBkZWNyZWFzZVZhbHVlO1xuICAgIHByaXZhdGUgaW5jcmVhc2VWYWx1ZTtcbiAgICBwcml2YXRlIGdldFByb3BzO1xuICAgIHByaXZhdGUgcmVzZXRTdHlsZXM7XG59XG4iXX0=