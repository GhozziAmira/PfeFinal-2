/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { EventEmitter } from '@angular/core';
import { DateFieldNameOptions, DateFormatOptions, DateFormatNameOptions, NumberFormatOptions, DateFormatPart, DayRange } from '@telerik/kendo-intl';
/**
 * @hidden
 */
import * as ɵngcc0 from '@angular/core';
export declare function cldrServiceFactory(localeId: string): CldrIntlService;
/**
 * An abstract base class that implements
 * the Internationalization service methods
 * for the current locale.
 */
export declare abstract class IntlService {
    /**
     * @hidden
     */
    readonly changes: EventEmitter<any>;
    /**
     * Notifies that the service was changed.
     */
    notify(): void;
    /**
     * Formats a string with placeholders such as
     * `Total amount {0:c}`.
     *
     * @param format - The format string.
     * @param values - One or more values to output in the format string placeholders.
     * @return - The formatted string.
     */
    abstract format(format: string, ...values: any[]): string;
    /**
     * Converts an object into a string based on the specified format.
     *
     * @param value - The value to format.
     * @param format - The format to use.
     * @param localeId - The locale ID to use in place of the default. Optional.
     * @return - The formatted object.
     */
    abstract toString(value: any, format: string | any, localeId?: string): string;
    /**
     * Converts a `Date` object into a string based on the specified format.
     * If no format is provided, the default short date format is used.
     *
     * @param value - The date to format.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default. Optional.
     * @return - The formatted date.
     */
    abstract formatDate(value: Date, format?: String | DateFormatOptions, localeId?: string): string;
    /**
     * Converts a string into a `Date` object based on the specified format.
     *
     * @param value - The string to convert.
     * @param format - The format strings or options.
     * @param localeId - The locale ID to use in place of the default. Optional.
     * @return - The parsed date.
     */
    abstract parseDate(value: string, format?: string | DateFormatOptions | string[] | DateFormatOptions[], localeId?: string): Date;
    /**
     * Converts a string into a `Number`.
     *
     * @param value - The string to convert.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default. Optional.
     * @return - The parsed number.
     */
    abstract parseNumber(value: string, format?: string | NumberFormatOptions, localeId?: string): number;
    /**
     * Converts a `Number` into a string based on the specified format.
     *
     * @param value - The number to format.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default. Optional.
     * @return - The formatted number.
     */
    abstract formatNumber(value: number, format: string | NumberFormatOptions, localeId?: string): string;
    /**
     * Returns the day names from the current locale based on the option.
     *
     * @param options - Detailed configuration for the desired date format.
     * @param localeId - The locale ID to use in place of the default. Optional.
     * @return - The day names from the current locale based on the option.
     */
    abstract dateFormatNames(options: DateFormatNameOptions, localeId?: string): any;
    /**
     * Returns a localized date field name based on specific dateFieldName options.
     *
     * @param options - Detailed configuration for the desired date field name.
     * @param localeId The optional locale id. If not specified, the `"en"` locale id is used.
     * @returns The localized date field name from the current locale based on the option.
     *
     * @example
     * ```
     * dateFieldName({ type: 'day' });                      //returns 'day';
     * dateFieldName({ type: 'day', nameType: 'wide' });    //returns 'day';
     * dateFieldName({ type: 'month', nameType: 'short' }); //returns 'mo.';
     * dateFieldName({ type: 'month', nameType: 'wide' });  //returns 'month';
     * ```
     */
    abstract dateFieldName(options: DateFieldNameOptions, localeId?: string): string;
    /**
     * Splits the date format into objects containing information about each part of the pattern.
     *
     * @param format The format string or options.
     * @param localeId The optional locale id. If not specified, the `"en"` locale id is used.
     * @returns The date format parts.
     */
    abstract splitDateFormat(format: string | DateFormatOptions, localeId?: string): DateFormatPart[];
    /**
     * Returns the number symbols from the current locale based on the option.
     *
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return - The number symbols from the current locale.
     */
    abstract numberSymbols(localeId?: string): any;
    /**
     * Returns the first day index starting from Sunday.
     *
     * @param localeId - The locale ID. Defaults to the current locale ID.
     * @return - The index of the first day of the week (0 == Sunday).
     */
    abstract firstDay(localeId?: string): number;
    /**
     * Returns the start and end index of the locale weekend starting from Sunday.
     *
     * @param localeId - The locale ID. Defaults to the current locale ID.
     * @return - The the start and end index of the locale weekend (0 == Sunday).
     */
    abstract weekendRange(localeId?: string): DayRange;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IntlService>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<IntlService>;
}
/**
 * The Internationalization service implemented by using
 * the CLDR Database via the `@telerik/kendo-intl` package.
 */
export declare class CldrIntlService extends IntlService {
    private locale;
    /**
     * Gets or sets the current locale ID.
     */
    localeId: string;
    /**
     * Creates a new instance of the service with the ID of the specified locale.
     *
     * Note that the parts of the locale ID can be separated by either `_` (underscore)
     * or `-` (dash).
     *
     * @param localeId - The default locale ID.
     */
    constructor(localeId: string);
    /**
     * Formats a string with placeholders such as
     * `Total amount {0:c}`.
     *
     * @param format - The format string.
     * @param values - One or more values to output in the format string placeholders.
     * @return - The formatted string.
     */
    format(format: string, ...values: any[]): string;
    /**
     * Converts an object into a string based on the specified format.
     *
     * @param value - The value to format.
     * @param format - The format to use.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The formatted object.
     */
    toString(value: any, format: string | any, localeId?: string): string;
    /**
     * Converts a `Date` object into a string based on the specified format.
     * If no format is provided, the default short date format is used.
     *
     * @param value - The date to format.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The formatted date.
     */
    formatDate(value: Date, format?: String | DateFormatOptions, localeId?: string): string;
    /**
     * Converts a string into a `Date` object based on the specified format.
     *
     * @param value - The string to convert.
     * @param format - The format strings or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The parsed date.
     */
    parseDate(value: string, format?: string | DateFormatOptions | string[] | DateFormatOptions[], localeId?: string): Date;
    /**
     * Converts a string into a `Number`.
     *
     * @param value - The string to convert.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The parsed number.
     */
    parseNumber(value: string, format?: string | NumberFormatOptions, localeId?: string): number;
    /**
     * Converts a `Number` into a string based on the specified format.
     *
     * @param value - The number to format.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The formatted number.
     */
    formatNumber(value: number, format: string | NumberFormatOptions, localeId?: string): string;
    /**
     * Returns the date names from the current locale based on the option.
     *
     * The available `type` values are:
     * - `era`
     * - `year`
     * - `quarter`
     * - `month`
     * - `week`
     * - `day`
     * - `dayperiod`
     * - `hour`
     * - `minute`
     * - `second`
     * - `zone`
     *
     * The available `nameType` values are:
     * - `wide`
     * - `narrow`
     * - `short`
     *
     * @param options - Detailed configuration for the desired date field name.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return - The day names from the current locale based on the option.
     * @returns The localized date field name from the current locale based on the option.
     *
     * @example
     * ```
     * dateFieldName({ type: 'day' });                      //returns 'day';
     * dateFieldName({ type: 'day', nameType: 'wide' });    //returns 'day';
     * dateFieldName({ type: 'month', nameType: 'short' }); //returns 'mo.';
     * dateFieldName({ type: 'month', nameType: 'wide' });  //returns 'month';
     * ```
     */
    dateFieldName(options: DateFieldNameOptions, localeId?: string): string;
    /**
     * Returns a localized date field name based on specific dateFieldName options.
     *
     * The available type values are:
     * - `day`
     * - `dayperiod`
     * - `months`
     * - `quarters`
     * - `eras`
     *
     * @param options - Detailed configuration for the desired date format.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return - The day names from the current locale based on the option.
     */
    dateFormatNames(options: DateFormatNameOptions, localeId?: string): any;
    /**
     * Splits the date format into objects containing information about each part of the pattern.
     *
     * @param format The format string or options.
     * @param localeId The optional locale id. If not specified, the `"en"` locale id is used.
     * @returns The date format parts.
     */
    splitDateFormat(format: string | DateFormatOptions, localeId?: string): DateFormatPart[];
    /**
     * Returns the number symbols from the current locale based on the option.
     *
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return - The number symbols from the current locale.
     */
    numberSymbols(localeId?: string): any;
    /**
     * Returns the first day index starting from Sunday.
     *
     * @param localeId - The locale ID. Defaults to the current locale ID.
     * @return - The index of the first day of the week (0 == Sunday).
     */
    firstDay(localeId?: string): number;
    /**
     * Returns the start and end index of the locale weekend starting from Sunday.
     *
     * @param localeId - The locale ID. Defaults to the current locale ID.
     * @return - The the start and end index of the locale weekend (0 == Sunday).
     */
    weekendRange(localeId?: string): DayRange;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<CldrIntlService>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<CldrIntlService>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50bC5zZXJ2aWNlLmQudHMiLCJzb3VyY2VzIjpbImludGwuc2VydmljZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7O0FBU0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkhBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwSkEiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERhdGVGaWVsZE5hbWVPcHRpb25zLCBEYXRlRm9ybWF0T3B0aW9ucywgRGF0ZUZvcm1hdE5hbWVPcHRpb25zLCBOdW1iZXJGb3JtYXRPcHRpb25zLCBEYXRlRm9ybWF0UGFydCwgRGF5UmFuZ2UgfSBmcm9tICdAdGVsZXJpay9rZW5kby1pbnRsJztcbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBjbGRyU2VydmljZUZhY3RvcnkobG9jYWxlSWQ6IHN0cmluZyk6IENsZHJJbnRsU2VydmljZTtcbi8qKlxuICogQW4gYWJzdHJhY3QgYmFzZSBjbGFzcyB0aGF0IGltcGxlbWVudHNcbiAqIHRoZSBJbnRlcm5hdGlvbmFsaXphdGlvbiBzZXJ2aWNlIG1ldGhvZHNcbiAqIGZvciB0aGUgY3VycmVudCBsb2NhbGUuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGFic3RyYWN0IGNsYXNzIEludGxTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVhZG9ubHkgY2hhbmdlczogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgLyoqXG4gICAgICogTm90aWZpZXMgdGhhdCB0aGUgc2VydmljZSB3YXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBub3RpZnkoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBGb3JtYXRzIGEgc3RyaW5nIHdpdGggcGxhY2Vob2xkZXJzIHN1Y2ggYXNcbiAgICAgKiBgVG90YWwgYW1vdW50IHswOmN9YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZy5cbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gT25lIG9yIG1vcmUgdmFsdWVzIHRvIG91dHB1dCBpbiB0aGUgZm9ybWF0IHN0cmluZyBwbGFjZWhvbGRlcnMuXG4gICAgICogQHJldHVybiAtIFRoZSBmb3JtYXR0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGFic3RyYWN0IGZvcm1hdChmb3JtYXQ6IHN0cmluZywgLi4udmFsdWVzOiBhbnlbXSk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIHN0cmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGZvcm1hdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmb3JtYXQuXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0LiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIGZvcm1hdHRlZCBvYmplY3QuXG4gICAgICovXG4gICAgYWJzdHJhY3QgdG9TdHJpbmcodmFsdWU6IGFueSwgZm9ybWF0OiBzdHJpbmcgfCBhbnksIGxvY2FsZUlkPzogc3RyaW5nKTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgYERhdGVgIG9iamVjdCBpbnRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqIElmIG5vIGZvcm1hdCBpcyBwcm92aWRlZCwgdGhlIGRlZmF1bHQgc2hvcnQgZGF0ZSBmb3JtYXQgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBkYXRlIHRvIGZvcm1hdC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdC4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiAtIFRoZSBmb3JtYXR0ZWQgZGF0ZS5cbiAgICAgKi9cbiAgICBhYnN0cmFjdCBmb3JtYXREYXRlKHZhbHVlOiBEYXRlLCBmb3JtYXQ/OiBTdHJpbmcgfCBEYXRlRm9ybWF0T3B0aW9ucywgbG9jYWxlSWQ/OiBzdHJpbmcpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzdHJpbmcgaW50byBhIGBEYXRlYCBvYmplY3QgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5ncyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0LiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIHBhcnNlZCBkYXRlLlxuICAgICAqL1xuICAgIGFic3RyYWN0IHBhcnNlRGF0ZSh2YWx1ZTogc3RyaW5nLCBmb3JtYXQ/OiBzdHJpbmcgfCBEYXRlRm9ybWF0T3B0aW9ucyB8IHN0cmluZ1tdIHwgRGF0ZUZvcm1hdE9wdGlvbnNbXSwgbG9jYWxlSWQ/OiBzdHJpbmcpOiBEYXRlO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIGludG8gYSBgTnVtYmVyYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdC4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiAtIFRoZSBwYXJzZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIGFic3RyYWN0IHBhcnNlTnVtYmVyKHZhbHVlOiBzdHJpbmcsIGZvcm1hdD86IHN0cmluZyB8IE51bWJlckZvcm1hdE9wdGlvbnMsIGxvY2FsZUlkPzogc3RyaW5nKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgYE51bWJlcmAgaW50byBhIHN0cmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGZvcm1hdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1iZXIgdG8gZm9ybWF0LlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0LiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIGZvcm1hdHRlZCBudW1iZXIuXG4gICAgICovXG4gICAgYWJzdHJhY3QgZm9ybWF0TnVtYmVyKHZhbHVlOiBudW1iZXIsIGZvcm1hdDogc3RyaW5nIHwgTnVtYmVyRm9ybWF0T3B0aW9ucywgbG9jYWxlSWQ/OiBzdHJpbmcpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGF5IG5hbWVzIGZyb20gdGhlIGN1cnJlbnQgbG9jYWxlIGJhc2VkIG9uIHRoZSBvcHRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIERldGFpbGVkIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBkZXNpcmVkIGRhdGUgZm9ybWF0LlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0LiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIGRheSBuYW1lcyBmcm9tIHRoZSBjdXJyZW50IGxvY2FsZSBiYXNlZCBvbiB0aGUgb3B0aW9uLlxuICAgICAqL1xuICAgIGFic3RyYWN0IGRhdGVGb3JtYXROYW1lcyhvcHRpb25zOiBEYXRlRm9ybWF0TmFtZU9wdGlvbnMsIGxvY2FsZUlkPzogc3RyaW5nKTogYW55O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsb2NhbGl6ZWQgZGF0ZSBmaWVsZCBuYW1lIGJhc2VkIG9uIHNwZWNpZmljIGRhdGVGaWVsZE5hbWUgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gRGV0YWlsZWQgY29uZmlndXJhdGlvbiBmb3IgdGhlIGRlc2lyZWQgZGF0ZSBmaWVsZCBuYW1lLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCBUaGUgb3B0aW9uYWwgbG9jYWxlIGlkLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgYFwiZW5cImAgbG9jYWxlIGlkIGlzIHVzZWQuXG4gICAgICogQHJldHVybnMgVGhlIGxvY2FsaXplZCBkYXRlIGZpZWxkIG5hbWUgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUgYmFzZWQgb24gdGhlIG9wdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgXG4gICAgICogZGF0ZUZpZWxkTmFtZSh7IHR5cGU6ICdkYXknIH0pOyAgICAgICAgICAgICAgICAgICAgICAvL3JldHVybnMgJ2RheSc7XG4gICAgICogZGF0ZUZpZWxkTmFtZSh7IHR5cGU6ICdkYXknLCBuYW1lVHlwZTogJ3dpZGUnIH0pOyAgICAvL3JldHVybnMgJ2RheSc7XG4gICAgICogZGF0ZUZpZWxkTmFtZSh7IHR5cGU6ICdtb250aCcsIG5hbWVUeXBlOiAnc2hvcnQnIH0pOyAvL3JldHVybnMgJ21vLic7XG4gICAgICogZGF0ZUZpZWxkTmFtZSh7IHR5cGU6ICdtb250aCcsIG5hbWVUeXBlOiAnd2lkZScgfSk7ICAvL3JldHVybnMgJ21vbnRoJztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBkYXRlRmllbGROYW1lKG9wdGlvbnM6IERhdGVGaWVsZE5hbWVPcHRpb25zLCBsb2NhbGVJZD86IHN0cmluZyk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBTcGxpdHMgdGhlIGRhdGUgZm9ybWF0IGludG8gb2JqZWN0cyBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IGVhY2ggcGFydCBvZiB0aGUgcGF0dGVybi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmb3JtYXQgVGhlIGZvcm1hdCBzdHJpbmcgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgVGhlIG9wdGlvbmFsIGxvY2FsZSBpZC4gSWYgbm90IHNwZWNpZmllZCwgdGhlIGBcImVuXCJgIGxvY2FsZSBpZCBpcyB1c2VkLlxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRlIGZvcm1hdCBwYXJ0cy5cbiAgICAgKi9cbiAgICBhYnN0cmFjdCBzcGxpdERhdGVGb3JtYXQoZm9ybWF0OiBzdHJpbmcgfCBEYXRlRm9ybWF0T3B0aW9ucywgbG9jYWxlSWQ/OiBzdHJpbmcpOiBEYXRlRm9ybWF0UGFydFtdO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBzeW1ib2xzIGZyb20gdGhlIGN1cnJlbnQgbG9jYWxlIGJhc2VkIG9uIHRoZSBvcHRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gLSBUaGUgbnVtYmVyIHN5bWJvbHMgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUuXG4gICAgICovXG4gICAgYWJzdHJhY3QgbnVtYmVyU3ltYm9scyhsb2NhbGVJZD86IHN0cmluZyk6IGFueTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBkYXkgaW5kZXggc3RhcnRpbmcgZnJvbSBTdW5kYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElELiBEZWZhdWx0cyB0byB0aGUgY3VycmVudCBsb2NhbGUgSUQuXG4gICAgICogQHJldHVybiAtIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrICgwID09IFN1bmRheSkuXG4gICAgICovXG4gICAgYWJzdHJhY3QgZmlyc3REYXkobG9jYWxlSWQ/OiBzdHJpbmcpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RhcnQgYW5kIGVuZCBpbmRleCBvZiB0aGUgbG9jYWxlIHdlZWtlbmQgc3RhcnRpbmcgZnJvbSBTdW5kYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElELiBEZWZhdWx0cyB0byB0aGUgY3VycmVudCBsb2NhbGUgSUQuXG4gICAgICogQHJldHVybiAtIFRoZSB0aGUgc3RhcnQgYW5kIGVuZCBpbmRleCBvZiB0aGUgbG9jYWxlIHdlZWtlbmQgKDAgPT0gU3VuZGF5KS5cbiAgICAgKi9cbiAgICBhYnN0cmFjdCB3ZWVrZW5kUmFuZ2UobG9jYWxlSWQ/OiBzdHJpbmcpOiBEYXlSYW5nZTtcbn1cbi8qKlxuICogVGhlIEludGVybmF0aW9uYWxpemF0aW9uIHNlcnZpY2UgaW1wbGVtZW50ZWQgYnkgdXNpbmdcbiAqIHRoZSBDTERSIERhdGFiYXNlIHZpYSB0aGUgYEB0ZWxlcmlrL2tlbmRvLWludGxgIHBhY2thZ2UuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIENsZHJJbnRsU2VydmljZSBleHRlbmRzIEludGxTZXJ2aWNlIHtcbiAgICBwcml2YXRlIGxvY2FsZTtcbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGN1cnJlbnQgbG9jYWxlIElELlxuICAgICAqL1xuICAgIGxvY2FsZUlkOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgc2VydmljZSB3aXRoIHRoZSBJRCBvZiB0aGUgc3BlY2lmaWVkIGxvY2FsZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGUgcGFydHMgb2YgdGhlIGxvY2FsZSBJRCBjYW4gYmUgc2VwYXJhdGVkIGJ5IGVpdGhlciBgX2AgKHVuZGVyc2NvcmUpXG4gICAgICogb3IgYC1gIChkYXNoKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBkZWZhdWx0IGxvY2FsZSBJRC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGVJZDogc3RyaW5nKTtcbiAgICAvKipcbiAgICAgKiBGb3JtYXRzIGEgc3RyaW5nIHdpdGggcGxhY2Vob2xkZXJzIHN1Y2ggYXNcbiAgICAgKiBgVG90YWwgYW1vdW50IHswOmN9YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZy5cbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gT25lIG9yIG1vcmUgdmFsdWVzIHRvIG91dHB1dCBpbiB0aGUgZm9ybWF0IHN0cmluZyBwbGFjZWhvbGRlcnMuXG4gICAgICogQHJldHVybiAtIFRoZSBmb3JtYXR0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQ6IHN0cmluZywgLi4udmFsdWVzOiBhbnlbXSk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIHN0cmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGZvcm1hdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmb3JtYXQuXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiBUaGUgZm9ybWF0dGVkIG9iamVjdC5cbiAgICAgKi9cbiAgICB0b1N0cmluZyh2YWx1ZTogYW55LCBmb3JtYXQ6IHN0cmluZyB8IGFueSwgbG9jYWxlSWQ/OiBzdHJpbmcpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBgRGF0ZWAgb2JqZWN0IGludG8gYSBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBmb3JtYXQuXG4gICAgICogSWYgbm8gZm9ybWF0IGlzIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBzaG9ydCBkYXRlIGZvcm1hdCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIGRhdGUgdG8gZm9ybWF0LlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiBUaGUgZm9ybWF0dGVkIGRhdGUuXG4gICAgICovXG4gICAgZm9ybWF0RGF0ZSh2YWx1ZTogRGF0ZSwgZm9ybWF0PzogU3RyaW5nIHwgRGF0ZUZvcm1hdE9wdGlvbnMsIGxvY2FsZUlkPzogc3RyaW5nKTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIGludG8gYSBgRGF0ZWAgb2JqZWN0IGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZ3Mgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gVGhlIHBhcnNlZCBkYXRlLlxuICAgICAqL1xuICAgIHBhcnNlRGF0ZSh2YWx1ZTogc3RyaW5nLCBmb3JtYXQ/OiBzdHJpbmcgfCBEYXRlRm9ybWF0T3B0aW9ucyB8IHN0cmluZ1tdIHwgRGF0ZUZvcm1hdE9wdGlvbnNbXSwgbG9jYWxlSWQ/OiBzdHJpbmcpOiBEYXRlO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIGludG8gYSBgTnVtYmVyYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gVGhlIHBhcnNlZCBudW1iZXIuXG4gICAgICovXG4gICAgcGFyc2VOdW1iZXIodmFsdWU6IHN0cmluZywgZm9ybWF0Pzogc3RyaW5nIHwgTnVtYmVyRm9ybWF0T3B0aW9ucywgbG9jYWxlSWQ/OiBzdHJpbmcpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBgTnVtYmVyYCBpbnRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIG51bWJlciB0byBmb3JtYXQuXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5nIG9yIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIFRoZSBmb3JtYXR0ZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIGZvcm1hdE51bWJlcih2YWx1ZTogbnVtYmVyLCBmb3JtYXQ6IHN0cmluZyB8IE51bWJlckZvcm1hdE9wdGlvbnMsIGxvY2FsZUlkPzogc3RyaW5nKTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRhdGUgbmFtZXMgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUgYmFzZWQgb24gdGhlIG9wdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBhdmFpbGFibGUgYHR5cGVgIHZhbHVlcyBhcmU6XG4gICAgICogLSBgZXJhYFxuICAgICAqIC0gYHllYXJgXG4gICAgICogLSBgcXVhcnRlcmBcbiAgICAgKiAtIGBtb250aGBcbiAgICAgKiAtIGB3ZWVrYFxuICAgICAqIC0gYGRheWBcbiAgICAgKiAtIGBkYXlwZXJpb2RgXG4gICAgICogLSBgaG91cmBcbiAgICAgKiAtIGBtaW51dGVgXG4gICAgICogLSBgc2Vjb25kYFxuICAgICAqIC0gYHpvbmVgXG4gICAgICpcbiAgICAgKiBUaGUgYXZhaWxhYmxlIGBuYW1lVHlwZWAgdmFsdWVzIGFyZTpcbiAgICAgKiAtIGB3aWRlYFxuICAgICAqIC0gYG5hcnJvd2BcbiAgICAgKiAtIGBzaG9ydGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gRGV0YWlsZWQgY29uZmlndXJhdGlvbiBmb3IgdGhlIGRlc2lyZWQgZGF0ZSBmaWVsZCBuYW1lLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiAtIFRoZSBkYXkgbmFtZXMgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUgYmFzZWQgb24gdGhlIG9wdGlvbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgbG9jYWxpemVkIGRhdGUgZmllbGQgbmFtZSBmcm9tIHRoZSBjdXJyZW50IGxvY2FsZSBiYXNlZCBvbiB0aGUgb3B0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiBkYXRlRmllbGROYW1lKHsgdHlwZTogJ2RheScgfSk7ICAgICAgICAgICAgICAgICAgICAgIC8vcmV0dXJucyAnZGF5JztcbiAgICAgKiBkYXRlRmllbGROYW1lKHsgdHlwZTogJ2RheScsIG5hbWVUeXBlOiAnd2lkZScgfSk7ICAgIC8vcmV0dXJucyAnZGF5JztcbiAgICAgKiBkYXRlRmllbGROYW1lKHsgdHlwZTogJ21vbnRoJywgbmFtZVR5cGU6ICdzaG9ydCcgfSk7IC8vcmV0dXJucyAnbW8uJztcbiAgICAgKiBkYXRlRmllbGROYW1lKHsgdHlwZTogJ21vbnRoJywgbmFtZVR5cGU6ICd3aWRlJyB9KTsgIC8vcmV0dXJucyAnbW9udGgnO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGRhdGVGaWVsZE5hbWUob3B0aW9uczogRGF0ZUZpZWxkTmFtZU9wdGlvbnMsIGxvY2FsZUlkPzogc3RyaW5nKTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsb2NhbGl6ZWQgZGF0ZSBmaWVsZCBuYW1lIGJhc2VkIG9uIHNwZWNpZmljIGRhdGVGaWVsZE5hbWUgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIFRoZSBhdmFpbGFibGUgdHlwZSB2YWx1ZXMgYXJlOlxuICAgICAqIC0gYGRheWBcbiAgICAgKiAtIGBkYXlwZXJpb2RgXG4gICAgICogLSBgbW9udGhzYFxuICAgICAqIC0gYHF1YXJ0ZXJzYFxuICAgICAqIC0gYGVyYXNgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIERldGFpbGVkIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBkZXNpcmVkIGRhdGUgZm9ybWF0LlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiAtIFRoZSBkYXkgbmFtZXMgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUgYmFzZWQgb24gdGhlIG9wdGlvbi5cbiAgICAgKi9cbiAgICBkYXRlRm9ybWF0TmFtZXMob3B0aW9uczogRGF0ZUZvcm1hdE5hbWVPcHRpb25zLCBsb2NhbGVJZD86IHN0cmluZyk6IGFueTtcbiAgICAvKipcbiAgICAgKiBTcGxpdHMgdGhlIGRhdGUgZm9ybWF0IGludG8gb2JqZWN0cyBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IGVhY2ggcGFydCBvZiB0aGUgcGF0dGVybi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmb3JtYXQgVGhlIGZvcm1hdCBzdHJpbmcgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgVGhlIG9wdGlvbmFsIGxvY2FsZSBpZC4gSWYgbm90IHNwZWNpZmllZCwgdGhlIGBcImVuXCJgIGxvY2FsZSBpZCBpcyB1c2VkLlxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRlIGZvcm1hdCBwYXJ0cy5cbiAgICAgKi9cbiAgICBzcGxpdERhdGVGb3JtYXQoZm9ybWF0OiBzdHJpbmcgfCBEYXRlRm9ybWF0T3B0aW9ucywgbG9jYWxlSWQ/OiBzdHJpbmcpOiBEYXRlRm9ybWF0UGFydFtdO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBzeW1ib2xzIGZyb20gdGhlIGN1cnJlbnQgbG9jYWxlIGJhc2VkIG9uIHRoZSBvcHRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gLSBUaGUgbnVtYmVyIHN5bWJvbHMgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUuXG4gICAgICovXG4gICAgbnVtYmVyU3ltYm9scyhsb2NhbGVJZD86IHN0cmluZyk6IGFueTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBkYXkgaW5kZXggc3RhcnRpbmcgZnJvbSBTdW5kYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElELiBEZWZhdWx0cyB0byB0aGUgY3VycmVudCBsb2NhbGUgSUQuXG4gICAgICogQHJldHVybiAtIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrICgwID09IFN1bmRheSkuXG4gICAgICovXG4gICAgZmlyc3REYXkobG9jYWxlSWQ/OiBzdHJpbmcpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RhcnQgYW5kIGVuZCBpbmRleCBvZiB0aGUgbG9jYWxlIHdlZWtlbmQgc3RhcnRpbmcgZnJvbSBTdW5kYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElELiBEZWZhdWx0cyB0byB0aGUgY3VycmVudCBsb2NhbGUgSUQuXG4gICAgICogQHJldHVybiAtIFRoZSB0aGUgc3RhcnQgYW5kIGVuZCBpbmRleCBvZiB0aGUgbG9jYWxlIHdlZWtlbmQgKDAgPT0gU3VuZGF5KS5cbiAgICAgKi9cbiAgICB3ZWVrZW5kUmFuZ2UobG9jYWxlSWQ/OiBzdHJpbmcpOiBEYXlSYW5nZTtcbn1cbiJdfQ==