/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { EventEmitter, Inject, Injectable, LOCALE_ID, NgModule, Pipe, defineInjectable, inject } from '@angular/core';
import { dateFieldName, dateFormatNames, firstDay, format, formatDate, formatNumber, load, localeInfo, numberSymbols, parseDate, parseNumber, setData, splitDateFormat, toString, weekendRange } from '@telerik/kendo-intl';

import * as ɵngcc0 from '@angular/core';
const DOCS_URL = 'http://www.telerik.com/kendo-angular-ui/components/internationalization/troubleshooting/';
/**
 * @hidden
 */
const errorSolutions = {
    'NoCurrency': `Solution: ${DOCS_URL}#toc-no-currency`,
    'NoCurrencyDisplay': `Solution: ${DOCS_URL}#toc-no-currency-display`,
    'NoCurrencyRegion': `Solution: ${DOCS_URL}#toc-no-currency-region`,
    'NoDateFieldNames': `Solution: ${DOCS_URL}#toc-no-date-filed-names`,
    'NoFirstDay': `Solution: ${DOCS_URL}#toc-no-first-day`,
    'NoGMTInfo': `Solution: ${DOCS_URL}#toc-no-gmt-info`,
    'NoLocale': `Solution: ${DOCS_URL}#toc-no-locale`,
    'NoValidCurrency': `Solution: ${DOCS_URL}#toc-no-valid-currency`,
    'NoWeekData': `Solution: ${DOCS_URL}#toc-no-week-data`
};

function formatMessage(error) {
    const message = error.message;
    const errorSolution = errorSolutions[Object.keys(errorSolutions).filter(key => message.indexOf(key) === 0)[0]];
    return errorSolution ? `${message} ${errorSolution}` : message;
}
function intlMethod(fn) {
    return function (...values) {
        try {
            return fn.apply(null, values);
        }
        catch (error) {
            error.message = formatMessage(error);
            throw error;
        }
    };
}
/**
 * @hidden
 */
const dateFormatNames$1 = intlMethod(dateFormatNames);
/**
 * @hidden
 */
const dateFieldName$1 = intlMethod(dateFieldName);
/**
 * @hidden
 */
const firstDay$1 = intlMethod(firstDay);
/**
 * @hidden
 */
const format$1 = intlMethod(format);
/**
 * @hidden
 */
const formatDate$1 = intlMethod(formatDate);
/**
 * @hidden
 */
const formatNumber$1 = intlMethod(formatNumber);
/**
 * @hidden
 */
const load$1 = intlMethod(load);
/**
 * @hidden
 */
const numberSymbols$1 = intlMethod(numberSymbols);
/**
 * @hidden
 */
const parseDate$1 = intlMethod(parseDate);
/**
 * @hidden
 */
const parseNumber$1 = intlMethod(parseNumber);
/**
 * @hidden
 */
const splitDateFormat$1 = intlMethod(splitDateFormat);
/**
 * @hidden
 */
const toString$1 = intlMethod(toString);
/**
 * @hidden
 */
const weekendRange$1 = intlMethod(weekendRange);
/**
 * Sets a pre-built locale.
 *
 * @params data - The pre-built locale data.
 */
const setData$1 = (data) => setData(data);
/**
 * Retrieves the locale data for the specified locale.
 *
 * @params locale - The locale id.
 * @returns data - The locale data.
 */
const localeData = (locale) => {
    try {
        return localeInfo(locale);
    }
    catch (error) {
        error.message = formatMessage(error);
        throw error;
    }
};

const LOCALE_REGEX = /_/g;
/**
 * @hidden
 */
function cldrServiceFactory(localeId) {
    return new CldrIntlService(localeId);
}
/**
 * An abstract base class that implements
 * the Internationalization service methods
 * for the current locale.
 */
class IntlService {
    constructor() {
        /**
         * @hidden
         */
        this.changes = new EventEmitter();
    }
    /**
     * Notifies that the service was changed.
     */
    notify() {
        this.changes.emit();
    }
}
IntlService.ɵfac = function IntlService_Factory(t) { return new (t || IntlService)(); };
IntlService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IntlService, factory: function IntlService_Factory(t) { var r = null; if (t) {
        r = new t();
    }
    else {
        r = cldrServiceFactory(ɵngcc0.ɵɵinject(LOCALE_ID));
    } return r; }, providedIn: 'root' });
IntlService.ngInjectableDef = defineInjectable({ factory: function IntlService_Factory() { return cldrServiceFactory(inject(LOCALE_ID)); }, token: IntlService, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntlService, [{
        type: Injectable,
        args: [{
                providedIn: 'root',
                useFactory: cldrServiceFactory,
                deps: [LOCALE_ID]
            }]
    }], function () { return []; }, null); })();
/**
 * The Internationalization service implemented by using
 * the CLDR Database via the `@telerik/kendo-intl` package.
 */
class CldrIntlService extends IntlService {
    /**
     * Creates a new instance of the service with the ID of the specified locale.
     *
     * Note that the parts of the locale ID can be separated by either `_` (underscore)
     * or `-` (dash).
     *
     * @param localeId - The default locale ID.
     */
    constructor(localeId) {
        super();
        this.localeId = localeId;
    }
    /**
     * Gets or sets the current locale ID.
     */
    get localeId() {
        return this.locale;
    }
    set localeId(value) {
        // Angular locales use underscore, for example, en_US
        // while IETF BCP-47 specifies a dash.
        // https://tools.ietf.org/html/bcp47
        const locale = value.replace(LOCALE_REGEX, '-');
        if (locale !== this.locale) {
            this.locale = locale;
            this.notify();
        }
    }
    /**
     * Formats a string with placeholders such as
     * `Total amount {0:c}`.
     *
     * @param format - The format string.
     * @param values - One or more values to output in the format string placeholders.
     * @return - The formatted string.
     */
    format(format$$1, ...values) {
        return format$1(format$$1, values, this.localeId);
    }
    /**
     * Converts an object into a string based on the specified format.
     *
     * @param value - The value to format.
     * @param format - The format to use.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The formatted object.
     */
    toString(value, format$$1, localeId) {
        return toString$1(value, format$$1, localeId || this.localeId);
    }
    /**
     * Converts a `Date` object into a string based on the specified format.
     * If no format is provided, the default short date format is used.
     *
     * @param value - The date to format.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The formatted date.
     */
    formatDate(value, format$$1, localeId) {
        return formatDate$1(value, format$$1, localeId || this.localeId);
    }
    /**
     * Converts a string into a `Date` object based on the specified format.
     *
     * @param value - The string to convert.
     * @param format - The format strings or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The parsed date.
     */
    parseDate(value, format$$1, localeId) {
        return parseDate$1(value, format$$1, localeId || this.localeId);
    }
    /**
     * Converts a string into a `Number`.
     *
     * @param value - The string to convert.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The parsed number.
     */
    parseNumber(value, format$$1, localeId) {
        return parseNumber$1(value, localeId || this.localeId, format$$1);
    }
    /**
     * Converts a `Number` into a string based on the specified format.
     *
     * @param value - The number to format.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The formatted number.
     */
    formatNumber(value, format$$1, localeId) {
        return formatNumber$1(value, format$$1, localeId || this.localeId);
    }
    /**
     * Returns the date names from the current locale based on the option.
     *
     * The available `type` values are:
     * - `era`
     * - `year`
     * - `quarter`
     * - `month`
     * - `week`
     * - `day`
     * - `dayperiod`
     * - `hour`
     * - `minute`
     * - `second`
     * - `zone`
     *
     * The available `nameType` values are:
     * - `wide`
     * - `narrow`
     * - `short`
     *
     * @param options - Detailed configuration for the desired date field name.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return - The day names from the current locale based on the option.
     * @returns The localized date field name from the current locale based on the option.
     *
     * @example
     * ```
     * dateFieldName({ type: 'day' });                      //returns 'day';
     * dateFieldName({ type: 'day', nameType: 'wide' });    //returns 'day';
     * dateFieldName({ type: 'month', nameType: 'short' }); //returns 'mo.';
     * dateFieldName({ type: 'month', nameType: 'wide' });  //returns 'month';
     * ```
     */
    dateFieldName(options, localeId) {
        return dateFieldName$1(options, localeId || this.localeId);
    }
    /**
     * Returns a localized date field name based on specific dateFieldName options.
     *
     * The available type values are:
     * - `day`
     * - `dayperiod`
     * - `months`
     * - `quarters`
     * - `eras`
     *
     * @param options - Detailed configuration for the desired date format.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return - The day names from the current locale based on the option.
     */
    dateFormatNames(options, localeId) {
        return dateFormatNames$1(localeId || this.localeId, options);
    }
    /**
     * Splits the date format into objects containing information about each part of the pattern.
     *
     * @param format The format string or options.
     * @param localeId The optional locale id. If not specified, the `"en"` locale id is used.
     * @returns The date format parts.
     */
    splitDateFormat(format$$1, localeId) {
        return splitDateFormat$1(format$$1, localeId || this.localeId);
    }
    /**
     * Returns the number symbols from the current locale based on the option.
     *
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return - The number symbols from the current locale.
     */
    numberSymbols(localeId) {
        return numberSymbols$1(localeId || this.localeId);
    }
    /**
     * Returns the first day index starting from Sunday.
     *
     * @param localeId - The locale ID. Defaults to the current locale ID.
     * @return - The index of the first day of the week (0 == Sunday).
     */
    firstDay(localeId) {
        return firstDay$1(localeId || this.localeId);
    }
    /**
     * Returns the start and end index of the locale weekend starting from Sunday.
     *
     * @param localeId - The locale ID. Defaults to the current locale ID.
     * @return - The the start and end index of the locale weekend (0 == Sunday).
     */
    weekendRange(localeId) {
        return weekendRange$1(localeId || this.localeId);
    }
}
CldrIntlService.ɵfac = function CldrIntlService_Factory(t) { return new (t || CldrIntlService)(ɵngcc0.ɵɵinject(LOCALE_ID)); };
CldrIntlService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: CldrIntlService, factory: CldrIntlService.ɵfac });
/** @nocollapse */
CldrIntlService.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CldrIntlService, [{
        type: Injectable
    }], function () { return [{ type: String, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }]; }, null); })();

const isNumeric = (value) => !isNaN(value - parseFloat(value));
const ɵ0 = isNumeric;
/**
 * Formats a date value to a string based on the requested format.
 * This pipe uses the [IntlService]({% slug api_intl_intlservice %}).
 *
 * @example
 * ```ng-template-no-run
 * <ul>
 *    <li>{{date | kendoDate }}</li>
 *    <li>{{milliseconds | kendoDate: 'M/dd/yyy' }}</li>
 *    <li>{{stringDate | kendoDate: 'G' }}</li>
 * </ul>
 * ```
 */
class DatePipe {
    /**
     * @hidden
     */
    constructor(intlService) {
        this.intlService = intlService;
    }
    /**
     * Converts a `Date` object into a string based on the specified format.
     * If no format is provided, the default short date format is used.
     *
     * @param value - The date to format.
     * @param format - The format string or options.
     * @param localeId - (Optional) The ID of the locale which will be used instead of the default one.
     * @return - The formatted date.
     */
    transform(value, format$$1 = "", localeId) {
        value = this.normalize(value);
        if (value) {
            return this.intlService.formatDate(value, format$$1, localeId);
        }
        return value;
    }
    normalize(value) {
        if (value && typeof value === 'string') {
            value = this.intlService.parseDate(value);
        }
        else if (value && isNumeric(value)) {
            value = new Date(parseFloat(value));
        }
        return value;
    }
}
DatePipe.ɵfac = function DatePipe_Factory(t) { return new (t || DatePipe)(ɵngcc0.ɵɵdirectiveInject(IntlService)); };
DatePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "kendoDate", type: DatePipe, pure: true });
/** @nocollapse */
DatePipe.ctorParameters = () => [
    { type: IntlService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatePipe, [{
        type: Pipe,
        args: [{
                name: 'kendoDate'
            }]
    }], function () { return [{ type: IntlService }]; }, null); })();

/**
 * Formats a number value to a string based on the requested format.
 * This pipe uses the [`IntlService`]({% slug api_intl_intlservice %}).
 *
 * @example
 * ```ng-template-no-run
 *   <ul>
 *     <li>{{decimal | kendoNumber:'c' }}</li>
 *     <li>{{stringNumber | kendoNumber:'p' }}</li>
 *     <li>{{int | kendoNumber:'##.00' }}</li>
 *  </ul>
 * ```
 */
class NumberPipe {
    /**
     * @hidden
     */
    constructor(intlService) {
        this.intlService = intlService;
    }
    /**
     * Converts a `Number` object into a string based on the specified format.
     * If no format is provided, the value is formatted as decimal number using the
     * [`"n"`](https://github.com/telerik/kendo-intl/blob/master/docs/num-formatting/index.md#standard) format.
     *
     * @param value - The numer that will be formatted.
     * @param format - The format string or options.
     * @param localeId - (Optional) The locale ID that will be used in place of the default one.
     * @return - The formatted number.
     */
    transform(value, format$$1, localeId) {
        if (typeof value === 'string') {
            value = this.intlService.parseNumber(value);
        }
        if (value !== null && value !== undefined) {
            return this.intlService.formatNumber(value, format$$1, localeId);
        }
        return value;
    }
}
NumberPipe.ɵfac = function NumberPipe_Factory(t) { return new (t || NumberPipe)(ɵngcc0.ɵɵdirectiveInject(IntlService)); };
NumberPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "kendoNumber", type: NumberPipe, pure: true });
/** @nocollapse */
NumberPipe.ctorParameters = () => [
    { type: IntlService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NumberPipe, [{
        type: Pipe,
        args: [{
                name: 'kendoNumber'
            }]
    }], function () { return [{ type: IntlService }]; }, null); })();

const pipes = [
    DatePipe,
    NumberPipe
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }}docs/ts/latest/guide/ngmodule.html)
 * definition for the Intl services.
 */
class IntlModule {
}
IntlModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IntlModule });
IntlModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IntlModule_Factory(t) { return new (t || IntlModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IntlModule, { declarations: [DatePipe,
        NumberPipe], exports: [DatePipe,
        NumberPipe] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntlModule, [{
        type: NgModule,
        args: [{
                declarations: [pipes],
                exports: [pipes]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { cldrServiceFactory, IntlService, CldrIntlService, DatePipe, ɵ0, NumberPipe, IntlModule, dateFormatNames$1 as dateFormatNames, dateFieldName$1 as dateFieldName, firstDay$1 as firstDay, format$1 as format, formatDate$1 as formatDate, formatNumber$1 as formatNumber, load$1 as load, numberSymbols$1 as numberSymbols, parseDate$1 as parseDate, parseNumber$1 as parseNumber, splitDateFormat$1 as splitDateFormat, toString$1 as toString, weekendRange$1 as weekendRange, setData$1 as setData, localeData };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztBQU9BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtSUMsd0NBT0M7Ozs7Ozs7OztnREFDb0w7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBZ01yTCw0R0FHQzs7Ozs7Ozs7OztrQ0FJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaURELHVGQUtDOzs7Ozs7Ozs7O3FFQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBeUNELDZGQUtDOzs7Ozs7Ozs7O3FFQUlBOzs7Ozs7Ozs7Ozs7O0NBV0Q7Ozs7Ozs7Ozs7MEJBTUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIsIEluamVjdCwgSW5qZWN0YWJsZSwgTE9DQUxFX0lELCBOZ01vZHVsZSwgUGlwZSwgZGVmaW5lSW5qZWN0YWJsZSwgaW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBkYXRlRmllbGROYW1lLCBkYXRlRm9ybWF0TmFtZXMsIGZpcnN0RGF5LCBmb3JtYXQsIGZvcm1hdERhdGUsIGZvcm1hdE51bWJlciwgbG9hZCwgbG9jYWxlSW5mbywgbnVtYmVyU3ltYm9scywgcGFyc2VEYXRlLCBwYXJzZU51bWJlciwgc2V0RGF0YSwgc3BsaXREYXRlRm9ybWF0LCB0b1N0cmluZywgd2Vla2VuZFJhbmdlIH0gZnJvbSAnQHRlbGVyaWsva2VuZG8taW50bCc7XG5cbmNvbnN0IERPQ1NfVVJMID0gJ2h0dHA6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL2ludGVybmF0aW9uYWxpemF0aW9uL3Ryb3VibGVzaG9vdGluZy8nO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGVycm9yU29sdXRpb25zID0ge1xuICAgICdOb0N1cnJlbmN5JzogYFNvbHV0aW9uOiAke0RPQ1NfVVJMfSN0b2Mtbm8tY3VycmVuY3lgLFxuICAgICdOb0N1cnJlbmN5RGlzcGxheSc6IGBTb2x1dGlvbjogJHtET0NTX1VSTH0jdG9jLW5vLWN1cnJlbmN5LWRpc3BsYXlgLFxuICAgICdOb0N1cnJlbmN5UmVnaW9uJzogYFNvbHV0aW9uOiAke0RPQ1NfVVJMfSN0b2Mtbm8tY3VycmVuY3ktcmVnaW9uYCxcbiAgICAnTm9EYXRlRmllbGROYW1lcyc6IGBTb2x1dGlvbjogJHtET0NTX1VSTH0jdG9jLW5vLWRhdGUtZmlsZWQtbmFtZXNgLFxuICAgICdOb0ZpcnN0RGF5JzogYFNvbHV0aW9uOiAke0RPQ1NfVVJMfSN0b2Mtbm8tZmlyc3QtZGF5YCxcbiAgICAnTm9HTVRJbmZvJzogYFNvbHV0aW9uOiAke0RPQ1NfVVJMfSN0b2Mtbm8tZ210LWluZm9gLFxuICAgICdOb0xvY2FsZSc6IGBTb2x1dGlvbjogJHtET0NTX1VSTH0jdG9jLW5vLWxvY2FsZWAsXG4gICAgJ05vVmFsaWRDdXJyZW5jeSc6IGBTb2x1dGlvbjogJHtET0NTX1VSTH0jdG9jLW5vLXZhbGlkLWN1cnJlbmN5YCxcbiAgICAnTm9XZWVrRGF0YSc6IGBTb2x1dGlvbjogJHtET0NTX1VSTH0jdG9jLW5vLXdlZWstZGF0YWBcbn07XG5cbmZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2UoZXJyb3IpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICBjb25zdCBlcnJvclNvbHV0aW9uID0gZXJyb3JTb2x1dGlvbnNbT2JqZWN0LmtleXMoZXJyb3JTb2x1dGlvbnMpLmZpbHRlcihrZXkgPT4gbWVzc2FnZS5pbmRleE9mKGtleSkgPT09IDApWzBdXTtcbiAgICByZXR1cm4gZXJyb3JTb2x1dGlvbiA/IGAke21lc3NhZ2V9ICR7ZXJyb3JTb2x1dGlvbn1gIDogbWVzc2FnZTtcbn1cbmZ1bmN0aW9uIGludGxNZXRob2QoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLnZhbHVlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gZm9ybWF0TWVzc2FnZShlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH07XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZGF0ZUZvcm1hdE5hbWVzJDEgPSBpbnRsTWV0aG9kKGRhdGVGb3JtYXROYW1lcyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZGF0ZUZpZWxkTmFtZSQxID0gaW50bE1ldGhvZChkYXRlRmllbGROYW1lKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBmaXJzdERheSQxID0gaW50bE1ldGhvZChmaXJzdERheSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZm9ybWF0JDEgPSBpbnRsTWV0aG9kKGZvcm1hdCk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZm9ybWF0RGF0ZSQxID0gaW50bE1ldGhvZChmb3JtYXREYXRlKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBmb3JtYXROdW1iZXIkMSA9IGludGxNZXRob2QoZm9ybWF0TnVtYmVyKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBsb2FkJDEgPSBpbnRsTWV0aG9kKGxvYWQpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG51bWJlclN5bWJvbHMkMSA9IGludGxNZXRob2QobnVtYmVyU3ltYm9scyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgcGFyc2VEYXRlJDEgPSBpbnRsTWV0aG9kKHBhcnNlRGF0ZSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgcGFyc2VOdW1iZXIkMSA9IGludGxNZXRob2QocGFyc2VOdW1iZXIpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHNwbGl0RGF0ZUZvcm1hdCQxID0gaW50bE1ldGhvZChzcGxpdERhdGVGb3JtYXQpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHRvU3RyaW5nJDEgPSBpbnRsTWV0aG9kKHRvU3RyaW5nKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCB3ZWVrZW5kUmFuZ2UkMSA9IGludGxNZXRob2Qod2Vla2VuZFJhbmdlKTtcbi8qKlxuICogU2V0cyBhIHByZS1idWlsdCBsb2NhbGUuXG4gKlxuICogQHBhcmFtcyBkYXRhIC0gVGhlIHByZS1idWlsdCBsb2NhbGUgZGF0YS5cbiAqL1xuY29uc3Qgc2V0RGF0YSQxID0gKGRhdGEpID0+IHNldERhdGEoZGF0YSk7XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgbG9jYWxlIGRhdGEgZm9yIHRoZSBzcGVjaWZpZWQgbG9jYWxlLlxuICpcbiAqIEBwYXJhbXMgbG9jYWxlIC0gVGhlIGxvY2FsZSBpZC5cbiAqIEByZXR1cm5zIGRhdGEgLSBUaGUgbG9jYWxlIGRhdGEuXG4gKi9cbmNvbnN0IGxvY2FsZURhdGEgPSAobG9jYWxlKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZUluZm8obG9jYWxlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGVycm9yLm1lc3NhZ2UgPSBmb3JtYXRNZXNzYWdlKGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufTtcblxuY29uc3QgTE9DQUxFX1JFR0VYID0gL18vZztcbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBjbGRyU2VydmljZUZhY3RvcnkobG9jYWxlSWQpIHtcbiAgICByZXR1cm4gbmV3IENsZHJJbnRsU2VydmljZShsb2NhbGVJZCk7XG59XG4vKipcbiAqIEFuIGFic3RyYWN0IGJhc2UgY2xhc3MgdGhhdCBpbXBsZW1lbnRzXG4gKiB0aGUgSW50ZXJuYXRpb25hbGl6YXRpb24gc2VydmljZSBtZXRob2RzXG4gKiBmb3IgdGhlIGN1cnJlbnQgbG9jYWxlLlxuICovXG5jbGFzcyBJbnRsU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIHRoYXQgdGhlIHNlcnZpY2Ugd2FzIGNoYW5nZWQuXG4gICAgICovXG4gICAgbm90aWZ5KCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMuZW1pdCgpO1xuICAgIH1cbn1cbkludGxTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVkSW46ICdyb290JyxcbiAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiBjbGRyU2VydmljZUZhY3RvcnksXG4gICAgICAgICAgICAgICAgZGVwczogW0xPQ0FMRV9JRF1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbkludGxTZXJ2aWNlLm5nSW5qZWN0YWJsZURlZiA9IGRlZmluZUluamVjdGFibGUoeyBmYWN0b3J5OiBmdW5jdGlvbiBJbnRsU2VydmljZV9GYWN0b3J5KCkgeyByZXR1cm4gY2xkclNlcnZpY2VGYWN0b3J5KGluamVjdChMT0NBTEVfSUQpKTsgfSwgdG9rZW46IEludGxTZXJ2aWNlLCBwcm92aWRlZEluOiBcInJvb3RcIiB9KTtcbi8qKlxuICogVGhlIEludGVybmF0aW9uYWxpemF0aW9uIHNlcnZpY2UgaW1wbGVtZW50ZWQgYnkgdXNpbmdcbiAqIHRoZSBDTERSIERhdGFiYXNlIHZpYSB0aGUgYEB0ZWxlcmlrL2tlbmRvLWludGxgIHBhY2thZ2UuXG4gKi9cbmNsYXNzIENsZHJJbnRsU2VydmljZSBleHRlbmRzIEludGxTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBzZXJ2aWNlIHdpdGggdGhlIElEIG9mIHRoZSBzcGVjaWZpZWQgbG9jYWxlLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoZSBwYXJ0cyBvZiB0aGUgbG9jYWxlIElEIGNhbiBiZSBzZXBhcmF0ZWQgYnkgZWl0aGVyIGBfYCAodW5kZXJzY29yZSlcbiAgICAgKiBvciBgLWAgKGRhc2gpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGRlZmF1bHQgbG9jYWxlIElELlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsZUlkKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubG9jYWxlSWQgPSBsb2NhbGVJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBjdXJyZW50IGxvY2FsZSBJRC5cbiAgICAgKi9cbiAgICBnZXQgbG9jYWxlSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZTtcbiAgICB9XG4gICAgc2V0IGxvY2FsZUlkKHZhbHVlKSB7XG4gICAgICAgIC8vIEFuZ3VsYXIgbG9jYWxlcyB1c2UgdW5kZXJzY29yZSwgZm9yIGV4YW1wbGUsIGVuX1VTXG4gICAgICAgIC8vIHdoaWxlIElFVEYgQkNQLTQ3IHNwZWNpZmllcyBhIGRhc2guXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9iY3A0N1xuICAgICAgICBjb25zdCBsb2NhbGUgPSB2YWx1ZS5yZXBsYWNlKExPQ0FMRV9SRUdFWCwgJy0nKTtcbiAgICAgICAgaWYgKGxvY2FsZSAhPT0gdGhpcy5sb2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxlID0gbG9jYWxlO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3JtYXRzIGEgc3RyaW5nIHdpdGggcGxhY2Vob2xkZXJzIHN1Y2ggYXNcbiAgICAgKiBgVG90YWwgYW1vdW50IHswOmN9YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZy5cbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gT25lIG9yIG1vcmUgdmFsdWVzIHRvIG91dHB1dCBpbiB0aGUgZm9ybWF0IHN0cmluZyBwbGFjZWhvbGRlcnMuXG4gICAgICogQHJldHVybiAtIFRoZSBmb3JtYXR0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQkJDEsIC4uLnZhbHVlcykge1xuICAgICAgICByZXR1cm4gZm9ybWF0JDEoZm9ybWF0JCQxLCB2YWx1ZXMsIHRoaXMubG9jYWxlSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIHN0cmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGZvcm1hdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmb3JtYXQuXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiBUaGUgZm9ybWF0dGVkIG9iamVjdC5cbiAgICAgKi9cbiAgICB0b1N0cmluZyh2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmckMSh2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCB8fCB0aGlzLmxvY2FsZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBgRGF0ZWAgb2JqZWN0IGludG8gYSBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBmb3JtYXQuXG4gICAgICogSWYgbm8gZm9ybWF0IGlzIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBzaG9ydCBkYXRlIGZvcm1hdCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIGRhdGUgdG8gZm9ybWF0LlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiBUaGUgZm9ybWF0dGVkIGRhdGUuXG4gICAgICovXG4gICAgZm9ybWF0RGF0ZSh2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gZm9ybWF0RGF0ZSQxKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHN0cmluZyBpbnRvIGEgYERhdGVgIG9iamVjdCBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGZvcm1hdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmdzIG9yIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIFRoZSBwYXJzZWQgZGF0ZS5cbiAgICAgKi9cbiAgICBwYXJzZURhdGUodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRGF0ZSQxKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHN0cmluZyBpbnRvIGEgYE51bWJlcmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5nIG9yIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIFRoZSBwYXJzZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIHBhcnNlTnVtYmVyKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiBwYXJzZU51bWJlciQxKHZhbHVlLCBsb2NhbGVJZCB8fCB0aGlzLmxvY2FsZUlkLCBmb3JtYXQkJDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGBOdW1iZXJgIGludG8gYSBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGZvcm1hdC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gVGhlIGZvcm1hdHRlZCBudW1iZXIuXG4gICAgICovXG4gICAgZm9ybWF0TnVtYmVyKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXROdW1iZXIkMSh2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCB8fCB0aGlzLmxvY2FsZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGF0ZSBuYW1lcyBmcm9tIHRoZSBjdXJyZW50IGxvY2FsZSBiYXNlZCBvbiB0aGUgb3B0aW9uLlxuICAgICAqXG4gICAgICogVGhlIGF2YWlsYWJsZSBgdHlwZWAgdmFsdWVzIGFyZTpcbiAgICAgKiAtIGBlcmFgXG4gICAgICogLSBgeWVhcmBcbiAgICAgKiAtIGBxdWFydGVyYFxuICAgICAqIC0gYG1vbnRoYFxuICAgICAqIC0gYHdlZWtgXG4gICAgICogLSBgZGF5YFxuICAgICAqIC0gYGRheXBlcmlvZGBcbiAgICAgKiAtIGBob3VyYFxuICAgICAqIC0gYG1pbnV0ZWBcbiAgICAgKiAtIGBzZWNvbmRgXG4gICAgICogLSBgem9uZWBcbiAgICAgKlxuICAgICAqIFRoZSBhdmFpbGFibGUgYG5hbWVUeXBlYCB2YWx1ZXMgYXJlOlxuICAgICAqIC0gYHdpZGVgXG4gICAgICogLSBgbmFycm93YFxuICAgICAqIC0gYHNob3J0YFxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBEZXRhaWxlZCBjb25maWd1cmF0aW9uIGZvciB0aGUgZGVzaXJlZCBkYXRlIGZpZWxkIG5hbWUuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIGRheSBuYW1lcyBmcm9tIHRoZSBjdXJyZW50IGxvY2FsZSBiYXNlZCBvbiB0aGUgb3B0aW9uLlxuICAgICAqIEByZXR1cm5zIFRoZSBsb2NhbGl6ZWQgZGF0ZSBmaWVsZCBuYW1lIGZyb20gdGhlIGN1cnJlbnQgbG9jYWxlIGJhc2VkIG9uIHRoZSBvcHRpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIGRhdGVGaWVsZE5hbWUoeyB0eXBlOiAnZGF5JyB9KTsgICAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm5zICdkYXknO1xuICAgICAqIGRhdGVGaWVsZE5hbWUoeyB0eXBlOiAnZGF5JywgbmFtZVR5cGU6ICd3aWRlJyB9KTsgICAgLy9yZXR1cm5zICdkYXknO1xuICAgICAqIGRhdGVGaWVsZE5hbWUoeyB0eXBlOiAnbW9udGgnLCBuYW1lVHlwZTogJ3Nob3J0JyB9KTsgLy9yZXR1cm5zICdtby4nO1xuICAgICAqIGRhdGVGaWVsZE5hbWUoeyB0eXBlOiAnbW9udGgnLCBuYW1lVHlwZTogJ3dpZGUnIH0pOyAgLy9yZXR1cm5zICdtb250aCc7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZGF0ZUZpZWxkTmFtZShvcHRpb25zLCBsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gZGF0ZUZpZWxkTmFtZSQxKG9wdGlvbnMsIGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbG9jYWxpemVkIGRhdGUgZmllbGQgbmFtZSBiYXNlZCBvbiBzcGVjaWZpYyBkYXRlRmllbGROYW1lIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBUaGUgYXZhaWxhYmxlIHR5cGUgdmFsdWVzIGFyZTpcbiAgICAgKiAtIGBkYXlgXG4gICAgICogLSBgZGF5cGVyaW9kYFxuICAgICAqIC0gYG1vbnRoc2BcbiAgICAgKiAtIGBxdWFydGVyc2BcbiAgICAgKiAtIGBlcmFzYFxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBEZXRhaWxlZCBjb25maWd1cmF0aW9uIGZvciB0aGUgZGVzaXJlZCBkYXRlIGZvcm1hdC5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gLSBUaGUgZGF5IG5hbWVzIGZyb20gdGhlIGN1cnJlbnQgbG9jYWxlIGJhc2VkIG9uIHRoZSBvcHRpb24uXG4gICAgICovXG4gICAgZGF0ZUZvcm1hdE5hbWVzKG9wdGlvbnMsIGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiBkYXRlRm9ybWF0TmFtZXMkMShsb2NhbGVJZCB8fCB0aGlzLmxvY2FsZUlkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BsaXRzIHRoZSBkYXRlIGZvcm1hdCBpbnRvIG9iamVjdHMgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCBlYWNoIHBhcnQgb2YgdGhlIHBhdHRlcm4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9ybWF0IFRoZSBmb3JtYXQgc3RyaW5nIG9yIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIFRoZSBvcHRpb25hbCBsb2NhbGUgaWQuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBgXCJlblwiYCBsb2NhbGUgaWQgaXMgdXNlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgZGF0ZSBmb3JtYXQgcGFydHMuXG4gICAgICovXG4gICAgc3BsaXREYXRlRm9ybWF0KGZvcm1hdCQkMSwgbG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIHNwbGl0RGF0ZUZvcm1hdCQxKGZvcm1hdCQkMSwgbG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBzeW1ib2xzIGZyb20gdGhlIGN1cnJlbnQgbG9jYWxlIGJhc2VkIG9uIHRoZSBvcHRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gLSBUaGUgbnVtYmVyIHN5bWJvbHMgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUuXG4gICAgICovXG4gICAgbnVtYmVyU3ltYm9scyhsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gbnVtYmVyU3ltYm9scyQxKGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBkYXkgaW5kZXggc3RhcnRpbmcgZnJvbSBTdW5kYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElELiBEZWZhdWx0cyB0byB0aGUgY3VycmVudCBsb2NhbGUgSUQuXG4gICAgICogQHJldHVybiAtIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrICgwID09IFN1bmRheSkuXG4gICAgICovXG4gICAgZmlyc3REYXkobG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0RGF5JDEobG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN0YXJ0IGFuZCBlbmQgaW5kZXggb2YgdGhlIGxvY2FsZSB3ZWVrZW5kIHN0YXJ0aW5nIGZyb20gU3VuZGF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRC4gRGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgbG9jYWxlIElELlxuICAgICAqIEByZXR1cm4gLSBUaGUgdGhlIHN0YXJ0IGFuZCBlbmQgaW5kZXggb2YgdGhlIGxvY2FsZSB3ZWVrZW5kICgwID09IFN1bmRheSkuXG4gICAgICovXG4gICAgd2Vla2VuZFJhbmdlKGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiB3ZWVrZW5kUmFuZ2UkMShsb2NhbGVJZCB8fCB0aGlzLmxvY2FsZUlkKTtcbiAgICB9XG59XG5DbGRySW50bFNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkNsZHJJbnRsU2VydmljZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFN0cmluZywgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbTE9DQUxFX0lELF0gfV0gfVxuXTtcblxuY29uc3QgaXNOdW1lcmljID0gKHZhbHVlKSA9PiAhaXNOYU4odmFsdWUgLSBwYXJzZUZsb2F0KHZhbHVlKSk7XG5jb25zdCDJtTAgPSBpc051bWVyaWM7XG4vKipcbiAqIEZvcm1hdHMgYSBkYXRlIHZhbHVlIHRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSByZXF1ZXN0ZWQgZm9ybWF0LlxuICogVGhpcyBwaXBlIHVzZXMgdGhlIFtJbnRsU2VydmljZV0oeyUgc2x1ZyBhcGlfaW50bF9pbnRsc2VydmljZSAlfSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYG5nLXRlbXBsYXRlLW5vLXJ1blxuICogPHVsPlxuICogICAgPGxpPnt7ZGF0ZSB8IGtlbmRvRGF0ZSB9fTwvbGk+XG4gKiAgICA8bGk+e3ttaWxsaXNlY29uZHMgfCBrZW5kb0RhdGU6ICdNL2RkL3l5eScgfX08L2xpPlxuICogICAgPGxpPnt7c3RyaW5nRGF0ZSB8IGtlbmRvRGF0ZTogJ0cnIH19PC9saT5cbiAqIDwvdWw+XG4gKiBgYGBcbiAqL1xuY2xhc3MgRGF0ZVBpcGUge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpbnRsU2VydmljZSkge1xuICAgICAgICB0aGlzLmludGxTZXJ2aWNlID0gaW50bFNlcnZpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgYERhdGVgIG9iamVjdCBpbnRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqIElmIG5vIGZvcm1hdCBpcyBwcm92aWRlZCwgdGhlIGRlZmF1bHQgc2hvcnQgZGF0ZSBmb3JtYXQgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBkYXRlIHRvIGZvcm1hdC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSAoT3B0aW9uYWwpIFRoZSBJRCBvZiB0aGUgbG9jYWxlIHdoaWNoIHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IG9uZS5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIGZvcm1hdHRlZCBkYXRlLlxuICAgICAqL1xuICAgIHRyYW5zZm9ybSh2YWx1ZSwgZm9ybWF0JCQxID0gXCJcIiwgbG9jYWxlSWQpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLm5vcm1hbGl6ZSh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50bFNlcnZpY2UuZm9ybWF0RGF0ZSh2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBub3JtYWxpemUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5pbnRsU2VydmljZS5wYXJzZURhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICYmIGlzTnVtZXJpYyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUocGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5EYXRlUGlwZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogUGlwZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBuYW1lOiAna2VuZG9EYXRlJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5EYXRlUGlwZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEludGxTZXJ2aWNlIH1cbl07XG5cbi8qKlxuICogRm9ybWF0cyBhIG51bWJlciB2YWx1ZSB0byBhIHN0cmluZyBiYXNlZCBvbiB0aGUgcmVxdWVzdGVkIGZvcm1hdC5cbiAqIFRoaXMgcGlwZSB1c2VzIHRoZSBbYEludGxTZXJ2aWNlYF0oeyUgc2x1ZyBhcGlfaW50bF9pbnRsc2VydmljZSAlfSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYG5nLXRlbXBsYXRlLW5vLXJ1blxuICogICA8dWw+XG4gKiAgICAgPGxpPnt7ZGVjaW1hbCB8IGtlbmRvTnVtYmVyOidjJyB9fTwvbGk+XG4gKiAgICAgPGxpPnt7c3RyaW5nTnVtYmVyIHwga2VuZG9OdW1iZXI6J3AnIH19PC9saT5cbiAqICAgICA8bGk+e3tpbnQgfCBrZW5kb051bWJlcjonIyMuMDAnIH19PC9saT5cbiAqICA8L3VsPlxuICogYGBgXG4gKi9cbmNsYXNzIE51bWJlclBpcGUge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpbnRsU2VydmljZSkge1xuICAgICAgICB0aGlzLmludGxTZXJ2aWNlID0gaW50bFNlcnZpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgYE51bWJlcmAgb2JqZWN0IGludG8gYSBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBmb3JtYXQuXG4gICAgICogSWYgbm8gZm9ybWF0IGlzIHByb3ZpZGVkLCB0aGUgdmFsdWUgaXMgZm9ybWF0dGVkIGFzIGRlY2ltYWwgbnVtYmVyIHVzaW5nIHRoZVxuICAgICAqIFtgXCJuXCJgXShodHRwczovL2dpdGh1Yi5jb20vdGVsZXJpay9rZW5kby1pbnRsL2Jsb2IvbWFzdGVyL2RvY3MvbnVtLWZvcm1hdHRpbmcvaW5kZXgubWQjc3RhbmRhcmQpIGZvcm1hdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1lciB0aGF0IHdpbGwgYmUgZm9ybWF0dGVkLlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIChPcHRpb25hbCkgVGhlIGxvY2FsZSBJRCB0aGF0IHdpbGwgYmUgdXNlZCBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuXG4gICAgICogQHJldHVybiAtIFRoZSBmb3JtYXR0ZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIHRyYW5zZm9ybSh2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmludGxTZXJ2aWNlLnBhcnNlTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50bFNlcnZpY2UuZm9ybWF0TnVtYmVyKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuTnVtYmVyUGlwZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogUGlwZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBuYW1lOiAna2VuZG9OdW1iZXInXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbk51bWJlclBpcGUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBJbnRsU2VydmljZSB9XG5dO1xuXG5jb25zdCBwaXBlcyA9IFtcbiAgICBEYXRlUGlwZSxcbiAgICBOdW1iZXJQaXBlXG5dO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX1kb2NzL3RzL2xhdGVzdC9ndWlkZS9uZ21vZHVsZS5odG1sKVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIEludGwgc2VydmljZXMuXG4gKi9cbmNsYXNzIEludGxNb2R1bGUge1xufVxuSW50bE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbcGlwZXNdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtwaXBlc11cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBjbGRyU2VydmljZUZhY3RvcnksIEludGxTZXJ2aWNlLCBDbGRySW50bFNlcnZpY2UsIERhdGVQaXBlLCDJtTAsIE51bWJlclBpcGUsIEludGxNb2R1bGUsIGRhdGVGb3JtYXROYW1lcyQxIGFzIGRhdGVGb3JtYXROYW1lcywgZGF0ZUZpZWxkTmFtZSQxIGFzIGRhdGVGaWVsZE5hbWUsIGZpcnN0RGF5JDEgYXMgZmlyc3REYXksIGZvcm1hdCQxIGFzIGZvcm1hdCwgZm9ybWF0RGF0ZSQxIGFzIGZvcm1hdERhdGUsIGZvcm1hdE51bWJlciQxIGFzIGZvcm1hdE51bWJlciwgbG9hZCQxIGFzIGxvYWQsIG51bWJlclN5bWJvbHMkMSBhcyBudW1iZXJTeW1ib2xzLCBwYXJzZURhdGUkMSBhcyBwYXJzZURhdGUsIHBhcnNlTnVtYmVyJDEgYXMgcGFyc2VOdW1iZXIsIHNwbGl0RGF0ZUZvcm1hdCQxIGFzIHNwbGl0RGF0ZUZvcm1hdCwgdG9TdHJpbmckMSBhcyB0b1N0cmluZywgd2Vla2VuZFJhbmdlJDEgYXMgd2Vla2VuZFJhbmdlLCBzZXREYXRhJDEgYXMgc2V0RGF0YSwgbG9jYWxlRGF0YSB9O1xuIl19