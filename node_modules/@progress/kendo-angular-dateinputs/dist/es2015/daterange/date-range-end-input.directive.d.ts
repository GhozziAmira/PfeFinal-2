/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { ElementRef, Renderer2, NgZone, OnInit, OnDestroy } from '@angular/core';
import { DateInputComponent } from '../dateinput/dateinput.component';
import { AutoCorrectOn } from './auto-correct-on.type';
import { DateRangeInput } from './date-range-input';
import { DateRangeService } from './date-range.service';
import { SelectionRange } from '../calendar/models/selection-range.interface';
/**
 * A directive which manages the end range selection.
 *
 * > You can use the DateRangeEndInputDirective only with a DateInput component.
 */
import * as ɵngcc0 from '@angular/core';
export declare class DateRangeEndInputDirective extends DateRangeInput implements OnInit, OnDestroy {
    private rangeService;
    private dateInput;
    /**
     * Specifies the auto-correction behavior. If the start date is greater than the end date, the
     * directive fixes the date range to a single date either on input change or on blur
     * ([see example]({% slug autocorrect_daterange %}#toc-configuring-input-directives)).
     *
     * By default, the component does not perform any auto-correction.
     */
    autoCorrectOn: AutoCorrectOn;
    /**
     * Specifies the navigation behavior of the calendar when the active end is changed on input focus. When enabled,
     * the calendar navigates to the value of the focused input. Otherwise, the calendar displays the last picked date.
     *
     * By default, the automatic navigation behavior on input focus is disabled.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <h5>Toggle input focus to see the calendar navigating between range ends.</h5>
     *  <kendo-daterange>
     *      <kendo-dateinput kendoDateRangeStartInput [navigateCalendarOnFocus]="true" [(value)]="start"></kendo-dateinput>
     *      <kendo-dateinput kendoDateRangeEndInput [navigateCalendarOnFocus]="true" [(value)]="end"></kendo-dateinput>
     *  </kendo-daterange>
     * `
     * })
     * class AppComponent {
     *   public start: Date = new Date(2018, 3, 10);
     *   public end: Date = new Date(2018, 10, 20);
     * }
     * ```
     */
    navigateCalendarOnFocus: boolean;
    constructor(rangeService: DateRangeService, dateInput: DateInputComponent, element: ElementRef, renderer: Renderer2, zone: NgZone);
    ngOnInit(): void;
    ngOnDestroy(): void;
    protected getRange(value: Date, correctOn: AutoCorrectOn): SelectionRange;
    protected updateInputValue(range: SelectionRange): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<DateRangeEndInputDirective>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<DateRangeEndInputDirective, "[kendoDateRangeEndInput]", never, {
    "navigateCalendarOnFocus": "navigateCalendarOnFocus";
    "autoCorrectOn": "autoCorrectOn";
}, {}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1yYW5nZS1lbmQtaW5wdXQuZGlyZWN0aXZlLmQudHMiLCJzb3VyY2VzIjpbImRhdGUtcmFuZ2UtZW5kLWlucHV0LmRpcmVjdGl2ZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5Q0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBFbGVtZW50UmVmLCBSZW5kZXJlcjIsIE5nWm9uZSwgT25Jbml0LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERhdGVJbnB1dENvbXBvbmVudCB9IGZyb20gJy4uL2RhdGVpbnB1dC9kYXRlaW5wdXQuY29tcG9uZW50JztcbmltcG9ydCB7IEF1dG9Db3JyZWN0T24gfSBmcm9tICcuL2F1dG8tY29ycmVjdC1vbi50eXBlJztcbmltcG9ydCB7IERhdGVSYW5nZUlucHV0IH0gZnJvbSAnLi9kYXRlLXJhbmdlLWlucHV0JztcbmltcG9ydCB7IERhdGVSYW5nZVNlcnZpY2UgfSBmcm9tICcuL2RhdGUtcmFuZ2Uuc2VydmljZSc7XG5pbXBvcnQgeyBTZWxlY3Rpb25SYW5nZSB9IGZyb20gJy4uL2NhbGVuZGFyL21vZGVscy9zZWxlY3Rpb24tcmFuZ2UuaW50ZXJmYWNlJztcbi8qKlxuICogQSBkaXJlY3RpdmUgd2hpY2ggbWFuYWdlcyB0aGUgZW5kIHJhbmdlIHNlbGVjdGlvbi5cbiAqXG4gKiA+IFlvdSBjYW4gdXNlIHRoZSBEYXRlUmFuZ2VFbmRJbnB1dERpcmVjdGl2ZSBvbmx5IHdpdGggYSBEYXRlSW5wdXQgY29tcG9uZW50LlxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBEYXRlUmFuZ2VFbmRJbnB1dERpcmVjdGl2ZSBleHRlbmRzIERhdGVSYW5nZUlucHV0IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgcmFuZ2VTZXJ2aWNlO1xuICAgIHByaXZhdGUgZGF0ZUlucHV0O1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgYXV0by1jb3JyZWN0aW9uIGJlaGF2aW9yLiBJZiB0aGUgc3RhcnQgZGF0ZSBpcyBncmVhdGVyIHRoYW4gdGhlIGVuZCBkYXRlLCB0aGVcbiAgICAgKiBkaXJlY3RpdmUgZml4ZXMgdGhlIGRhdGUgcmFuZ2UgdG8gYSBzaW5nbGUgZGF0ZSBlaXRoZXIgb24gaW5wdXQgY2hhbmdlIG9yIG9uIGJsdXJcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGF1dG9jb3JyZWN0X2RhdGVyYW5nZSAlfSN0b2MtY29uZmlndXJpbmctaW5wdXQtZGlyZWN0aXZlcykpLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIGNvbXBvbmVudCBkb2VzIG5vdCBwZXJmb3JtIGFueSBhdXRvLWNvcnJlY3Rpb24uXG4gICAgICovXG4gICAgYXV0b0NvcnJlY3RPbjogQXV0b0NvcnJlY3RPbjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIG5hdmlnYXRpb24gYmVoYXZpb3Igb2YgdGhlIGNhbGVuZGFyIHdoZW4gdGhlIGFjdGl2ZSBlbmQgaXMgY2hhbmdlZCBvbiBpbnB1dCBmb2N1cy4gV2hlbiBlbmFibGVkLFxuICAgICAqIHRoZSBjYWxlbmRhciBuYXZpZ2F0ZXMgdG8gdGhlIHZhbHVlIG9mIHRoZSBmb2N1c2VkIGlucHV0LiBPdGhlcndpc2UsIHRoZSBjYWxlbmRhciBkaXNwbGF5cyB0aGUgbGFzdCBwaWNrZWQgZGF0ZS5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBhdXRvbWF0aWMgbmF2aWdhdGlvbiBiZWhhdmlvciBvbiBpbnB1dCBmb2N1cyBpcyBkaXNhYmxlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICogIDxoNT5Ub2dnbGUgaW5wdXQgZm9jdXMgdG8gc2VlIHRoZSBjYWxlbmRhciBuYXZpZ2F0aW5nIGJldHdlZW4gcmFuZ2UgZW5kcy48L2g1PlxuICAgICAqICA8a2VuZG8tZGF0ZXJhbmdlPlxuICAgICAqICAgICAgPGtlbmRvLWRhdGVpbnB1dCBrZW5kb0RhdGVSYW5nZVN0YXJ0SW5wdXQgW25hdmlnYXRlQ2FsZW5kYXJPbkZvY3VzXT1cInRydWVcIiBbKHZhbHVlKV09XCJzdGFydFwiPjwva2VuZG8tZGF0ZWlucHV0PlxuICAgICAqICAgICAgPGtlbmRvLWRhdGVpbnB1dCBrZW5kb0RhdGVSYW5nZUVuZElucHV0IFtuYXZpZ2F0ZUNhbGVuZGFyT25Gb2N1c109XCJ0cnVlXCIgWyh2YWx1ZSldPVwiZW5kXCI+PC9rZW5kby1kYXRlaW5wdXQ+XG4gICAgICogIDwva2VuZG8tZGF0ZXJhbmdlPlxuICAgICAqIGBcbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICogICBwdWJsaWMgc3RhcnQ6IERhdGUgPSBuZXcgRGF0ZSgyMDE4LCAzLCAxMCk7XG4gICAgICogICBwdWJsaWMgZW5kOiBEYXRlID0gbmV3IERhdGUoMjAxOCwgMTAsIDIwKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgbmF2aWdhdGVDYWxlbmRhck9uRm9jdXM6IGJvb2xlYW47XG4gICAgY29uc3RydWN0b3IocmFuZ2VTZXJ2aWNlOiBEYXRlUmFuZ2VTZXJ2aWNlLCBkYXRlSW5wdXQ6IERhdGVJbnB1dENvbXBvbmVudCwgZWxlbWVudDogRWxlbWVudFJlZiwgcmVuZGVyZXI6IFJlbmRlcmVyMiwgem9uZTogTmdab25lKTtcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgcHJvdGVjdGVkIGdldFJhbmdlKHZhbHVlOiBEYXRlLCBjb3JyZWN0T246IEF1dG9Db3JyZWN0T24pOiBTZWxlY3Rpb25SYW5nZTtcbiAgICBwcm90ZWN0ZWQgdXBkYXRlSW5wdXRWYWx1ZShyYW5nZTogU2VsZWN0aW9uUmFuZ2UpOiB2b2lkO1xufVxuIl19