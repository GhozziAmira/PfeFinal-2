import { ElementRef, EmbeddedViewRef, EventEmitter, OnDestroy, OnInit, Renderer2, ViewContainerRef, ChangeDetectorRef } from '@angular/core';
import { Subscription } from 'rxjs';
import { ComponentLoader } from '../utils/component-loader/component-loader.class';
import { ComponentLoaderFactory } from '../utils/component-loader/component-loader.factory';
import { BsDropdownConfig } from './dropdown.config';
import { BsDropdownContainerComponent } from './dropdown-container.component';
import { BsDropdownState } from './dropdown.state';
import { BsDropdownMenuDirective } from './dropdown-menu.directive';
import * as ɵngcc0 from '@angular/core';
export declare class BsDropdownDirective implements OnInit, OnDestroy {
    private _elementRef;
    private _renderer;
    private _viewContainerRef;
    private _cis;
    private _config;
    private _state;
    private cdRef;
    /**
     * Placement of a popover. Accepts: "top", "bottom", "left", "right"
     */
    placement: string;
    /**
     * Specifies events that should trigger. Supports a space separated list of
     * event names.
     */
    triggers: string;
    /**
     * A selector specifying the element the popover should be appended to.
     * Currently only supports "body".
     */
    container: string;
    dropup: boolean;
    dropupDefault: boolean;
    dynamicPosition: boolean;
    /**
     * This attribute indicates that the dropdown should be opened upwards
     */
    readonly isDropup: true;
    /**
     * Indicates that dropdown will be closed on item or document click,
     * and after pressing ESC
     */
    autoClose: boolean;
    /**
     * Disables dropdown toggle and hides dropdown menu if opened
     */
    isDisabled: boolean;
    /**
     * Returns whether or not the popover is currently being shown
     */
    isOpen: boolean;
    /**
     * Emits an event when isOpen change
     */
    isOpenChange: EventEmitter<any>;
    /**
     * Emits an event when the popover is shown
     */
    onShown: EventEmitter<any>;
    shown: EventEmitter<any>;
    /**
     * Emits an event when the popover is hidden
     */
    onHidden: EventEmitter<any>;
    hidden: EventEmitter<any>;
    private _destroy$;
    readonly isBs4: boolean;
    _isInlineOpen: boolean;
    _showInline: boolean;
    _inlinedMenu: EmbeddedViewRef<BsDropdownMenuDirective>;
    _isDisabled: boolean;
    _dropdown: ComponentLoader<BsDropdownContainerComponent>;
    _dropup: boolean;
    _subscriptions: Subscription[];
    _isInited: boolean;
    _isDropupDefault: boolean;
    constructor(_elementRef: ElementRef, _renderer: Renderer2, _viewContainerRef: ViewContainerRef, _cis: ComponentLoaderFactory, _config: BsDropdownConfig, _state: BsDropdownState, cdRef: ChangeDetectorRef);
    ngOnInit(): void;
    /**
     * Opens an element’s popover. This is considered a “manual” triggering of
     * the popover.
     */
    show(): void;
    /**
     * Closes an element’s popover. This is considered a “manual” triggering of
     * the popover.
     */
    hide(): void;
    /**
     * Toggles an element’s popover. This is considered a “manual” triggering of
     * the popover.
     */
    toggle(value?: boolean): void;
    ngOnDestroy(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<BsDropdownDirective>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<BsDropdownDirective, "[mdbDropdown],[dropdown]", ["bs-dropdown"], {
    "dropupDefault": "dropupDefault";
    "dynamicPosition": "dynamicPosition";
    "autoClose": "autoClose";
    "isDisabled": "isDisabled";
    "isOpen": "isOpen";
    "dropup": "dropup";
    "placement": "placement";
    "triggers": "triggers";
    "container": "container";
}, {
    "onShown": "onShown";
    "shown": "shown";
    "onHidden": "onHidden";
    "hidden": "hidden";
    "isOpenChange": "isOpenChange";
}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJvcGRvd24uZGlyZWN0aXZlLmQudHMiLCJzb3VyY2VzIjpbImRyb3Bkb3duLmRpcmVjdGl2ZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFGQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVsZW1lbnRSZWYsIEVtYmVkZGVkVmlld1JlZiwgRXZlbnRFbWl0dGVyLCBPbkRlc3Ryb3ksIE9uSW5pdCwgUmVuZGVyZXIyLCBWaWV3Q29udGFpbmVyUmVmLCBDaGFuZ2VEZXRlY3RvclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBDb21wb25lbnRMb2FkZXIgfSBmcm9tICcuLi91dGlscy9jb21wb25lbnQtbG9hZGVyL2NvbXBvbmVudC1sb2FkZXIuY2xhc3MnO1xuaW1wb3J0IHsgQ29tcG9uZW50TG9hZGVyRmFjdG9yeSB9IGZyb20gJy4uL3V0aWxzL2NvbXBvbmVudC1sb2FkZXIvY29tcG9uZW50LWxvYWRlci5mYWN0b3J5JztcbmltcG9ydCB7IEJzRHJvcGRvd25Db25maWcgfSBmcm9tICcuL2Ryb3Bkb3duLmNvbmZpZyc7XG5pbXBvcnQgeyBCc0Ryb3Bkb3duQ29udGFpbmVyQ29tcG9uZW50IH0gZnJvbSAnLi9kcm9wZG93bi1jb250YWluZXIuY29tcG9uZW50JztcbmltcG9ydCB7IEJzRHJvcGRvd25TdGF0ZSB9IGZyb20gJy4vZHJvcGRvd24uc3RhdGUnO1xuaW1wb3J0IHsgQnNEcm9wZG93bk1lbnVEaXJlY3RpdmUgfSBmcm9tICcuL2Ryb3Bkb3duLW1lbnUuZGlyZWN0aXZlJztcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEJzRHJvcGRvd25EaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBfZWxlbWVudFJlZjtcbiAgICBwcml2YXRlIF9yZW5kZXJlcjtcbiAgICBwcml2YXRlIF92aWV3Q29udGFpbmVyUmVmO1xuICAgIHByaXZhdGUgX2NpcztcbiAgICBwcml2YXRlIF9jb25maWc7XG4gICAgcHJpdmF0ZSBfc3RhdGU7XG4gICAgcHJpdmF0ZSBjZFJlZjtcbiAgICAvKipcbiAgICAgKiBQbGFjZW1lbnQgb2YgYSBwb3BvdmVyLiBBY2NlcHRzOiBcInRvcFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIiwgXCJyaWdodFwiXG4gICAgICovXG4gICAgcGxhY2VtZW50OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIGV2ZW50cyB0aGF0IHNob3VsZCB0cmlnZ2VyLiBTdXBwb3J0cyBhIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mXG4gICAgICogZXZlbnQgbmFtZXMuXG4gICAgICovXG4gICAgdHJpZ2dlcnM6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBBIHNlbGVjdG9yIHNwZWNpZnlpbmcgdGhlIGVsZW1lbnQgdGhlIHBvcG92ZXIgc2hvdWxkIGJlIGFwcGVuZGVkIHRvLlxuICAgICAqIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIFwiYm9keVwiLlxuICAgICAqL1xuICAgIGNvbnRhaW5lcjogc3RyaW5nO1xuICAgIGRyb3B1cDogYm9vbGVhbjtcbiAgICBkcm9wdXBEZWZhdWx0OiBib29sZWFuO1xuICAgIGR5bmFtaWNQb3NpdGlvbjogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBUaGlzIGF0dHJpYnV0ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgZHJvcGRvd24gc2hvdWxkIGJlIG9wZW5lZCB1cHdhcmRzXG4gICAgICovXG4gICAgcmVhZG9ubHkgaXNEcm9wdXA6IHRydWU7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgZHJvcGRvd24gd2lsbCBiZSBjbG9zZWQgb24gaXRlbSBvciBkb2N1bWVudCBjbGljayxcbiAgICAgKiBhbmQgYWZ0ZXIgcHJlc3NpbmcgRVNDXG4gICAgICovXG4gICAgYXV0b0Nsb3NlOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIERpc2FibGVzIGRyb3Bkb3duIHRvZ2dsZSBhbmQgaGlkZXMgZHJvcGRvd24gbWVudSBpZiBvcGVuZWRcbiAgICAgKi9cbiAgICBpc0Rpc2FibGVkOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHBvcG92ZXIgaXMgY3VycmVudGx5IGJlaW5nIHNob3duXG4gICAgICovXG4gICAgaXNPcGVuOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gaXNPcGVuIGNoYW5nZVxuICAgICAqL1xuICAgIGlzT3BlbkNoYW5nZTogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgd2hlbiB0aGUgcG9wb3ZlciBpcyBzaG93blxuICAgICAqL1xuICAgIG9uU2hvd246IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIHNob3duOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBwb3BvdmVyIGlzIGhpZGRlblxuICAgICAqL1xuICAgIG9uSGlkZGVuOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICBoaWRkZW46IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIHByaXZhdGUgX2Rlc3Ryb3kkO1xuICAgIHJlYWRvbmx5IGlzQnM0OiBib29sZWFuO1xuICAgIF9pc0lubGluZU9wZW46IGJvb2xlYW47XG4gICAgX3Nob3dJbmxpbmU6IGJvb2xlYW47XG4gICAgX2lubGluZWRNZW51OiBFbWJlZGRlZFZpZXdSZWY8QnNEcm9wZG93bk1lbnVEaXJlY3RpdmU+O1xuICAgIF9pc0Rpc2FibGVkOiBib29sZWFuO1xuICAgIF9kcm9wZG93bjogQ29tcG9uZW50TG9hZGVyPEJzRHJvcGRvd25Db250YWluZXJDb21wb25lbnQ+O1xuICAgIF9kcm9wdXA6IGJvb2xlYW47XG4gICAgX3N1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdO1xuICAgIF9pc0luaXRlZDogYm9vbGVhbjtcbiAgICBfaXNEcm9wdXBEZWZhdWx0OiBib29sZWFuO1xuICAgIGNvbnN0cnVjdG9yKF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCBfcmVuZGVyZXI6IFJlbmRlcmVyMiwgX3ZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsIF9jaXM6IENvbXBvbmVudExvYWRlckZhY3RvcnksIF9jb25maWc6IEJzRHJvcGRvd25Db25maWcsIF9zdGF0ZTogQnNEcm9wZG93blN0YXRlLCBjZFJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYpO1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogT3BlbnMgYW4gZWxlbWVudOKAmXMgcG9wb3Zlci4gVGhpcyBpcyBjb25zaWRlcmVkIGEg4oCcbWFudWFs4oCdIHRyaWdnZXJpbmcgb2ZcbiAgICAgKiB0aGUgcG9wb3Zlci5cbiAgICAgKi9cbiAgICBzaG93KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIGFuIGVsZW1lbnTigJlzIHBvcG92ZXIuIFRoaXMgaXMgY29uc2lkZXJlZCBhIOKAnG1hbnVhbOKAnSB0cmlnZ2VyaW5nIG9mXG4gICAgICogdGhlIHBvcG92ZXIuXG4gICAgICovXG4gICAgaGlkZSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgYW4gZWxlbWVudOKAmXMgcG9wb3Zlci4gVGhpcyBpcyBjb25zaWRlcmVkIGEg4oCcbWFudWFs4oCdIHRyaWdnZXJpbmcgb2ZcbiAgICAgKiB0aGUgcG9wb3Zlci5cbiAgICAgKi9cbiAgICB0b2dnbGUodmFsdWU/OiBib29sZWFuKTogdm9pZDtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xufVxuIl19